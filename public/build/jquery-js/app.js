/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./assets/js/jquery.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/js/jquery.js":
/*!*****************************!*\
  !*** ./assets/js/jquery.js ***!
  \*****************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
(function (global, factory) {

    "use strict";

    if (( false ? "undefined" : _typeof(module)) === "object" && _typeof(module.exports) === "object") {

        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info.
        module.exports = global.document ? factory(global, true) : function (w) {
            if (!w.document) {
                throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
        };
    } else {
        factory(global);
    }

    // Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

    // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
    // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
    // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
    // enough that all such attempts are guarded in a try block.
    "use strict";

    var arr = [];

    var document = window.document;

    var getProto = Object.getPrototypeOf;

    var _slice = arr.slice;

    var concat = arr.concat;

    var push = arr.push;

    var indexOf = arr.indexOf;

    var class2type = {};

    var toString = class2type.toString;

    var hasOwn = class2type.hasOwnProperty;

    var fnToString = hasOwn.toString;

    var ObjectFunctionString = fnToString.call(Object);

    var support = {};

    var isFunction = function isFunction(obj) {

        // Support: Chrome <=57, Firefox <=52
        // In some browsers, typeof returns "function" for HTML <object> elements
        // (i.e., `typeof document.createElement( "object" ) === "function"`).
        // We don't want to classify *any* DOM node as a function.
        return typeof obj === "function" && typeof obj.nodeType !== "number";
    };

    var isWindow = function isWindow(obj) {
        return obj != null && obj === obj.window;
    };

    var preservedScriptAttributes = {
        type: true,
        src: true,
        noModule: true
    };

    function DOMEval(code, doc, node) {
        doc = doc || document;

        var i,
            script = doc.createElement("script");

        script.text = code;
        if (node) {
            for (i in preservedScriptAttributes) {
                if (node[i]) {
                    script[i] = node[i];
                }
            }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
    }

    function toType(obj) {
        if (obj == null) {
            return obj + "";
        }

        // Support: Android <=2.3 only (functionish RegExp)
        return (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
    }
    /* global Symbol */
    // Defining this global in .eslintrc.json would create a danger of using the global
    // unguarded in another place, it seems safer to define global only for this module


    var version = "3.3.1",


    // Define a local copy of jQuery
    jQuery = function jQuery(selector, context) {

        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init(selector, context);
    },


    // Support: Android <=4.0 only
    // Make sure we trim BOM and NBSP
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

    jQuery.fn = jQuery.prototype = {

        // The current version of jQuery being used
        jquery: version,

        constructor: jQuery,

        // The default length of a jQuery object is 0
        length: 0,

        toArray: function toArray() {
            return _slice.call(this);
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function get(num) {

            // Return all the elements in a clean array
            if (num == null) {
                return _slice.call(this);
            }

            // Return just the one element from the set
            return num < 0 ? this[num + this.length] : this[num];
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function pushStack(elems) {

            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        each: function each(callback) {
            return jQuery.each(this, callback);
        },

        map: function map(callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },

        slice: function slice() {
            return this.pushStack(_slice.apply(this, arguments));
        },

        first: function first() {
            return this.eq(0);
        },

        last: function last() {
            return this.eq(-1);
        },

        eq: function eq(i) {
            var len = this.length,
                j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },

        end: function end() {
            return this.prevObject || this.constructor();
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function () {
        var options,
            name,
            src,
            copy,
            copyIsArray,
            clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;

            // Skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if ((typeof target === "undefined" ? "undefined" : _typeof(target)) !== "object" && !isFunction(target)) {
            target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }

        for (; i < length; i++) {

            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) {

                // Extend the base object
                for (name in options) {
                    src = target[name];
                    copy = options[name];

                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {

                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && Array.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[name] = jQuery.extend(deep, clone, copy);

                        // Don't bring in undefined values
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    jQuery.extend({

        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

        // Assume jQuery is ready without the ready module
        isReady: true,

        error: function error(msg) {
            throw new Error(msg);
        },

        noop: function noop() {},

        isPlainObject: function isPlainObject(obj) {
            var proto, Ctor;

            // Detect obvious negatives
            // Use toString instead of jQuery.type to catch host objects
            if (!obj || toString.call(obj) !== "[object Object]") {
                return false;
            }

            proto = getProto(obj);

            // Objects with no prototype (e.g., `Object.create( null )`) are plain
            if (!proto) {
                return true;
            }

            // Objects with prototype are plain iff they were constructed by a global Object function
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },

        isEmptyObject: function isEmptyObject(obj) {

            /* eslint-disable no-unused-vars */
            // See https://github.com/eslint/eslint/issues/6125
            var name;

            for (name in obj) {
                return false;
            }
            return true;
        },

        // Evaluates a script in a global context
        globalEval: function globalEval(code) {
            DOMEval(code);
        },

        each: function each(obj, callback) {
            var length,
                i = 0;

            if (isArrayLike(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }

            return obj;
        },

        // Support: Android <=4.0 only
        trim: function trim(text) {
            return text == null ? "" : (text + "").replace(rtrim, "");
        },

        // results is for internal usage only
        makeArray: function makeArray(arr, results) {
            var ret = results || [];

            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }

            return ret;
        },

        inArray: function inArray(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },

        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function merge(first, second) {
            var len = +second.length,
                j = 0,
                i = first.length;

            for (; j < len; j++) {
                first[i++] = second[j];
            }

            first.length = i;

            return first;
        },

        grep: function grep(elems, callback, invert) {
            var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;

            // Go through the array, only saving the items
            // that pass the validator function
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }

            return matches;
        },

        // arg is for internal usage only
        map: function map(elems, callback, arg) {
            var length,
                value,
                i = 0,
                ret = [];

            // Go through the array, translating each of the items to their new values
            if (isArrayLike(elems)) {
                length = elems.length;
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }

                // Go through every key on the object,
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }
            }

            // Flatten any nested arrays
            return concat.apply([], ret);
        },

        // A global GUID counter for objects
        guid: 1,

        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    });

    if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }

    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });

    function isArrayLike(obj) {

        // Support: real iOS 8.2 only (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length" in obj && obj.length,
            type = toType(obj);

        if (isFunction(obj) || isWindow(obj)) {
            return false;
        }

        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle =
    /*!
     * Sizzle CSS Selector Engine v2.3.3
     * https://sizzlejs.com/
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * Date: 2016-08-08
     */
    function (window) {

        var i,
            support,
            Expr,
            getText,
            isXML,
            tokenize,
            compile,
            select,
            outermostContext,
            sortInput,
            hasDuplicate,


        // Local document vars
        setDocument,
            document,
            docElem,
            documentIsHTML,
            rbuggyQSA,
            rbuggyMatches,
            matches,
            contains,


        // Instance-specific data
        expando = "sizzle" + 1 * new Date(),
            preferredDoc = window.document,
            dirruns = 0,
            done = 0,
            classCache = createCache(),
            tokenCache = createCache(),
            compilerCache = createCache(),
            sortOrder = function sortOrder(a, b) {
            if (a === b) {
                hasDuplicate = true;
            }
            return 0;
        },


        // Instance methods
        hasOwn = {}.hasOwnProperty,
            arr = [],
            pop = arr.pop,
            push_native = arr.push,
            push = arr.push,
            slice = arr.slice,

        // Use a stripped-down indexOf as it's faster than native
        // https://jsperf.com/thor-indexof-vs-for/5
        indexOf = function indexOf(list, elem) {
            var i = 0,
                len = list.length;
            for (; i < len; i++) {
                if (list[i] === elem) {
                    return i;
                }
            }
            return -1;
        },
            booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",


        // Regular expressions

        // http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]",


        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
        identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",


        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
        // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace +
        // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
            pseudos = ":(" + identifier + ")(?:\\((" +
        // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
        // 2. simple (capture 6)
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
        // 3. anything else (capture 2)
        ".*" + ")\\)|)",


        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + "+", "g"),
            rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
            rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
            rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
            rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
            rpseudo = new RegExp(pseudos),
            ridentifier = new RegExp("^" + identifier + "$"),
            matchExpr = {
            "ID": new RegExp("^#(" + identifier + ")"),
            "CLASS": new RegExp("^\\.(" + identifier + ")"),
            "TAG": new RegExp("^(" + identifier + "|[*])"),
            "ATTR": new RegExp("^" + attributes),
            "PSEUDO": new RegExp("^" + pseudos),
            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            "bool": new RegExp("^(?:" + booleans + ")$", "i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
            rinputs = /^(?:input|select|textarea|button)$/i,
            rheader = /^h\d$/i,
            rnative = /^[^{]+\{\s*\[native \w/,


        // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            rsibling = /[+~]/,


        // CSS escapes
        // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
            funescape = function funescape(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 0x10000;
            // NaN means non-codepoint
            // Support: Firefox<24
            // Workaround erroneous numeric interpretation of +"0x"
            return high !== high || escapedWhitespace ? escaped : high < 0 ?
            // BMP codepoint
            String.fromCharCode(high + 0x10000) :
            // Supplemental Plane codepoint (surrogate pair)
            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },


        // CSS string/identifier serialization
        // https://drafts.csswg.org/cssom/#common-serializing-idioms
        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
            fcssescape = function fcssescape(ch, asCodePoint) {
            if (asCodePoint) {

                // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                if (ch === "\0") {
                    return "\uFFFD";
                }

                // Control characters and (dependent upon position) numbers get escaped as code points
                return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
            }

            // Other potentially-special ASCII characters get backslash-escaped
            return "\\" + ch;
        },


        // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function unloadHandler() {
            setDocument();
        },
            disabledAncestor = addCombinator(function (elem) {
            return elem.disabled === true && ("form" in elem || "label" in elem);
        }, { dir: "parentNode", next: "legend" });

        // Optimize for push.apply( _, NodeList )
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            // Support: Android<4.0
            // Detect silently failing push.apply
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ?

                // Leverage slice if possible
                function (target, els) {
                    push_native.apply(target, slice.call(els));
                } :

                // Support: IE<9
                // Otherwise append directly
                function (target, els) {
                    var j = target.length,
                        i = 0;
                    // Can't trust NodeList.length
                    while (target[j++] = els[i++]) {}
                    target.length = j - 1;
                }
            };
        }

        function Sizzle(selector, context, results, seed) {
            var m,
                i,
                elem,
                nid,
                match,
                groups,
                newSelector,
                newContext = context && context.ownerDocument,


            // nodeType defaults to 9, since context defaults to document
            nodeType = context ? context.nodeType : 9;

            results = results || [];

            // Return early from calls with invalid selector or context
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

                return results;
            }

            // Try to shortcut find operations (as opposed to filters) in HTML documents
            if (!seed) {

                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                    setDocument(context);
                }
                context = context || document;

                if (documentIsHTML) {

                    // If the selector is sufficiently simple, try using a "get*By*" DOM method
                    // (excepting DocumentFragment context, where the methods don't exist)
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

                        // ID selector
                        if (m = match[1]) {

                            // Document context
                            if (nodeType === 9) {
                                if (elem = context.getElementById(m)) {

                                    // Support: IE, Opera, Webkit
                                    // TODO: identify versions
                                    // getElementById can match elements by name instead of ID
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else {
                                    return results;
                                }

                                // Element context
                            } else {

                                // Support: IE, Opera, Webkit
                                // TODO: identify versions
                                // getElementById can match elements by name instead of ID
                                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {

                                    results.push(elem);
                                    return results;
                                }
                            }

                            // Type selector
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;

                            // Class selector
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {

                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }

                    // Take advantage of querySelectorAll
                    if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {

                        if (nodeType !== 1) {
                            newContext = context;
                            newSelector = selector;

                            // qSA looks outside Element context, which is not what we want
                            // Thanks to Andrew Dupont for this workaround technique
                            // Support: IE <=8
                            // Exclude object elements
                        } else if (context.nodeName.toLowerCase() !== "object") {

                            // Capture the context ID, setting it first if necessary
                            if (nid = context.getAttribute("id")) {
                                nid = nid.replace(rcssescape, fcssescape);
                            } else {
                                context.setAttribute("id", nid = expando);
                            }

                            // Prefix every selector in the list
                            groups = tokenize(selector);
                            i = groups.length;
                            while (i--) {
                                groups[i] = "#" + nid + " " + toSelector(groups[i]);
                            }
                            newSelector = groups.join(",");

                            // Expand context for sibling selectors
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        }

                        if (newSelector) {
                            try {
                                push.apply(results, newContext.querySelectorAll(newSelector));
                                return results;
                            } catch (qsaError) {} finally {
                                if (nid === expando) {
                                    context.removeAttribute("id");
                                }
                            }
                        }
                    }
                }
            }

            // All others
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }

        /**
         * Create key-value caches of limited size
         * @returns {function(string, object)} Returns the Object data after storing it on itself with
         *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
         *	deleting the oldest entry
         */
        function createCache() {
            var keys = [];

            function cache(key, value) {
                // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                if (keys.push(key + " ") > Expr.cacheLength) {
                    // Only keep the most recent entries
                    delete cache[keys.shift()];
                }
                return cache[key + " "] = value;
            }
            return cache;
        }

        /**
         * Mark a function for special use by Sizzle
         * @param {Function} fn The function to mark
         */
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }

        /**
         * Support testing using an element
         * @param {Function} fn Passed the created element and returns a boolean result
         */
        function assert(fn) {
            var el = document.createElement("fieldset");

            try {
                return !!fn(el);
            } catch (e) {
                return false;
            } finally {
                // Remove from its parent by default
                if (el.parentNode) {
                    el.parentNode.removeChild(el);
                }
                // release memory in IE
                el = null;
            }
        }

        /**
         * Adds the same handler for all of the specified attrs
         * @param {String} attrs Pipe-separated list of attributes
         * @param {Function} handler The method that will be applied
         */
        function addHandle(attrs, handler) {
            var arr = attrs.split("|"),
                i = arr.length;

            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }

        /**
         * Checks document order of two siblings
         * @param {Element} a
         * @param {Element} b
         * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
         */
        function siblingCheck(a, b) {
            var cur = b && a,
                diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;

            // Use IE sourceIndex if available on both nodes
            if (diff) {
                return diff;
            }

            // Check if b follows a
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }

            return a ? 1 : -1;
        }

        /**
         * Returns a function to use in pseudos for input types
         * @param {String} type
         */
        function createInputPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }

        /**
         * Returns a function to use in pseudos for buttons
         * @param {String} type
         */
        function createButtonPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }

        /**
         * Returns a function to use in pseudos for :enabled/:disabled
         * @param {Boolean} disabled true for :disabled; false for :enabled
         */
        function createDisabledPseudo(disabled) {

            // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
            return function (elem) {

                // Only certain elements can match :enabled or :disabled
                // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                if ("form" in elem) {

                    // Check for inherited disabledness on relevant non-disabled elements:
                    // * listed form-associated elements in a disabled fieldset
                    //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                    // * option elements in a disabled optgroup
                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                    // All such elements have a "form" property.
                    if (elem.parentNode && elem.disabled === false) {

                        // Option elements defer to a parent optgroup if present
                        if ("label" in elem) {
                            if ("label" in elem.parentNode) {
                                return elem.parentNode.disabled === disabled;
                            } else {
                                return elem.disabled === disabled;
                            }
                        }

                        // Support: IE 6 - 11
                        // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                        return elem.isDisabled === disabled ||

                        // Where there is no isDisabled, check manually
                        /* jshint -W018 */
                        elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
                    }

                    return elem.disabled === disabled;

                    // Try to winnow out elements that can't be disabled before trusting the disabled property.
                    // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                    // even exist on them, let alone have a boolean value.
                } else if ("label" in elem) {
                    return elem.disabled === disabled;
                }

                // Remaining elements are neither :enabled nor :disabled
                return false;
            };
        }

        /**
         * Returns a function to use in pseudos for positionals
         * @param {Function} fn
         */
        function createPositionalPseudo(fn) {
            return markFunction(function (argument) {
                argument = +argument;
                return markFunction(function (seed, matches) {
                    var j,
                        matchIndexes = fn([], seed.length, argument),
                        i = matchIndexes.length;

                    // Match elements found at the specified indexes
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }

        /**
         * Checks a node for validity as a Sizzle context
         * @param {Element|Object=} context
         * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
         */
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
        }

        // Expose support vars for convenience
        support = Sizzle.support = {};

        /**
         * Detects XML nodes
         * @param {Element|Object} elem An element or a document
         * @returns {Boolean} True iff elem is a non-HTML XML node
         */
        isXML = Sizzle.isXML = function (elem) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833)
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };

        /**
         * Sets document-related variables once based on the current document
         * @param {Element|Object} [doc] An element or document object to use to set the document
         * @returns {Object} Returns the current document
         */
        setDocument = Sizzle.setDocument = function (node) {
            var hasCompare,
                subWindow,
                doc = node ? node.ownerDocument || node : preferredDoc;

            // Return early if doc is invalid or already selected
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }

            // Update global variables
            document = doc;
            docElem = document.documentElement;
            documentIsHTML = !isXML(document);

            // Support: IE 9-11, Edge
            // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
            if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {

                // Support: IE 11, Edge
                if (subWindow.addEventListener) {
                    subWindow.addEventListener("unload", unloadHandler, false);

                    // Support: IE 9 - 10 only
                } else if (subWindow.attachEvent) {
                    subWindow.attachEvent("onunload", unloadHandler);
                }
            }

            /* Attributes
            ---------------------------------------------------------------------- */

            // Support: IE<8
            // Verify that getAttribute really returns attributes and not properties
            // (excepting IE8 booleans)
            support.attributes = assert(function (el) {
                el.className = "i";
                return !el.getAttribute("className");
            });

            /* getElement(s)By*
            ---------------------------------------------------------------------- */

            // Check if getElementsByTagName("*") returns only elements
            support.getElementsByTagName = assert(function (el) {
                el.appendChild(document.createComment(""));
                return !el.getElementsByTagName("*").length;
            });

            // Support: IE<9
            support.getElementsByClassName = rnative.test(document.getElementsByClassName);

            // Support: IE<10
            // Check if getElementById returns elements by name
            // The broken getElementById methods don't pick up programmatically-set names,
            // so use a roundabout getElementsByName test
            support.getById = assert(function (el) {
                docElem.appendChild(el).id = expando;
                return !document.getElementsByName || !document.getElementsByName(expando).length;
            });

            // ID filter and find
            if (support.getById) {
                Expr.filter["ID"] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                };
                Expr.find["ID"] = function (id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var elem = context.getElementById(id);
                        return elem ? [elem] : [];
                    }
                };
            } else {
                Expr.filter["ID"] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                };

                // Support: IE 6 - 7 only
                // getElementById is not reliable as a find shortcut
                Expr.find["ID"] = function (id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var node,
                            i,
                            elems,
                            elem = context.getElementById(id);

                        if (elem) {

                            // Verify the id attribute
                            node = elem.getAttributeNode("id");
                            if (node && node.value === id) {
                                return [elem];
                            }

                            // Fall back on getElementsByName
                            elems = context.getElementsByName(id);
                            i = 0;
                            while (elem = elems[i++]) {
                                node = elem.getAttributeNode("id");
                                if (node && node.value === id) {
                                    return [elem];
                                }
                            }
                        }

                        return [];
                    }
                };
            }

            // Tag
            Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") {
                    return context.getElementsByTagName(tag);

                    // DocumentFragment nodes don't have gEBTN
                } else if (support.qsa) {
                    return context.querySelectorAll(tag);
                }
            } : function (tag, context) {
                var elem,
                    tmp = [],
                    i = 0,

                // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                results = context.getElementsByTagName(tag);

                // Filter out possible comments
                if (tag === "*") {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }

                    return tmp;
                }
                return results;
            };

            // Class
            Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
                if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };

            /* QSA/matchesSelector
            ---------------------------------------------------------------------- */

            // QSA and matchesSelector support

            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
            rbuggyMatches = [];

            // qSa(:focus) reports false when true (Chrome 21)
            // We allow this because of a bug in IE8/9 that throws an error
            // whenever `document.activeElement` is accessed on an iframe
            // So, we allow :focus to pass through QSA all the time to avoid the IE error
            // See https://bugs.jquery.com/ticket/13378
            rbuggyQSA = [];

            if (support.qsa = rnative.test(document.querySelectorAll)) {
                // Build QSA regex
                // Regex strategy adopted from Diego Perini
                assert(function (el) {
                    // Select is set to empty string on purpose
                    // This is to test IE's treatment of not explicitly
                    // setting a boolean content attribute,
                    // since its presence should be enough
                    // https://bugs.jquery.com/ticket/12359
                    docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";

                    // Support: IE8, Opera 11-12.16
                    // Nothing should be selected when empty strings follow ^= or $= or *=
                    // The test attribute must be unknown in Opera but "safe" for WinRT
                    // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                    if (el.querySelectorAll("[msallowcapture^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    }

                    // Support: IE8
                    // Boolean attributes and "value" are not treated correctly
                    if (!el.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    }

                    // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                    if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                        rbuggyQSA.push("~=");
                    }

                    // Webkit/Opera - :checked should return selected option elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    // IE8 throws error here and will not see later tests
                    if (!el.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                    }

                    // Support: Safari 8+, iOS 8+
                    // https://bugs.webkit.org/show_bug.cgi?id=136851
                    // In-page `selector#id sibling-combinator selector` fails
                    if (!el.querySelectorAll("a#" + expando + "+*").length) {
                        rbuggyQSA.push(".#.+[+~]");
                    }
                });

                assert(function (el) {
                    el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";

                    // Support: Windows 8 Native Apps
                    // The type and name attributes are restricted during .innerHTML assignment
                    var input = document.createElement("input");
                    input.setAttribute("type", "hidden");
                    el.appendChild(input).setAttribute("name", "D");

                    // Support: IE8
                    // Enforce case-sensitivity of name attribute
                    if (el.querySelectorAll("[name=d]").length) {
                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    }

                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                    // IE8 throws error here and will not see later tests
                    if (el.querySelectorAll(":enabled").length !== 2) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }

                    // Support: IE9-11+
                    // IE's :disabled selector does not pick up the children of disabled fieldsets
                    docElem.appendChild(el).disabled = true;
                    if (el.querySelectorAll(":disabled").length !== 2) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }

                    // Opera 10-11 does not throw on post-comma invalid pseudos
                    el.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }

            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {

                assert(function (el) {
                    // Check to see if it's possible to do matchesSelector
                    // on a disconnected node (IE 9)
                    support.disconnectedMatch = matches.call(el, "*");

                    // This should fail with an exception
                    // Gecko does not error, returns false instead
                    matches.call(el, "[s!='']:x");
                    rbuggyMatches.push("!=", pseudos);
                });
            }

            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

            /* Contains
            ---------------------------------------------------------------------- */
            hasCompare = rnative.test(docElem.compareDocumentPosition);

            // Element contains another
            // Purposefully self-exclusive
            // As in, an element does not contain itself
            contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a,
                    bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function (a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };

            /* Sorting
            ---------------------------------------------------------------------- */

            // Document order sorting
            sortOrder = hasCompare ? function (a, b) {

                // Flag for duplicate removal
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }

                // Sort on method existence if only one input has compareDocumentPosition
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }

                // Calculate position if both inputs belong to the same document
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :

                // Otherwise we know they are disconnected
                1;

                // Disconnected nodes
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {

                    // Choose the first element that is related to our preferred document
                    if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }

                    // Maintain original order
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }

                return compare & 4 ? -1 : 1;
            } : function (a, b) {
                // Exit early if the nodes are identical
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }

                var cur,
                    i = 0,
                    aup = a.parentNode,
                    bup = b.parentNode,
                    ap = [a],
                    bp = [b];

                // Parentless nodes are either documents or disconnected
                if (!aup || !bup) {
                    return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;

                    // If the nodes are siblings, we can do a quick check
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }

                // Otherwise we need full lists of their ancestors for comparison
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }

                // Walk down the tree looking for a discrepancy
                while (ap[i] === bp[i]) {
                    i++;
                }

                return i ?
                // Do a sibling check if the nodes have a common ancestor
                siblingCheck(ap[i], bp[i]) :

                // Otherwise nodes in our document sort first
                ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };

            return document;
        };

        Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements);
        };

        Sizzle.matchesSelector = function (elem, expr) {
            // Set document vars if needed
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }

            // Make sure that attribute selectors are quoted
            expr = expr.replace(rattributeQuotes, "='$1']");

            if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {

                try {
                    var ret = matches.call(elem, expr);

                    // IE 9's matchesSelector returns false on disconnected nodes
                    if (ret || support.disconnectedMatch ||
                    // As well, disconnected nodes are said to be in a document
                    // fragment in IE 9
                    elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {}
            }

            return Sizzle(expr, document, null, [elem]).length > 0;
        };

        Sizzle.contains = function (context, elem) {
            // Set document vars if needed
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };

        Sizzle.attr = function (elem, name) {
            // Set document vars if needed
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }

            var fn = Expr.attrHandle[name.toLowerCase()],

            // Don't get fooled by Object.prototype properties (jQuery #13807)
            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };

        Sizzle.escape = function (sel) {
            return (sel + "").replace(rcssescape, fcssescape);
        };

        Sizzle.error = function (msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };

        /**
         * Document sorting and removing duplicates
         * @param {ArrayLike} results
         */
        Sizzle.uniqueSort = function (results) {
            var elem,
                duplicates = [],
                j = 0,
                i = 0;

            // Unless we *know* we can detect duplicates, assume their presence
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);

            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }

            // Clear input after sorting to release objects
            // See https://github.com/jquery/sizzle/pull/225
            sortInput = null;

            return results;
        };

        /**
         * Utility function for retrieving the text value of an array of DOM nodes
         * @param {Array|Element} elem
         */
        getText = Sizzle.getText = function (elem) {
            var node,
                ret = "",
                i = 0,
                nodeType = elem.nodeType;

            if (!nodeType) {
                // If no nodeType, this is expected to be an array
                while (node = elem[i++]) {
                    // Do not traverse comment nodes
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                // Use textContent for elements
                // innerText usage removed for consistency of new lines (jQuery #11153)
                if (typeof elem.textContent === "string") {
                    return elem.textContent;
                } else {
                    // Traverse its children
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            // Do not include comment or processing instruction nodes

            return ret;
        };

        Expr = Sizzle.selectors = {

            // Can be adjusted by the user
            cacheLength: 50,

            createPseudo: markFunction,

            match: matchExpr,

            attrHandle: {},

            find: {},

            relative: {
                ">": { dir: "parentNode", first: true },
                " ": { dir: "parentNode" },
                "+": { dir: "previousSibling", first: true },
                "~": { dir: "previousSibling" }
            },

            preFilter: {
                "ATTR": function ATTR(match) {
                    match[1] = match[1].replace(runescape, funescape);

                    // Move the given value to match[3] whether quoted or unquoted
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                    }

                    return match.slice(0, 4);
                },

                "CHILD": function CHILD(match) {
                    /* matches from matchExpr["CHILD"]
                        1 type (only|nth|...)
                        2 what (child|of-type)
                        3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                        4 xn-component of xn+y argument ([+-]?\d*n|)
                        5 sign of xn-component
                        6 x of xn-component
                        7 sign of y-component
                        8 y of y-component
                    */
                    match[1] = match[1].toLowerCase();

                    if (match[1].slice(0, 3) === "nth") {
                        // nth-* requires argument
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }

                        // numeric x and y parameters for Expr.filter.CHILD
                        // remember that false/true cast respectively to 0/1
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd");

                        // other types prohibit arguments
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }

                    return match;
                },

                "PSEUDO": function PSEUDO(match) {
                    var excess,
                        unquoted = !match[6] && match[2];

                    if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                    }

                    // Accept quoted arguments as-is
                    if (match[3]) {
                        match[2] = match[4] || match[5] || "";

                        // Strip excess characters from unquoted arguments
                    } else if (unquoted && rpseudo.test(unquoted) && (
                    // Get excess from tokenize (recursively)
                    excess = tokenize(unquoted, true)) && (
                    // advance to the next closing parenthesis
                    excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                        // excess is a negative index
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }

                    // Return only captures needed by the pseudo filter method (type and argument)
                    return match.slice(0, 3);
                }
            },

            filter: {

                "TAG": function TAG(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function () {
                        return true;
                    } : function (elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },

                "CLASS": function CLASS(className) {
                    var pattern = classCache[className + " "];

                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                    });
                },

                "ATTR": function ATTR(name, operator, check) {
                    return function (elem) {
                        var result = Sizzle.attr(elem, name);

                        if (result == null) {
                            return operator === "!=";
                        }
                        if (!operator) {
                            return true;
                        }

                        result += "";

                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    };
                },

                "CHILD": function CHILD(type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth",
                        forward = type.slice(-4) !== "last",
                        ofType = what === "of-type";

                    return first === 1 && last === 0 ?

                    // Shortcut for :nth-*(n)
                    function (elem) {
                        return !!elem.parentNode;
                    } : function (elem, context, xml) {
                        var cache,
                            uniqueCache,
                            outerCache,
                            node,
                            nodeIndex,
                            start,
                            dir = simple !== forward ? "nextSibling" : "previousSibling",
                            parent = elem.parentNode,
                            name = ofType && elem.nodeName.toLowerCase(),
                            useCache = !xml && !ofType,
                            diff = false;

                        if (parent) {

                            // :(first|last|only)-(child|of-type)
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {

                                            return false;
                                        }
                                    }
                                    // Reverse direction for :only-* (if we haven't yet done so)
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }

                            start = [forward ? parent.firstChild : parent.lastChild];

                            // non-xml :nth-child(...) stores cache data on `parent`
                            if (forward && useCache) {

                                // Seek `elem` from a previously-cached index

                                // ...in a gzip-friendly way
                                node = parent;
                                outerCache = node[expando] || (node[expando] = {});

                                // Support: IE <9 only
                                // Defend against cloned attroperties (jQuery gh-1709)
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

                                cache = uniqueCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];

                                while (node = ++nodeIndex && node && node[dir] || (

                                // Fallback to seeking `elem` from the start
                                diff = nodeIndex = 0) || start.pop()) {

                                    // When found, cache indexes on `parent` and break
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        uniqueCache[type] = [dirruns, nodeIndex, diff];
                                        break;
                                    }
                                }
                            } else {
                                // Use previously-cached element index if available
                                if (useCache) {
                                    // ...in a gzip-friendly way
                                    node = elem;
                                    outerCache = node[expando] || (node[expando] = {});

                                    // Support: IE <9 only
                                    // Defend against cloned attroperties (jQuery gh-1709)
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex;
                                }

                                // xml :nth-child(...)
                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                if (diff === false) {
                                    // Use the same loop as above to seek `elem` from the start
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {

                                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {

                                            // Cache the index of each encountered element
                                            if (useCache) {
                                                outerCache = node[expando] || (node[expando] = {});

                                                // Support: IE <9 only
                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

                                                uniqueCache[type] = [dirruns, diff];
                                            }

                                            if (node === elem) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }

                            // Incorporate the offset, then check against cycle size
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },

                "PSEUDO": function PSEUDO(pseudo, argument) {
                    // pseudo-class names are case-insensitive
                    // http://www.w3.org/TR/selectors/#pseudo-classes
                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                    // Remember that setFilters inherits from pseudos
                    var args,
                        fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

                    // The user may use createPseudo to indicate that
                    // arguments are needed to create the filter function
                    // just as Sizzle does
                    if (fn[expando]) {
                        return fn(argument);
                    }

                    // But maintain support for old signatures
                    if (fn.length > 1) {
                        args = [pseudo, pseudo, "", argument];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                            var idx,
                                matched = fn(seed, argument),
                                i = matched.length;
                            while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function (elem) {
                            return fn(elem, 0, args);
                        };
                    }

                    return fn;
                }
            },

            pseudos: {
                // Potentially complex pseudos
                "not": markFunction(function (selector) {
                    // Trim the selector passed to compile
                    // to avoid treating leading and trailing
                    // spaces as combinators
                    var input = [],
                        results = [],
                        matcher = compile(selector.replace(rtrim, "$1"));

                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                        var elem,
                            unmatched = matcher(seed, null, xml, []),
                            i = seed.length;

                        // Match elements unmatched by `matcher`
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function (elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        // Don't keep the element (issue #299)
                        input[0] = null;
                        return !results.pop();
                    };
                }),

                "has": markFunction(function (selector) {
                    return function (elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),

                "contains": markFunction(function (text) {
                    text = text.replace(runescape, funescape);
                    return function (elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),

                // "Whether an element is represented by a :lang() selector
                // is based solely on the element's language value
                // being equal to the identifier C,
                // or beginning with the identifier C immediately followed by "-".
                // The matching of C against the element's language value is performed case-insensitively.
                // The identifier C does not have to be a valid language name."
                // http://www.w3.org/TR/selectors/#lang-pseudo
                "lang": markFunction(function (lang) {
                    // lang value must be a valid identifier
                    if (!ridentifier.test(lang || "")) {
                        Sizzle.error("unsupported lang: " + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function (elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {

                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),

                // Miscellaneous
                "target": function target(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },

                "root": function root(elem) {
                    return elem === docElem;
                },

                "focus": function focus(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },

                // Boolean properties
                "enabled": createDisabledPseudo(false),
                "disabled": createDisabledPseudo(true),

                "checked": function checked(elem) {
                    // In CSS3, :checked should return both checked and selected elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                },

                "selected": function selected(elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }

                    return elem.selected === true;
                },

                // Contents
                "empty": function empty(elem) {
                    // http://www.w3.org/TR/selectors/#empty-pseudo
                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                    //   but not by others (comment: 8; processing instruction: 7; etc.)
                    // nodeType < 6 works because attributes (2) do not appear as children
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },

                "parent": function parent(elem) {
                    return !Expr.pseudos["empty"](elem);
                },

                // Element/input types
                "header": function header(elem) {
                    return rheader.test(elem.nodeName);
                },

                "input": function input(elem) {
                    return rinputs.test(elem.nodeName);
                },

                "button": function button(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },

                "text": function text(elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (

                    // Support: IE<8
                    // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                    (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },

                // Position-in-collection
                "first": createPositionalPseudo(function () {
                    return [0];
                }),

                "last": createPositionalPseudo(function (matchIndexes, length) {
                    return [length - 1];
                }),

                "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),

                "even": createPositionalPseudo(function (matchIndexes, length) {
                    var i = 0;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "odd": createPositionalPseudo(function (matchIndexes, length) {
                    var i = 1;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; --i >= 0;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; ++i < length;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };

        Expr.pseudos["nth"] = Expr.pseudos["eq"];

        // Add button/input type pseudos
        for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in { submit: true, reset: true }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }

        // Easy API for creating new setFilters
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();

        tokenize = Sizzle.tokenize = function (selector, parseOnly) {
            var matched,
                match,
                tokens,
                type,
                soFar,
                groups,
                preFilters,
                cached = tokenCache[selector + " "];

            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }

            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;

            while (soFar) {

                // Comma and first run
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        // Don't consume trailing commas as valid
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }

                matched = false;

                // Combinators
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        // Cast descendant combinators to space
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }

                // Filters
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }

                if (!matched) {
                    break;
                }
            }

            // Return the length of the invalid excess
            // if we're just parsing
            // Otherwise, throw an error or return tokens
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
            // Cache the tokens
            tokenCache(selector, groups).slice(0);
        };

        function toSelector(tokens) {
            var i = 0,
                len = tokens.length,
                selector = "";
            for (; i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }

        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir,
                skip = combinator.next,
                key = skip || dir,
                checkNonElements = base && key === "parentNode",
                doneName = done++;

            return combinator.first ?
            // Check against closest ancestor/preceding element
            function (elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
                return false;
            } :

            // Check against all ancestor/preceding elements
            function (elem, context, xml) {
                var oldCache,
                    uniqueCache,
                    outerCache,
                    newCache = [dirruns, doneName];

                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});

                            // Support: IE <9 only
                            // Defend against cloned attroperties (jQuery gh-1709)
                            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

                            if (skip && skip === elem.nodeName.toLowerCase()) {
                                elem = elem[dir] || elem;
                            } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {

                                // Assign to newCache so results back-propagate to previous elements
                                return newCache[2] = oldCache[2];
                            } else {
                                // Reuse newcache so results back-propagate to previous elements
                                uniqueCache[key] = newCache;

                                // A match means we're done; a fail means we have to keep checking
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            };
        }

        function elementMatcher(matchers) {
            return matchers.length > 1 ? function (elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }

        function multipleContexts(selector, contexts, results) {
            var i = 0,
                len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }

        function condense(unmatched, map, filter, context, xml) {
            var elem,
                newUnmatched = [],
                i = 0,
                len = unmatched.length,
                mapped = map != null;

            for (; i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }

            return newUnmatched;
        }

        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function (seed, results, context, xml) {
                var temp,
                    i,
                    elem,
                    preMap = [],
                    postMap = [],
                    preexisting = results.length,


                // Get initial elements from seed or context
                elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),


                // Prefilter to get matcher input, preserving a map for seed-results synchronization
                matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
                    matcherOut = matcher ?
                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || (seed ? preFilter : preexisting || postFilter) ?

                // ...intermediate processing is necessary
                [] :

                // ...otherwise use results directly
                results : matcherIn;

                // Find primary matches
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }

                // Apply postFilter
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);

                    // Un-match failing elements by moving them back to matcherIn
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }

                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    // Restore matcherIn since elem is not yet a final match
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }

                        // Move matched elements from seed to results to keep them synchronized
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }

                    // Add elements to results, through postFinder if defined
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }

        function matcherFromTokens(tokens) {
            var checkContext,
                matcher,
                j,
                len = tokens.length,
                leadingRelative = Expr.relative[tokens[0].type],
                implicitRelative = leadingRelative || Expr.relative[" "],
                i = leadingRelative ? 1 : 0,


            // The foundational matcher ensures that elements are reachable from top-level context(s)
            matchContext = addCombinator(function (elem) {
                return elem === checkContext;
            }, implicitRelative, true),
                matchAnyContext = addCombinator(function (elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, true),
                matchers = [function (elem, context, xml) {
                var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                // Avoid hanging onto element (issue #299)
                checkContext = null;
                return ret;
            }];

            for (; i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                    // Return special upon seeing a positional matcher
                    if (matcher[expando]) {
                        // Find the next relative operator (if any) for proper handling
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(
                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                        tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }

            return elementMatcher(matchers);
        }

        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0,
                byElement = elementMatchers.length > 0,
                superMatcher = function superMatcher(seed, context, xml, results, outermost) {
                var elem,
                    j,
                    matcher,
                    matchedCount = 0,
                    i = "0",
                    unmatched = seed && [],
                    setMatched = [],
                    contextBackup = outermostContext,

                // We must always have either seed elements or outermost context
                elems = seed || byElement && Expr.find["TAG"]("*", outermost),

                // Use integer dirruns iff this is the outermost matcher
                dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
                    len = elems.length;

                if (outermost) {
                    outermostContext = context === document || context || outermost;
                }

                // Add elements passing elementMatchers directly to results
                // Support: IE<9, Safari
                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                for (; i !== len && (elem = elems[i]) != null; i++) {
                    if (byElement && elem) {
                        j = 0;
                        if (!context && elem.ownerDocument !== document) {
                            setDocument(elem);
                            xml = !documentIsHTML;
                        }
                        while (matcher = elementMatchers[j++]) {
                            if (matcher(elem, context || document, xml)) {
                                results.push(elem);
                                break;
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                        }
                    }

                    // Track unmatched elements for set filters
                    if (bySet) {
                        // They will have gone through all possible matchers
                        if (elem = !matcher && elem) {
                            matchedCount--;
                        }

                        // Lengthen the array for every element, matched or not
                        if (seed) {
                            unmatched.push(elem);
                        }
                    }
                }

                // `i` is now the count of elements visited above, and adding it to `matchedCount`
                // makes the latter nonnegative.
                matchedCount += i;

                // Apply set filters to unmatched elements
                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                // no element matchers and no seed.
                // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                // numerically zero.
                if (bySet && i !== matchedCount) {
                    j = 0;
                    while (matcher = setMatchers[j++]) {
                        matcher(unmatched, setMatched, context, xml);
                    }

                    if (seed) {
                        // Reintegrate element matches to eliminate the need for sorting
                        if (matchedCount > 0) {
                            while (i--) {
                                if (!(unmatched[i] || setMatched[i])) {
                                    setMatched[i] = pop.call(results);
                                }
                            }
                        }

                        // Discard index placeholder values to get only actual matches
                        setMatched = condense(setMatched);
                    }

                    // Add matches to results
                    push.apply(results, setMatched);

                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {

                        Sizzle.uniqueSort(results);
                    }
                }

                // Override manipulation of globals by nested matchers
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }

                return unmatched;
            };

            return bySet ? markFunction(superMatcher) : superMatcher;
        }

        compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
            var i,
                setMatchers = [],
                elementMatchers = [],
                cached = compilerCache[selector + " "];

            if (!cached) {
                // Generate a function of recursive functions that can be used to check each element
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }

                // Cache the compiled function
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

                // Save selector and tokenization
                cached.selector = selector;
            }
            return cached;
        };

        /**
         * A low-level selection function that works with Sizzle's compiled
         *  selector functions
         * @param {String|Function} selector A selector or a pre-compiled
         *  selector function built with Sizzle.compile
         * @param {Element} context
         * @param {Array} [results]
         * @param {Array} [seed] A set of elements to match against
         */
        select = Sizzle.select = function (selector, context, results, seed) {
            var i,
                tokens,
                token,
                type,
                find,
                compiled = typeof selector === "function" && selector,
                match = !seed && tokenize(selector = compiled.selector || selector);

            results = results || [];

            // Try to minimize operations if there is only one selector in the list and no seed
            // (the latter of which guarantees us context)
            if (match.length === 1) {

                // Reduce context if the leading compound selector is an ID
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;

                        // Precompiled matchers will still verify ancestry, so step up a level
                    } else if (compiled) {
                        context = context.parentNode;
                    }

                    selector = selector.slice(tokens.shift().value.length);
                }

                // Fetch a seed set for right-to-left matching
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];

                    // Abort if we hit a combinator
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        // Search, expanding context for leading sibling combinators
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {

                            // If seed is empty or no tokens remain, we can return early
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }

                            break;
                        }
                    }
                }
            }

            // Compile and execute a filtering function if one is not provided
            // Provide `match` to avoid retokenization if we modified the selector above
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };

        // One-time assignments

        // Sort stability
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

        // Support: Chrome 14-35+
        // Always assume duplicates if they aren't passed to the comparison function
        support.detectDuplicates = !!hasDuplicate;

        // Initialize against the default document
        setDocument();

        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
        // Detached nodes confoundingly follow *each other*
        support.sortDetached = assert(function (el) {
            // Should return 1, but returns 4 (following)
            return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
        });

        // Support: IE<8
        // Prevent attribute/property "interpolation"
        // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
        if (!assert(function (el) {
            el.innerHTML = "<a href='#'></a>";
            return el.firstChild.getAttribute("href") === "#";
        })) {
            addHandle("type|href|height|width", function (elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                }
            });
        }

        // Support: IE<9
        // Use defaultValue in place of getAttribute("value")
        if (!support.attributes || !assert(function (el) {
            el.innerHTML = "<input/>";
            el.firstChild.setAttribute("value", "");
            return el.firstChild.getAttribute("value") === "";
        })) {
            addHandle("value", function (elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === "input") {
                    return elem.defaultValue;
                }
            });
        }

        // Support: IE<9
        // Use getAttributeNode to fetch booleans when getAttribute lies
        if (!assert(function (el) {
            return el.getAttribute("disabled") == null;
        })) {
            addHandle(booleans, function (elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }

        return Sizzle;
    }(window);

    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;

    // Deprecated
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;

    var dir = function dir(elem, _dir, until) {
        var matched = [],
            truncate = until !== undefined;

        while ((elem = elem[_dir]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                    break;
                }
                matched.push(elem);
            }
        }
        return matched;
    };

    var _siblings = function _siblings(n, elem) {
        var matched = [];

        for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
            }
        }

        return matched;
    };

    var rneedsContext = jQuery.expr.match.needsContext;

    function nodeName(elem, name) {

        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    };
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }

        // Single element
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not;
            });
        }

        // Arraylike of elements (jQuery, arguments, Array)
        if (typeof qualifier !== "string") {
            return jQuery.grep(elements, function (elem) {
                return indexOf.call(qualifier, elem) > -1 !== not;
            });
        }

        // Filtered directly for both simple and complex selectors
        return jQuery.filter(qualifier, elements, not);
    }

    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];

        if (not) {
            expr = ":not(" + expr + ")";
        }

        if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }

        return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
        }));
    };

    jQuery.fn.extend({
        find: function find(selector) {
            var i,
                ret,
                len = this.length,
                self = this;

            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }

            ret = this.pushStack([]);

            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }

            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function filter(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function not(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function is(selector) {
            return !!winnow(this,

            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });

    // Initialize a jQuery object


    // A central reference to the root jQuery(document)
    var rootjQuery,


    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    // Shortcut simple #id case for speed
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
        init = jQuery.fn.init = function (selector, context, root) {
        var match, elem;

        // HANDLE: $(""), $(null), $(undefined), $(false)
        if (!selector) {
            return this;
        }

        // Method init() accepts an alternate rootjQuery
        // so migrate can support jQuery.sub (gh-2101)
        root = root || rootjQuery;

        // Handle HTML strings
        if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {

                // Assume that strings that start and end with <> are HTML and skip the regex check
                match = [null, selector, null];
            } else {
                match = rquickExpr.exec(selector);
            }

            // Match html or make sure no context is specified for #id
            if (match && (match[1] || !context)) {

                // HANDLE: $(html) -> $(array)
                if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context;

                    // Option to run scripts is true for back-compat
                    // Intentionally let the error be thrown if parseHTML is not present
                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

                    // HANDLE: $(html, props)
                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                        for (match in context) {

                            // Properties of context are called as methods if possible
                            if (isFunction(this[match])) {
                                this[match](context[match]);

                                // ...and otherwise set as attributes
                            } else {
                                this.attr(match, context[match]);
                            }
                        }
                    }

                    return this;

                    // HANDLE: $(#id)
                } else {
                    elem = document.getElementById(match[2]);

                    if (elem) {

                        // Inject the element directly into the jQuery object
                        this[0] = elem;
                        this.length = 1;
                    }
                    return this;
                }

                // HANDLE: $(expr, $(...))
            } else if (!context || context.jquery) {
                return (context || root).find(selector);

                // HANDLE: $(expr, context)
                // (which is just equivalent to: $(context).find(expr)
            } else {
                return this.constructor(context).find(selector);
            }

            // HANDLE: $(DOMElement)
        } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;

            // HANDLE: $(function)
            // Shortcut for document ready
        } else if (isFunction(selector)) {
            return root.ready !== undefined ? root.ready(selector) :

            // Execute immediately if ready is not present
            selector(jQuery);
        }

        return jQuery.makeArray(selector, this);
    };

    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

    // Initialize central reference
    rootjQuery = jQuery(document);

    var rparentsprev = /^(?:parents|prev(?:Until|All))/,


    // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };

    jQuery.fn.extend({
        has: function has(target) {
            var targets = jQuery(target, this),
                l = targets.length;

            return this.filter(function () {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        closest: function closest(selectors, context) {
            var cur,
                i = 0,
                l = this.length,
                matched = [],
                targets = typeof selectors !== "string" && jQuery(selectors);

            // Positional selectors never match, since there's no _selection_ context
            if (!rneedsContext.test(selectors)) {
                for (; i < l; i++) {
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

                        // Always skip document fragments
                        if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 :

                        // Don't pass non-elements to Sizzle
                        cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {

                            matched.push(cur);
                            break;
                        }
                    }
                }
            }

            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },

        // Determine the position of an element within the set
        index: function index(elem) {

            // No argument, return index in parent
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }

            // Index in selector
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }

            // Locate the position of the desired element
            return indexOf.call(this,

            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem);
        },

        add: function add(selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },

        addBack: function addBack(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });

    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}
        return cur;
    }

    jQuery.each({
        parent: function parent(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function parents(elem) {
            return dir(elem, "parentNode");
        },
        parentsUntil: function parentsUntil(elem, i, until) {
            return dir(elem, "parentNode", until);
        },
        next: function next(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function prev(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function nextAll(elem) {
            return dir(elem, "nextSibling");
        },
        prevAll: function prevAll(elem) {
            return dir(elem, "previousSibling");
        },
        nextUntil: function nextUntil(elem, i, until) {
            return dir(elem, "nextSibling", until);
        },
        prevUntil: function prevUntil(elem, i, until) {
            return dir(elem, "previousSibling", until);
        },
        siblings: function siblings(elem) {
            return _siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function children(elem) {
            return _siblings(elem.firstChild);
        },
        contents: function contents(elem) {
            if (nodeName(elem, "iframe")) {
                return elem.contentDocument;
            }

            // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
            // Treat the template element as a regular one in browsers that
            // don't support it.
            if (nodeName(elem, "template")) {
                elem = elem.content || elem;
            }

            return jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var matched = jQuery.map(this, fn, until);

            if (name.slice(-5) !== "Until") {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }

            if (this.length > 1) {

                // Remove duplicates
                if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched);
                }

                // Reverse order for parents* and prev-derivatives
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }

            return this.pushStack(matched);
        };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;

    // Convert String-formatted options into Object-formatted ones
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }

    /*
     * Create a callback list using the following parameters:
     *
     *	options: an optional list of space-separated options that will change how
     *			the callback list behaves or a more traditional option object
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible options:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */
    jQuery.Callbacks = function (options) {

        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

        var // Flag to know if list is currently firing
        firing,


        // Last fire value for non-forgettable lists
        memory,


        // Flag to know if list was already fired
        _fired,


        // Flag to prevent firing
        _locked,


        // Actual callback list
        list = [],


        // Queue of execution data for repeatable lists
        queue = [],


        // Index of currently firing callback (modified by add/remove as needed)
        firingIndex = -1,


        // Fire callbacks
        fire = function fire() {

            // Enforce single-firing
            _locked = _locked || options.once;

            // Execute callbacks for all pending executions,
            // respecting firingIndex overrides and runtime changes
            _fired = firing = true;
            for (; queue.length; firingIndex = -1) {
                memory = queue.shift();
                while (++firingIndex < list.length) {

                    // Run callback and check for early termination
                    if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {

                        // Jump to end and forget the data so .add doesn't re-fire
                        firingIndex = list.length;
                        memory = false;
                    }
                }
            }

            // Forget the data if we're done with it
            if (!options.memory) {
                memory = false;
            }

            firing = false;

            // Clean up if we're done firing for good
            if (_locked) {

                // Keep an empty list if we have data for future add calls
                if (memory) {
                    list = [];

                    // Otherwise, this object is spent
                } else {
                    list = "";
                }
            }
        },


        // Actual Callbacks object
        self = {

            // Add a callback or a collection of callbacks to the list
            add: function add() {
                if (list) {

                    // If we have memory from a past run, we should fire after adding
                    if (memory && !firing) {
                        firingIndex = list.length - 1;
                        queue.push(memory);
                    }

                    (function add(args) {
                        jQuery.each(args, function (_, arg) {
                            if (isFunction(arg)) {
                                if (!options.unique || !self.has(arg)) {
                                    list.push(arg);
                                }
                            } else if (arg && arg.length && toType(arg) !== "string") {

                                // Inspect recursively
                                add(arg);
                            }
                        });
                    })(arguments);

                    if (memory && !firing) {
                        fire();
                    }
                }
                return this;
            },

            // Remove a callback from the list
            remove: function remove() {
                jQuery.each(arguments, function (_, arg) {
                    var index;
                    while ((index = jQuery.inArray(arg, list, index)) > -1) {
                        list.splice(index, 1);

                        // Handle firing indexes
                        if (index <= firingIndex) {
                            firingIndex--;
                        }
                    }
                });
                return this;
            },

            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function has(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
            },

            // Remove all callbacks from the list
            empty: function empty() {
                if (list) {
                    list = [];
                }
                return this;
            },

            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function disable() {
                _locked = queue = [];
                list = memory = "";
                return this;
            },
            disabled: function disabled() {
                return !list;
            },

            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function lock() {
                _locked = queue = [];
                if (!memory && !firing) {
                    list = memory = "";
                }
                return this;
            },
            locked: function locked() {
                return !!_locked;
            },

            // Call all callbacks with the given context and arguments
            fireWith: function fireWith(context, args) {
                if (!_locked) {
                    args = args || [];
                    args = [context, args.slice ? args.slice() : args];
                    queue.push(args);
                    if (!firing) {
                        fire();
                    }
                }
                return this;
            },

            // Call all the callbacks with the given arguments
            fire: function fire() {
                self.fireWith(this, arguments);
                return this;
            },

            // To know if the callbacks have already been called at least once
            fired: function fired() {
                return !!_fired;
            }
        };

        return self;
    };

    function Identity(v) {
        return v;
    }
    function Thrower(ex) {
        throw ex;
    }

    function adoptValue(value, resolve, reject, noValue) {
        var method;

        try {

            // Check for promise aspect first to privilege synchronous behavior
            if (value && isFunction(method = value.promise)) {
                method.call(value).done(resolve).fail(reject);

                // Other thenables
            } else if (value && isFunction(method = value.then)) {
                method.call(value, resolve, reject);

                // Other non-thenables
            } else {

                // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
                // * false: [ value ].slice( 0 ) => resolve( value )
                // * true: [ value ].slice( 1 ) => resolve()
                resolve.apply(undefined, [value].slice(noValue));
            }

            // For Promises/A+, convert exceptions into rejections
            // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
            // Deferred#then to conditionally suppress rejection.
        } catch (value) {

            // Support: Android 4.0 only
            // Strict mode functions invoked without .call/.apply get global-object context
            reject.apply(undefined, [value]);
        }
    }

    jQuery.extend({

        Deferred: function Deferred(func) {
            var tuples = [

            // action, add listener, callbacks,
            // ... .then handlers, argument index, [final state]
            ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
                _state = "pending",
                _promise = {
                state: function state() {
                    return _state;
                },
                always: function always() {
                    deferred.done(arguments).fail(arguments);
                    return this;
                },
                "catch": function _catch(fn) {
                    return _promise.then(null, fn);
                },

                // Keep pipe for back-compat
                pipe: function pipe() /* fnDone, fnFail, fnProgress */{
                    var fns = arguments;

                    return jQuery.Deferred(function (newDefer) {
                        jQuery.each(tuples, function (i, tuple) {

                            // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                            var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];

                            // deferred.progress(function() { bind to newDefer or newDefer.notify })
                            // deferred.done(function() { bind to newDefer or newDefer.resolve })
                            // deferred.fail(function() { bind to newDefer or newDefer.reject })
                            deferred[tuple[1]](function () {
                                var returned = fn && fn.apply(this, arguments);
                                if (returned && isFunction(returned.promise)) {
                                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                } else {
                                    newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                                }
                            });
                        });
                        fns = null;
                    }).promise();
                },
                then: function then(onFulfilled, onRejected, onProgress) {
                    var maxDepth = 0;
                    function resolve(depth, deferred, handler, special) {
                        return function () {
                            var that = this,
                                args = arguments,
                                mightThrow = function mightThrow() {
                                var returned, then;

                                // Support: Promises/A+ section 2.3.3.3.3
                                // https://promisesaplus.com/#point-59
                                // Ignore double-resolution attempts
                                if (depth < maxDepth) {
                                    return;
                                }

                                returned = handler.apply(that, args);

                                // Support: Promises/A+ section 2.3.1
                                // https://promisesaplus.com/#point-48
                                if (returned === deferred.promise()) {
                                    throw new TypeError("Thenable self-resolution");
                                }

                                // Support: Promises/A+ sections 2.3.3.1, 3.5
                                // https://promisesaplus.com/#point-54
                                // https://promisesaplus.com/#point-75
                                // Retrieve `then` only once
                                then = returned && (

                                // Support: Promises/A+ section 2.3.4
                                // https://promisesaplus.com/#point-64
                                // Only check objects and functions for thenability
                                (typeof returned === "undefined" ? "undefined" : _typeof(returned)) === "object" || typeof returned === "function") && returned.then;

                                // Handle a returned thenable
                                if (isFunction(then)) {

                                    // Special processors (notify) just wait for resolution
                                    if (special) {
                                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));

                                        // Normal processors (resolve) also hook into progress
                                    } else {

                                        // ...and disregard older resolution values
                                        maxDepth++;

                                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                                    }

                                    // Handle all other returned values
                                } else {

                                    // Only substitute handlers pass on context
                                    // and multiple values (non-spec behavior)
                                    if (handler !== Identity) {
                                        that = undefined;
                                        args = [returned];
                                    }

                                    // Process the value(s)
                                    // Default process is resolve
                                    (special || deferred.resolveWith)(that, args);
                                }
                            },


                            // Only normal processors (resolve) catch and reject exceptions
                            process = special ? mightThrow : function () {
                                try {
                                    mightThrow();
                                } catch (e) {

                                    if (jQuery.Deferred.exceptionHook) {
                                        jQuery.Deferred.exceptionHook(e, process.stackTrace);
                                    }

                                    // Support: Promises/A+ section 2.3.3.3.4.1
                                    // https://promisesaplus.com/#point-61
                                    // Ignore post-resolution exceptions
                                    if (depth + 1 >= maxDepth) {

                                        // Only substitute handlers pass on context
                                        // and multiple values (non-spec behavior)
                                        if (handler !== Thrower) {
                                            that = undefined;
                                            args = [e];
                                        }

                                        deferred.rejectWith(that, args);
                                    }
                                }
                            };

                            // Support: Promises/A+ section 2.3.3.3.1
                            // https://promisesaplus.com/#point-57
                            // Re-resolve promises immediately to dodge false rejection from
                            // subsequent errors
                            if (depth) {
                                process();
                            } else {

                                // Call an optional hook to record the stack, in case of exception
                                // since it's otherwise lost when execution goes async
                                if (jQuery.Deferred.getStackHook) {
                                    process.stackTrace = jQuery.Deferred.getStackHook();
                                }
                                window.setTimeout(process);
                            }
                        };
                    }

                    return jQuery.Deferred(function (newDefer) {

                        // progress_handlers.add( ... )
                        tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));

                        // fulfilled_handlers.add( ... )
                        tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));

                        // rejected_handlers.add( ... )
                        tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
                    }).promise();
                },

                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function promise(obj) {
                    return obj != null ? jQuery.extend(obj, _promise) : _promise;
                }
            },
                deferred = {};

            // Add list-specific methods
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2],
                    stateString = tuple[5];

                // promise.progress = list.add
                // promise.done = list.add
                // promise.fail = list.add
                _promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) {
                    list.add(function () {

                        // state = "resolved" (i.e., fulfilled)
                        // state = "rejected"
                        _state = stateString;
                    },

                    // rejected_callbacks.disable
                    // fulfilled_callbacks.disable
                    tuples[3 - i][2].disable,

                    // rejected_handlers.disable
                    // fulfilled_handlers.disable
                    tuples[3 - i][3].disable,

                    // progress_callbacks.lock
                    tuples[0][2].lock,

                    // progress_handlers.lock
                    tuples[0][3].lock);
                }

                // progress_handlers.fire
                // fulfilled_handlers.fire
                // rejected_handlers.fire
                list.add(tuple[3].fire);

                // deferred.notify = function() { deferred.notifyWith(...) }
                // deferred.resolve = function() { deferred.resolveWith(...) }
                // deferred.reject = function() { deferred.rejectWith(...) }
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
                    return this;
                };

                // deferred.notifyWith = list.fireWith
                // deferred.resolveWith = list.fireWith
                // deferred.rejectWith = list.fireWith
                deferred[tuple[0] + "With"] = list.fireWith;
            });

            // Make the deferred a promise
            _promise.promise(deferred);

            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function when(singleValue) {
            var

            // count of uncompleted subordinates
            remaining = arguments.length,


            // count of unprocessed arguments
            i = remaining,


            // subordinate fulfillment data
            resolveContexts = Array(i),
                resolveValues = _slice.call(arguments),


            // the master Deferred
            master = jQuery.Deferred(),


            // subordinate callback factory
            updateFunc = function updateFunc(i) {
                return function (value) {
                    resolveContexts[i] = this;
                    resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;
                    if (! --remaining) {
                        master.resolveWith(resolveContexts, resolveValues);
                    }
                };
            };

            // Single- and empty arguments are adopted like Promise.resolve
            if (remaining <= 1) {
                adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);

                // Use .then() to unwrap secondary thenables (cf. gh-3000)
                if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {

                    return master.then();
                }
            }

            // Multiple arguments are aggregated like Promise.all array elements
            while (i--) {
                adoptValue(resolveValues[i], updateFunc(i), master.reject);
            }

            return master.promise();
        }
    });

    // These usually indicate a programmer mistake during development,
    // warn about them ASAP rather than swallowing them by default.
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

    jQuery.Deferred.exceptionHook = function (error, stack) {

        // Support: IE 8 - 9 only
        // Console exists when dev tools are open, which can happen at any time
        if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
            window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
        }
    };

    jQuery.readyException = function (error) {
        window.setTimeout(function () {
            throw error;
        });
    };

    // The deferred used on DOM ready
    var readyList = jQuery.Deferred();

    jQuery.fn.ready = function (fn) {

        readyList.then(fn)

        // Wrap jQuery.readyException in a function so that the lookup
        // happens at the time of error handling instead of callback
        // registration.
        .catch(function (error) {
            jQuery.readyException(error);
        });

        return this;
    };

    jQuery.extend({

        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Handle when the DOM is ready
        ready: function ready(wait) {

            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }

            // Remember that the DOM is ready
            jQuery.isReady = true;

            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }

            // If there are functions bound, to execute
            readyList.resolveWith(document, [jQuery]);
        }
    });

    jQuery.ready.then = readyList.then;

    // The ready event handler and self cleanup method
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed);
        window.removeEventListener("load", completed);
        jQuery.ready();
    }

    // Catch cases where $(document).ready() is called
    // after the browser event has already occurred.
    // Support: IE <=9 - 10 only
    // Older IE sometimes signals "interactive" too soon
    if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {

        // Handle it asynchronously to allow scripts the opportunity to delay ready
        window.setTimeout(jQuery.ready);
    } else {

        // Use the handy event callback
        document.addEventListener("DOMContentLoaded", completed);

        // A fallback to window.onload, that will always work
        window.addEventListener("load", completed);
    }

    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0,
            len = elems.length,
            bulk = key == null;

        // Sets many values
        if (toType(key) === "object") {
            chainable = true;
            for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw);
            }

            // Sets one value
        } else if (value !== undefined) {
            chainable = true;

            if (!isFunction(value)) {
                raw = true;
            }

            if (bulk) {

                // Bulk operations run against the entire set
                if (raw) {
                    fn.call(elems, value);
                    fn = null;

                    // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function fn(elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }

            if (fn) {
                for (; i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }

        if (chainable) {
            return elems;
        }

        // Gets
        if (bulk) {
            return fn.call(elems);
        }

        return len ? fn(elems[0], key) : emptyGet;
    };

    // Matches dashed string for camelizing
    var rmsPrefix = /^-ms-/,
        rdashAlpha = /-([a-z])/g;

    // Used by camelCase as callback to replace()
    function fcamelCase(all, letter) {
        return letter.toUpperCase();
    }

    // Convert dashed to camelCase; used by the css and data modules
    // Support: IE <=9 - 11, Edge 12 - 15
    // Microsoft forgot to hump their vendor prefix (#9572)
    function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function acceptData(owner) {

        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };

    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }

    Data.uid = 1;

    Data.prototype = {

        cache: function cache(owner) {

            // Check if the owner object already has a cache
            var value = owner[this.expando];

            // If not, create one
            if (!value) {
                value = {};

                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see #8335.
                // Always return an empty object.
                if (acceptData(owner)) {

                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if (owner.nodeType) {
                        owner[this.expando] = value;

                        // Otherwise secure it in a non-enumerable property
                        // configurable must be true to allow the property to be
                        // deleted when data is removed
                    } else {
                        Object.defineProperty(owner, this.expando, {
                            value: value,
                            configurable: true
                        });
                    }
                }
            }

            return value;
        },
        set: function set(owner, data, value) {
            var prop,
                cache = this.cache(owner);

            // Handle: [ owner, key, value ] args
            // Always use camelCase key (gh-2257)
            if (typeof data === "string") {
                cache[camelCase(data)] = value;

                // Handle: [ owner, { properties } ] args
            } else {

                // Copy the properties one-by-one to the cache object
                for (prop in data) {
                    cache[camelCase(prop)] = data[prop];
                }
            }
            return cache;
        },
        get: function get(owner, key) {
            return key === undefined ? this.cache(owner) :

            // Always use camelCase key (gh-2257)
            owner[this.expando] && owner[this.expando][camelCase(key)];
        },
        access: function access(owner, key, value) {

            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if (key === undefined || key && typeof key === "string" && value === undefined) {

                return this.get(owner, key);
            }

            // When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set(owner, key, value);

            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function remove(owner, key) {
            var i,
                cache = owner[this.expando];

            if (cache === undefined) {
                return;
            }

            if (key !== undefined) {

                // Support array or space separated string of keys
                if (Array.isArray(key)) {

                    // If key is an array of keys...
                    // We always set camelCase keys, so remove that.
                    key = key.map(camelCase);
                } else {
                    key = camelCase(key);

                    // If a key with the spaces exists, use it.
                    // Otherwise, create an array by matching non-whitespace
                    key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
                }

                i = key.length;

                while (i--) {
                    delete cache[key[i]];
                }
            }

            // Remove the expando if there's no more data
            if (key === undefined || jQuery.isEmptyObject(cache)) {

                // Support: Chrome <=35 - 45
                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                if (owner.nodeType) {
                    owner[this.expando] = undefined;
                } else {
                    delete owner[this.expando];
                }
            }
        },
        hasData: function hasData(owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();

    var dataUser = new Data();

    //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /[A-Z]/g;

    function getData(data) {
        if (data === "true") {
            return true;
        }

        if (data === "false") {
            return false;
        }

        if (data === "null") {
            return null;
        }

        // Only convert to a number if it doesn't change the string
        if (data === +data + "") {
            return +data;
        }

        if (rbrace.test(data)) {
            return JSON.parse(data);
        }

        return data;
    }

    function dataAttr(elem, key, data) {
        var name;

        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);

            if (typeof data === "string") {
                try {
                    data = getData(data);
                } catch (e) {}

                // Make sure we set the data so it isn't changed later
                dataUser.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }

    jQuery.extend({
        hasData: function hasData(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },

        data: function data(elem, name, _data) {
            return dataUser.access(elem, name, _data);
        },

        removeData: function removeData(elem, name) {
            dataUser.remove(elem, name);
        },

        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function _data(elem, name, data) {
            return dataPriv.access(elem, name, data);
        },

        _removeData: function _removeData(elem, name) {
            dataPriv.remove(elem, name);
        }
    });

    jQuery.fn.extend({
        data: function data(key, value) {
            var i,
                name,
                data,
                elem = this[0],
                attrs = elem && elem.attributes;

            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);

                    if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {

                            // Support: IE 11 only
                            // The attrs elements can be null (#14894)
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        dataPriv.set(elem, "hasDataAttrs", true);
                    }
                }

                return data;
            }

            // Sets multiple values
            if ((typeof key === "undefined" ? "undefined" : _typeof(key)) === "object") {
                return this.each(function () {
                    dataUser.set(this, key);
                });
            }

            return access(this, function (value) {
                var data;

                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if (elem && value === undefined) {

                    // Attempt to get data from the cache
                    // The key will always be camelCased in Data
                    data = dataUser.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }

                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr(elem, key);
                    if (data !== undefined) {
                        return data;
                    }

                    // We tried really hard, but the data doesn't exist.
                    return;
                }

                // Set the data...
                this.each(function () {

                    // We always store the camelCased key
                    dataUser.set(this, key, value);
                });
            }, null, value, arguments.length > 1, null, true);
        },

        removeData: function removeData(key) {
            return this.each(function () {
                dataUser.remove(this, key);
            });
        }
    });

    jQuery.extend({
        queue: function queue(elem, type, data) {
            var queue;

            if (elem) {
                type = (type || "fx") + "queue";
                queue = dataPriv.get(elem, type);

                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || Array.isArray(data)) {
                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },

        dequeue: function dequeue(elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks(elem, type),
                next = function next() {
                jQuery.dequeue(elem, type);
            };

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }

            if (fn) {

                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                // Clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }

            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },

        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function _queueHooks(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function () {
                    dataPriv.remove(elem, [type + "queue", key]);
                })
            });
        }
    });

    jQuery.fn.extend({
        queue: function queue(type, data) {
            var setter = 2;

            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }

            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }

            return data === undefined ? this : this.each(function () {
                var queue = jQuery.queue(this, type, data);

                // Ensure a hooks for this queue
                jQuery._queueHooks(this, type);

                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function dequeue(type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function clearQueue(type) {
            return this.queue(type || "fx", []);
        },

        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function promise(type, obj) {
            var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function resolve() {
                if (! --count) {
                    defer.resolveWith(elements, [elements]);
                }
            };

            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";

            while (i--) {
                tmp = dataPriv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");

    var cssExpand = ["Top", "Right", "Bottom", "Left"];

    var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {

        // isHiddenWithinTree might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;

        // Inline style trumps all
        return elem.style.display === "none" || elem.style.display === "" &&

        // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
    };

    var swap = function swap(elem, options, callback, args) {
        var ret,
            name,
            old = {};

        // Remember the old values, and insert the new ones
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }

        ret = callback.apply(elem, args || []);

        // Revert the old values
        for (name in options) {
            elem.style[name] = old[name];
        }

        return ret;
    };

    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted,
            scale,
            maxIterations = 20,
            currentValue = tween ? function () {
            return tween.cur();
        } : function () {
            return jQuery.css(elem, prop, "");
        },
            initial = currentValue(),
            unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),


        // Starting value computation is required for potential unit mismatches
        initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

        if (initialInUnit && initialInUnit[3] !== unit) {

            // Support: Firefox <=54
            // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
            initial = initial / 2;

            // Trust units reported by jQuery.css
            unit = unit || initialInUnit[3];

            // Iteratively approximate from a nonzero starting point
            initialInUnit = +initial || 1;

            while (maxIterations--) {

                // Evaluate and update our best guess (doubling guesses that zero out).
                // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
                jQuery.style(elem, prop, initialInUnit + unit);
                if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                    maxIterations = 0;
                }
                initialInUnit = initialInUnit / scale;
            }

            initialInUnit = initialInUnit * 2;
            jQuery.style(elem, prop, initialInUnit + unit);

            // Make sure we update the tween properties later on
            valueParts = valueParts || [];
        }

        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;

            // Apply relative offset (+=/-=) if specified
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }

    var defaultDisplayMap = {};

    function getDefaultDisplay(elem) {
        var temp,
            doc = elem.ownerDocument,
            nodeName = elem.nodeName,
            display = defaultDisplayMap[nodeName];

        if (display) {
            return display;
        }

        temp = doc.body.appendChild(doc.createElement(nodeName));
        display = jQuery.css(temp, "display");

        temp.parentNode.removeChild(temp);

        if (display === "none") {
            display = "block";
        }
        defaultDisplayMap[nodeName] = display;

        return display;
    }

    function showHide(elements, show) {
        var display,
            elem,
            values = [],
            index = 0,
            length = elements.length;

        // Determine new display value for elements that need to change
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }

            display = elem.style.display;
            if (show) {

                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                // check is required in this first loop unless we have a nonempty display value (either
                // inline or about-to-be-restored)
                if (display === "none") {
                    values[index] = dataPriv.get(elem, "display") || null;
                    if (!values[index]) {
                        elem.style.display = "";
                    }
                }
                if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                    values[index] = getDefaultDisplay(elem);
                }
            } else {
                if (display !== "none") {
                    values[index] = "none";

                    // Remember what we're overwriting
                    dataPriv.set(elem, "display", display);
                }
            }
        }

        // Set the display of the elements in a second loop to avoid constant reflow
        for (index = 0; index < length; index++) {
            if (values[index] != null) {
                elements[index].style.display = values[index];
            }
        }

        return elements;
    }

    jQuery.fn.extend({
        show: function show() {
            return showHide(this, true);
        },
        hide: function hide() {
            return showHide(this);
        },
        toggle: function toggle(state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }

            return this.each(function () {
                if (isHiddenWithinTree(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;

    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;

    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;

    // We have to close these tags to support XHTML (#13200)
    var wrapMap = {

        // Support: IE <=9 only
        option: [1, "<select multiple='multiple'>", "</select>"],

        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

        _default: [0, "", ""]
    };

    // Support: IE <=9 only
    wrapMap.optgroup = wrapMap.option;

    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    function getAll(context, tag) {

        // Support: IE <=9 - 11 only
        // Use typeof to avoid zero-argument method invocation on host objects (#15151)
        var ret;

        if (typeof context.getElementsByTagName !== "undefined") {
            ret = context.getElementsByTagName(tag || "*");
        } else if (typeof context.querySelectorAll !== "undefined") {
            ret = context.querySelectorAll(tag || "*");
        } else {
            ret = [];
        }

        if (tag === undefined || tag && nodeName(context, tag)) {
            return jQuery.merge([context], ret);
        }

        return ret;
    }

    // Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        var i = 0,
            l = elems.length;

        for (; i < l; i++) {
            dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
        }
    }

    var rhtml = /<|&#?\w+;/;

    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem,
            tmp,
            tag,
            wrap,
            contains,
            j,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i = 0,
            l = elems.length;

        for (; i < l; i++) {
            elem = elems[i];

            if (elem || elem === 0) {

                // Add nodes directly
                if (toType(elem) === "object") {

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                    // Convert non-html into a text node
                } else if (!rhtml.test(elem)) {
                    nodes.push(context.createTextNode(elem));

                    // Convert html into DOM nodes
                } else {
                    tmp = tmp || fragment.appendChild(context.createElement("div"));

                    // Deserialize a standard representation
                    tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

                    // Descend through wrappers to the right content
                    j = wrap[0];
                    while (j--) {
                        tmp = tmp.lastChild;
                    }

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, tmp.childNodes);

                    // Remember the top-level container
                    tmp = fragment.firstChild;

                    // Ensure the created nodes are orphaned (#12392)
                    tmp.textContent = "";
                }
            }
        }

        // Remove wrapper from fragment
        fragment.textContent = "";

        i = 0;
        while (elem = nodes[i++]) {

            // Skip elements already in the context collection (trac-4087)
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                    ignored.push(elem);
                }
                continue;
            }

            contains = jQuery.contains(elem.ownerDocument, elem);

            // Append to fragment
            tmp = getAll(fragment.appendChild(elem), "script");

            // Preserve script evaluation history
            if (contains) {
                setGlobalEval(tmp);
            }

            // Capture executables
            if (scripts) {
                j = 0;
                while (elem = tmp[j++]) {
                    if (rscriptType.test(elem.type || "")) {
                        scripts.push(elem);
                    }
                }
            }
        }

        return fragment;
    }

    (function () {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild(document.createElement("div")),
            input = document.createElement("input");

        // Support: Android 4.0 - 4.3 only
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");

        div.appendChild(input);

        // Support: Android <=4.1 only
        // Older WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

        // Support: IE <=11 only
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();
    var documentElement = document.documentElement;

    var rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

    function returnTrue() {
        return true;
    }

    function returnFalse() {
        return false;
    }

    // Support: IE <=9 only
    // See #13393 for more info
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }

    function _on(elem, types, selector, data, fn, one) {
        var origFn, type;

        // Types can be a map of types/handlers
        if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {

            // ( types-Object, selector, data )
            if (typeof selector !== "string") {

                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for (type in types) {
                _on(elem, type, selector, data, types[type], one);
            }
            return elem;
        }

        if (data == null && fn == null) {

            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === "string") {

                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {

                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = returnFalse;
        } else if (!fn) {
            return elem;
        }

        if (one === 1) {
            origFn = fn;
            fn = function fn(event) {

                // Can use an empty set, since event contains the info
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };

            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function () {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }

    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */
    jQuery.event = {

        global: {},

        add: function add(elem, types, handler, data, selector) {

            var handleObjIn,
                eventHandle,
                tmp,
                events,
                t,
                handleObj,
                special,
                handlers,
                type,
                namespaces,
                origType,
                elemData = dataPriv.get(elem);

            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if (!elemData) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Ensure that invalid selectors throw exceptions at attach time
            // Evaluate against documentElement in case elem is a non-element node (e.g., document)
            if (selector) {
                jQuery.find.matchesSelector(documentElement, selector);
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {

                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }

            // Handle multiple events separated by a space
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();

                // There *must* be a type, no attaching namespace-only handlers
                if (!type) {
                    continue;
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);

                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener if the special events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {

                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }
        },

        // Detach an event or set of events from an element
        remove: function remove(elem, types, handler, selector, mappedTypes) {

            var j,
                origCount,
                tmp,
                events,
                t,
                handleObj,
                special,
                handlers,
                type,
                namespaces,
                origType,
                elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

            if (!elemData || !(events = elemData.events)) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();

                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }

                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

                // Remove matching events
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];

                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);

                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {

                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    delete events[type];
                }
            }

            // Remove data and the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, "handle events");
            }
        },

        dispatch: function dispatch(nativeEvent) {

            // Make a writable jQuery.Event from the native event object
            var event = jQuery.event.fix(nativeEvent);

            var i,
                j,
                ret,
                matched,
                handleObj,
                handlerQueue,
                args = new Array(arguments.length),
                handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
                special = jQuery.event.special[event.type] || {};

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;

            for (i = 1; i < arguments.length; i++) {
                args[i] = arguments[i];
            }

            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }

            // Determine handlers
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);

            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;

                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

                    // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                    // a subset or equal to those in the bound event (both can have no namespace).
                    if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

                        event.handleObj = handleObj;
                        event.data = handleObj.data;

                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }

            return event.result;
        },

        handlers: function handlers(event, _handlers) {
            var i,
                handleObj,
                sel,
                matchedHandlers,
                matchedSelectors,
                handlerQueue = [],
                delegateCount = _handlers.delegateCount,
                cur = event.target;

            // Find delegate handlers
            if (delegateCount &&

            // Support: IE <=9
            // Black-hole SVG <use> instance trees (trac-13180)
            cur.nodeType &&

            // Support: Firefox <=42
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11 only
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event.type === "click" && event.button >= 1)) {

                for (; cur !== this; cur = cur.parentNode || this) {

                    // Don't check non-elements (#13208)
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                        matchedHandlers = [];
                        matchedSelectors = {};
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = _handlers[i];

                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + " ";

                            if (matchedSelectors[sel] === undefined) {
                                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matchedSelectors[sel]) {
                                matchedHandlers.push(handleObj);
                            }
                        }
                        if (matchedHandlers.length) {
                            handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            cur = this;
            if (delegateCount < _handlers.length) {
                handlerQueue.push({ elem: cur, handlers: _handlers.slice(delegateCount) });
            }

            return handlerQueue;
        },

        addProp: function addProp(name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,

                get: isFunction(hook) ? function () {
                    if (this.originalEvent) {
                        return hook(this.originalEvent);
                    }
                } : function () {
                    if (this.originalEvent) {
                        return this.originalEvent[name];
                    }
                },

                set: function set(value) {
                    Object.defineProperty(this, name, {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: value
                    });
                }
            });
        },

        fix: function fix(originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },

        special: {
            load: {

                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            focus: {

                // Fire native event if possible so blur/focus sequence is correct
                trigger: function trigger() {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function trigger() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {

                // For checkbox, fire native event so checked state will be right
                trigger: function trigger() {
                    if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
                        this.click();
                        return false;
                    }
                },

                // For cross-browser consistency, don't fire native .click() on links
                _default: function _default(event) {
                    return nodeName(event.target, "a");
                }
            },

            beforeunload: {
                postDispatch: function postDispatch(event) {

                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };

    jQuery.removeEvent = function (elem, type, handle) {

        // This "if" is needed for plain objects
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
        }
    };

    jQuery.Event = function (src, props) {

        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&

            // Support: Android <=2.3 only
            src.returnValue === false ? returnTrue : returnFalse;

            // Create target properties
            // Support: Safari <=6 - 7 only
            // Target should not be a text node (#504, #13143)
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;

            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || Date.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,

        preventDefault: function preventDefault() {
            var e = this.originalEvent;

            this.isDefaultPrevented = returnTrue;

            if (e && !this.isSimulated) {
                e.preventDefault();
            }
        },
        stopPropagation: function stopPropagation() {
            var e = this.originalEvent;

            this.isPropagationStopped = returnTrue;

            if (e && !this.isSimulated) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function stopImmediatePropagation() {
            var e = this.originalEvent;

            this.isImmediatePropagationStopped = returnTrue;

            if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
            }

            this.stopPropagation();
        }
    };

    // Includes all common event props including KeyEvent and MouseEvent specific props
    jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,

        which: function which(event) {
            var button = event.button;

            // Add which for key events
            if (event.which == null && rkeyEvent.test(event.type)) {
                return event.charCode != null ? event.charCode : event.keyCode;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
                if (button & 1) {
                    return 1;
                }

                if (button & 2) {
                    return 3;
                }

                if (button & 4) {
                    return 2;
                }

                return 0;
            }

            return event.which;
        }
    }, jQuery.event.addProp);

    // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,

            handle: function handle(event) {
                var ret,
                    target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj;

                // For mouseenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });

    jQuery.fn.extend({

        on: function on(types, selector, data, fn) {
            return _on(this, types, selector, data, fn);
        },
        one: function one(types, selector, data, fn) {
            return _on(this, types, selector, data, fn, 1);
        },
        off: function off(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {

                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {

                // ( types-object [, selector] )
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {

                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });

    var

    /* eslint-disable max-len */

    // See https://github.com/eslint/eslint/issues/3229
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,


    /* eslint-enable */

    // Support: IE <=10 - 11, Edge 12 - 13 only
    // In IE/Edge using regex groups here causes severe slowdowns.
    // See https://connect.microsoft.com/IE/feedback/details/1736512/
    rnoInnerhtml = /<script|<style|<link/i,


    // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

    // Prefer a tbody over its parent table for containing new rows
    function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {

            return jQuery(elem).children("tbody")[0] || elem;
        }

        return elem;
    }

    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
        } else {
            elem.removeAttribute("type");
        }

        return elem;
    }

    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

        if (dest.nodeType !== 1) {
            return;
        }

        // 1. Copy private data: events, handlers, etc.
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.access(src);
            pdataCur = dataPriv.set(dest, pdataOld);
            events = pdataOld.events;

            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};

                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }

        // 2. Copy user data
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);

            dataUser.set(dest, udataCur);
        }
    }

    // Fix IE bugs, see support tests
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();

        // Fails to persist the checked state of a cloned checkbox or radio button.
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;

            // Fails to return the selected option to the default selected state when cloning options
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }

    function domManip(collection, args, callback, ignored) {

        // Flatten any nested arrays
        args = concat.apply([], args);

        var fragment,
            first,
            scripts,
            hasScripts,
            node,
            doc,
            i = 0,
            l = collection.length,
            iNoClone = l - 1,
            value = args[0],
            valueIsFunction = isFunction(value);

        // We can't cloneNode fragments that contain checked, in WebKit
        if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
            return collection.each(function (index) {
                var self = collection.eq(index);
                if (valueIsFunction) {
                    args[0] = value.call(this, index, self.html());
                }
                domManip(self, args, callback, ignored);
            });
        }

        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;

            if (fragment.childNodes.length === 1) {
                fragment = first;
            }

            // Require either new content or an interest in ignored elements to invoke the callback
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;

                // Use the original fragment for the last item
                // instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for (; i < l; i++) {
                    node = fragment;

                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);

                        // Keep references to cloned scripts for later restoration
                        if (hasScripts) {

                            // Support: Android <=4.0 only, PhantomJS 1 only
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery.merge(scripts, getAll(node, "script"));
                        }
                    }

                    callback.call(collection[i], node, i);
                }

                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;

                    // Reenable scripts
                    jQuery.map(scripts, restoreScript);

                    // Evaluate executable scripts on first document insertion
                    for (i = 0; i < hasScripts; i++) {
                        node = scripts[i];
                        if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {

                            if (node.src && (node.type || "").toLowerCase() !== "module") {

                                // Optional AJAX dependency, but won't run scripts if not present
                                if (jQuery._evalUrl) {
                                    jQuery._evalUrl(node.src);
                                }
                            } else {
                                DOMEval(node.textContent.replace(rcleanScript, ""), doc, node);
                            }
                        }
                    }
                }
            }
        }

        return collection;
    }

    function _remove(elem, selector, keepData) {
        var node,
            nodes = selector ? jQuery.filter(selector, elem) : elem,
            i = 0;

        for (; (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node));
            }

            if (node.parentNode) {
                if (keepData && jQuery.contains(node.ownerDocument, node)) {
                    setGlobalEval(getAll(node, "script"));
                }
                node.parentNode.removeChild(node);
            }
        }

        return elem;
    }

    jQuery.extend({
        htmlPrefilter: function htmlPrefilter(html) {
            return html.replace(rxhtmlTag, "<$1></$2>");
        },

        clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
            var i,
                l,
                srcElements,
                destElements,
                clone = elem.cloneNode(true),
                inPage = jQuery.contains(elem.ownerDocument, elem);

            // Fix IE cloning issues
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

                // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone);
                srcElements = getAll(elem);

                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);

                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }

            // Preserve script evaluation history
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }

            // Return the cloned set
            return clone;
        },

        cleanData: function cleanData(elems) {
            var data,
                elem,
                type,
                special = jQuery.event.special,
                i = 0;

            for (; (elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                    if (data = elem[dataPriv.expando]) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);

                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }

                        // Support: Chrome <=35 - 45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[dataPriv.expando] = undefined;
                    }
                    if (elem[dataUser.expando]) {

                        // Support: Chrome <=35 - 45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[dataUser.expando] = undefined;
                    }
                }
            }
        }
    });

    jQuery.fn.extend({
        detach: function detach(selector) {
            return _remove(this, selector, true);
        },

        remove: function remove(selector) {
            return _remove(this, selector);
        },

        text: function text(value) {
            return access(this, function (value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function () {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },

        append: function append() {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },

        prepend: function prepend() {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },

        before: function before() {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },

        after: function after() {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },

        empty: function empty() {
            var elem,
                i = 0;

            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {

                    // Prevent memory leaks
                    jQuery.cleanData(getAll(elem, false));

                    // Remove any remaining nodes
                    elem.textContent = "";
                }
            }

            return this;
        },

        clone: function clone(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },

        html: function html(value) {
            return access(this, function (value) {
                var elem = this[0] || {},
                    i = 0,
                    l = this.length;

                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }

                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                    value = jQuery.htmlPrefilter(value);

                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};

                            // Remove element nodes and prevent memory leaks
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                    } catch (e) {}
                }

                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },

        replaceWith: function replaceWith() {
            var ignored = [];

            // Make the changes, replacing each non-ignored context element with the new content
            return domManip(this, arguments, function (elem) {
                var parent = this.parentNode;

                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) {
                        parent.replaceChild(elem, this);
                    }
                }

                // Force callback invocation
            }, ignored);
        }
    });

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems,
                ret = [],
                insert = jQuery(selector),
                last = insert.length - 1,
                i = 0;

            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);

                // Support: Android <=4.0 only, PhantomJS 1 only
                // .get() because push.apply(_, arraylike) throws on ancient WebKit
                push.apply(ret, elems.get());
            }

            return this.pushStack(ret);
        };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

    var getStyles = function getStyles(elem) {

        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;

        if (!view || !view.opener) {
            view = window;
        }

        return view.getComputedStyle(elem);
    };

    var rboxStyle = new RegExp(cssExpand.join("|"), "i");

    (function () {

        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {

            // This is a singleton, we need to execute it only once
            if (!div) {
                return;
            }

            container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
            div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div);

            var divStyle = window.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";

            // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;

            // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
            // Some styles come back with percentage values, even though they shouldn't
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;

            // Support: IE 9 - 11 only
            // Detect misreporting of content dimensions for box-sizing:border-box elements
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;

            // Support: IE 9 only
            // Detect overflow:scroll screwiness (gh-3699)
            div.style.position = "absolute";
            scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

            documentElement.removeChild(container);

            // Nullify the div so it wouldn't be stored in the memory and
            // it will also be a sign that checks already performed
            div = null;
        }

        function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
        }

        var pixelPositionVal,
            boxSizingReliableVal,
            scrollboxSizeVal,
            pixelBoxStylesVal,
            reliableMarginLeftVal,
            container = document.createElement("div"),
            div = document.createElement("div");

        // Finish early in limited (non-browser) environments
        if (!div.style) {
            return;
        }

        // Support: IE <=9 - 11 only
        // Style of cloned element affects source element cloned (#8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";

        jQuery.extend(support, {
            boxSizingReliable: function boxSizingReliable() {
                computeStyleTests();
                return boxSizingReliableVal;
            },
            pixelBoxStyles: function pixelBoxStyles() {
                computeStyleTests();
                return pixelBoxStylesVal;
            },
            pixelPosition: function pixelPosition() {
                computeStyleTests();
                return pixelPositionVal;
            },
            reliableMarginLeft: function reliableMarginLeft() {
                computeStyleTests();
                return reliableMarginLeftVal;
            },
            scrollboxSize: function scrollboxSize() {
                computeStyleTests();
                return scrollboxSizeVal;
            }
        });
    })();

    function curCSS(elem, name, computed) {
        var width,
            minWidth,
            maxWidth,
            ret,


        // Support: Firefox 51+
        // Retrieving style before computed somehow
        // fixes an issue with getting wrong values
        // on detached elements
        style = elem.style;

        computed = computed || getStyles(elem);

        // getPropertyValue is needed for:
        //   .css('filter') (IE 9 only, #12537)
        //   .css('--customProperty) (#3144)
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];

            if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }

            // A tribute to the "awesome hack by Dean Edwards"
            // Android Browser returns percentage for some values,
            // but width seems to be reliably pixels.
            // This is against the CSSOM draft spec:
            // https://drafts.csswg.org/cssom/#resolved-values
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {

                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;

                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }

        return ret !== undefined ?

        // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
        ret + "" : ret;
    }

    function addGetHookIf(conditionFn, hookFn) {

        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function get() {
                if (conditionFn()) {

                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                }

                // Hook needed; redefine it so that the support test is not executed again.
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }

    var

    // Swappable if display is none or starts with table
    // except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rcustomProp = /^--/,
        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
        cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    },
        cssPrefixes = ["Webkit", "Moz", "ms"],
        emptyStyle = document.createElement("div").style;

    // Return a css property mapped to a potentially vendor prefixed property
    function vendorPropName(name) {

        // Shortcut for names that are not vendor prefixed
        if (name in emptyStyle) {
            return name;
        }

        // Check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1),
            i = cssPrefixes.length;

        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
                return name;
            }
        }
    }

    // Return a property mapped along what jQuery.cssProps suggests or to
    // a vendor prefixed property.
    function finalPropName(name) {
        var ret = jQuery.cssProps[name];
        if (!ret) {
            ret = jQuery.cssProps[name] = vendorPropName(name) || name;
        }
        return ret;
    }

    function setPositiveNumber(elem, value, subtract) {

        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec(value);
        return matches ?

        // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }

    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i = dimension === "width" ? 1 : 0,
            extra = 0,
            delta = 0;

        // Adjustment may not be necessary
        if (box === (isBorderBox ? "border" : "content")) {
            return 0;
        }

        for (; i < 4; i += 2) {

            // Both box models exclude margin
            if (box === "margin") {
                delta += jQuery.css(elem, box + cssExpand[i], true, styles);
            }

            // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
            if (!isBorderBox) {

                // Add padding
                delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

                // For "border" or "margin", add border
                if (box !== "padding") {
                    delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);

                    // But still keep track of it otherwise
                } else {
                    extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }

                // If we get here with a border-box (content + padding + border), we're seeking "content" or
                // "padding" or "margin"
            } else {

                // For "content", subtract padding
                if (box === "content") {
                    delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }

                // For "content" or "padding", subtract border
                if (box !== "margin") {
                    delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }

        // Account for positive content-box scroll gutter when requested by providing computedVal
        if (!isBorderBox && computedVal >= 0) {

            // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
            // Assuming integer scroll gutter, subtract the rest and round down
            delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5));
        }

        return delta;
    }

    function getWidthOrHeight(elem, dimension, extra) {

        // Start with computed style
        var styles = getStyles(elem),
            val = curCSS(elem, dimension, styles),
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            valueIsBorderBox = isBorderBox;

        // Support: Firefox <=54
        // Return a confounding non-pixel value or feign ignorance, as appropriate.
        if (rnumnonpx.test(val)) {
            if (!extra) {
                return val;
            }
            val = "auto";
        }

        // Check for style in case a browser which returns unreliable values
        // for getComputedStyle silently falls back to the reliable elem.style
        valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]);

        // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        if (val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") {

            val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)];

            // offsetWidth/offsetHeight provide border-box values
            valueIsBorderBox = true;
        }

        // Normalize "" and auto
        val = parseFloat(val) || 0;

        // Adjust for the element's box model
        return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles,

        // Provide the current computed size to request scroll gutter calculation (gh-3589)
        val) + "px";
    }

    jQuery.extend({

        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function get(elem, computed) {
                    if (computed) {

                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },

        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},

        // Get and set the style property on a DOM Node
        style: function style(elem, name, value, extra) {

            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret,
                type,
                hooks,
                origName = camelCase(name),
                isCustomProp = rcustomProp.test(name),
                style = elem.style;

            // Make sure that we're working with the right name. We don't
            // want to query the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) {
                name = finalPropName(origName);
            }

            // Gets hook for the prefixed version, then unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value === "undefined" ? "undefined" : _typeof(value);

                // Convert "+=" or "-=" to relative numbers (#7345)
                if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);

                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that null and NaN values aren't set (#7116)
                if (value == null || value !== value) {
                    return;
                }

                // If a number was passed in, add the unit (except for certain CSS properties)
                if (type === "number") {
                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                }

                // background-* props affect original clone's values
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {

                    if (isCustomProp) {
                        style.setProperty(name, value);
                    } else {
                        style[name] = value;
                    }
                }
            } else {

                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {

                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function css(elem, name, extra, styles) {
            var val,
                num,
                hooks,
                origName = camelCase(name),
                isCustomProp = rcustomProp.test(name);

            // Make sure that we're working with the right name. We don't
            // want to modify the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) {
                name = finalPropName(origName);
            }

            // Try prefixed name followed by the unprefixed name
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }

            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }

            // Convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }

            // Make numeric if forced or a qualifier was provided and val looks numeric
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }

            return val;
        }
    });

    jQuery.each(["height", "width"], function (i, dimension) {
        jQuery.cssHooks[dimension] = {
            get: function get(elem, computed, extra) {
                if (computed) {

                    // Certain elements can have dimension info if we invisibly show them
                    // but it must have a current display style that would benefit
                    return rdisplayswap.test(jQuery.css(elem, "display")) && (

                    // Support: Safari 8+
                    // Table columns in Safari have non-zero offsetWidth & zero
                    // getBoundingClientRect().width unless display is changed.
                    // Support: IE <=11 only
                    // Running getBoundingClientRect on a disconnected node
                    // in IE throws an error.
                    !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, dimension, extra);
                    }) : getWidthOrHeight(elem, dimension, extra);
                }
            },

            set: function set(elem, value, extra) {
                var matches,
                    styles = getStyles(elem),
                    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                    subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles);

                // Account for unreliable border-box dimensions by comparing offset* to computed and
                // faking a content-box to get border and padding (gh-3699)
                if (isBorderBox && support.scrollboxSize() === styles.position) {
                    subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
                }

                // Convert to pixels if value adjustment is needed
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {

                    elem.style[dimension] = value;
                    value = jQuery.css(elem, dimension);
                }

                return setPositiveNumber(elem, value, subtract);
            }
        };
    });

    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
        if (computed) {
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
                return elem.getBoundingClientRect().left;
            })) + "px";
        }
    });

    // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function expand(value) {
                var i = 0,
                    expanded = {},


                // Assumes a single number if not a string
                parts = typeof value === "string" ? value.split(" ") : [value];

                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }

                return expanded;
            }
        };

        if (prefix !== "margin") {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });

    jQuery.fn.extend({
        css: function css(name, value) {
            return access(this, function (elem, name, value) {
                var styles,
                    len,
                    map = {},
                    i = 0;

                if (Array.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;

                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }

                    return map;
                }

                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        }
    });

    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;

    Tween.prototype = {
        constructor: Tween,
        init: function init(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function cur() {
            var hooks = Tween.propHooks[this.prop];

            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function run(percent) {
            var eased,
                hooks = Tween.propHooks[this.prop];

            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;

            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
        _default: {
            get: function get(tween) {
                var result;

                // Use a property on the element directly when it is not a DOM element,
                // or when there is no matching style property that exists.
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                    return tween.elem[tween.prop];
                }

                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css(tween.elem, tween.prop, "");

                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function set(tween) {

                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };

    // Support: IE <=9 only
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function set(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };

    jQuery.easing = {
        linear: function linear(p) {
            return p;
        },
        swing: function swing(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    };

    jQuery.fx = Tween.prototype.init;

    // Back compat <1.8 extension point
    jQuery.fx.step = {};

    var fxNow,
        inProgress,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rrun = /queueHooks$/;

    function schedule() {
        if (inProgress) {
            if (document.hidden === false && window.requestAnimationFrame) {
                window.requestAnimationFrame(schedule);
            } else {
                window.setTimeout(schedule, jQuery.fx.interval);
            }

            jQuery.fx.tick();
        }
    }

    // Animations created synchronously will run synchronously
    function createFxNow() {
        window.setTimeout(function () {
            fxNow = undefined;
        });
        return fxNow = Date.now();
    }

    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which,
            i = 0,
            attrs = { height: type };

        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }

        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }

        return attrs;
    }

    function createTween(value, prop, animation) {
        var tween,
            collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
            index = 0,
            length = collection.length;
        for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {

                // We're done with this property
                return tween;
            }
        }
    }

    function defaultPrefilter(elem, props, opts) {
        var prop,
            value,
            toggle,
            hooks,
            oldfire,
            propTween,
            restoreDisplay,
            display,
            isBox = "width" in props || "height" in props,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHiddenWithinTree(elem),
            dataShow = dataPriv.get(elem, "fxshow");

        // Queue-skipping animations hijack the fx hooks
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;

            anim.always(function () {

                // Ensure the complete handler is called before this completes
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }

        // Detect show/hide animations
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {

                    // Pretend to be hidden if this is a "show" and
                    // there is still data from a stopped show/hide
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;

                        // Ignore all other no-op show/hide data
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }

        // Bail out if this is a no-op like .hide().hide()
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) {
            return;
        }

        // Restrict "overflow" and "display" styles during box animations
        if (isBox && elem.nodeType === 1) {

            // Support: IE <=9 - 11, Edge 12 - 15
            // Record all 3 overflow attributes because IE does not infer the shorthand
            // from identically-valued overflowX and overflowY and Edge just mirrors
            // the overflowX value there.
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];

            // Identify a display type, preferring old show/hide data over the CSS cascade
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
                restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery.css(elem, "display");
            if (display === "none") {
                if (restoreDisplay) {
                    display = restoreDisplay;
                } else {

                    // Get nonempty value(s) by temporarily forcing visibility
                    showHide([elem], true);
                    restoreDisplay = elem.style.display || restoreDisplay;
                    display = jQuery.css(elem, "display");
                    showHide([elem]);
                }
            }

            // Animate inline elements as inline-block
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
                if (jQuery.css(elem, "float") === "none") {

                    // Restore the original display value at the end of pure show/hide animations
                    if (!propTween) {
                        anim.done(function () {
                            style.display = restoreDisplay;
                        });
                        if (restoreDisplay == null) {
                            display = style.display;
                            restoreDisplay = display === "none" ? "" : display;
                        }
                    }
                    style.display = "inline-block";
                }
            }
        }

        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function () {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }

        // Implement show/hide animations
        propTween = false;
        for (prop in orig) {

            // General show/hide setup for this element animation
            if (!propTween) {
                if (dataShow) {
                    if ("hidden" in dataShow) {
                        hidden = dataShow.hidden;
                    }
                } else {
                    dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
                }

                // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                if (toggle) {
                    dataShow.hidden = !hidden;
                }

                // Show elements before animating them
                if (hidden) {
                    showHide([elem], true);
                }

                /* eslint-disable no-loop-func */

                anim.done(function () {

                    /* eslint-enable no-loop-func */

                    // The final step of a "hide" animation is actually hiding the element
                    if (!hidden) {
                        showHide([elem]);
                    }
                    dataPriv.remove(elem, "fxshow");
                    for (prop in orig) {
                        jQuery.style(elem, prop, orig[prop]);
                    }
                });
            }

            // Per-property setup
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start;
                if (hidden) {
                    propTween.end = propTween.start;
                    propTween.start = 0;
                }
            }
        }
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }

            if (index !== name) {
                props[name] = value;
                delete props[index];
            }

            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];

                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }

    function Animation(elem, properties, options) {
        var result,
            stopped,
            index = 0,
            length = Animation.prefilters.length,
            deferred = jQuery.Deferred().always(function () {

            // Don't match elem in the :animated selector
            delete tick.elem;
        }),
            tick = function tick() {
            if (stopped) {
                return false;
            }
            var currentTime = fxNow || createFxNow(),
                remaining = Math.max(0, animation.startTime + animation.duration - currentTime),


            // Support: Android 2.3 only
            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
            temp = remaining / animation.duration || 0,
                percent = 1 - temp,
                index = 0,
                length = animation.tweens.length;

            for (; index < length; index++) {
                animation.tweens[index].run(percent);
            }

            deferred.notifyWith(elem, [animation, percent, remaining]);

            // If there's more to do, yield
            if (percent < 1 && length) {
                return remaining;
            }

            // If this was an empty animation, synthesize a final progress notification
            if (!length) {
                deferred.notifyWith(elem, [animation, 1, 0]);
            }

            // Resolve the animation and report its conclusion
            deferred.resolveWith(elem, [animation]);
            return false;
        },
            animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
                specialEasing: {},
                easing: jQuery.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function createTween(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function stop(gotoEnd) {
                var index = 0,


                // If we are going to the end, we want to run all the tweens
                // otherwise we skip this part
                length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                    return this;
                }
                stopped = true;
                for (; index < length; index++) {
                    animation.tweens[index].run(1);
                }

                // Resolve when we played the last frame; otherwise, reject
                if (gotoEnd) {
                    deferred.notifyWith(elem, [animation, 1, 0]);
                    deferred.resolveWith(elem, [animation, gotoEnd]);
                } else {
                    deferred.rejectWith(elem, [animation, gotoEnd]);
                }
                return this;
            }
        }),
            props = animation.props;

        propFilter(props, animation.opts.specialEasing);

        for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (isFunction(result.stop)) {
                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
                }
                return result;
            }
        }

        jQuery.map(props, createTween, animation);

        if (isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }

        // Attach callbacks from options
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);

        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));

        return animation;
    }

    jQuery.Animation = jQuery.extend(Animation, {

        tweeners: {
            "*": [function (prop, value) {
                var tween = this.createTween(prop, value);
                adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                return tween;
            }]
        },

        tweener: function tweener(props, callback) {
            if (isFunction(props)) {
                callback = props;
                props = ["*"];
            } else {
                props = props.match(rnothtmlwhite);
            }

            var prop,
                index = 0,
                length = props.length;

            for (; index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },

        prefilters: [defaultPrefilter],

        prefilter: function prefilter(callback, prepend) {
            if (prepend) {
                Animation.prefilters.unshift(callback);
            } else {
                Animation.prefilters.push(callback);
            }
        }
    });

    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && (typeof speed === "undefined" ? "undefined" : _typeof(speed)) === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction(easing) && easing
        };

        // Go to the end state if fx are off
        if (jQuery.fx.off) {
            opt.duration = 0;
        } else {
            if (typeof opt.duration !== "number") {
                if (opt.duration in jQuery.fx.speeds) {
                    opt.duration = jQuery.fx.speeds[opt.duration];
                } else {
                    opt.duration = jQuery.fx.speeds._default;
                }
            }
        }

        // Normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function () {
            if (isFunction(opt.old)) {
                opt.old.call(this);
            }

            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };

        return opt;
    };

    jQuery.fn.extend({
        fadeTo: function fadeTo(speed, to, easing, callback) {

            // Show any hidden elements after setting opacity to 0
            return this.filter(isHiddenWithinTree).css("opacity", 0).show()

            // Animate to the value specified
            .end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function animate(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop),
                optall = jQuery.speed(speed, easing, callback),
                doAnimation = function doAnimation() {

                // Operate on a copy of prop so per-property easing won't be lost
                var anim = Animation(this, jQuery.extend({}, prop), optall);

                // Empty animations, or finishing resolves immediately
                if (empty || dataPriv.get(this, "finish")) {
                    anim.stop(true);
                }
            };
            doAnimation.finish = doAnimation;

            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function stop(type, clearQueue, gotoEnd) {
            var stopQueue = function stopQueue(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };

            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }

            return this.each(function () {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = dataPriv.get(this);

                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }

                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {

                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }

                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function finish(type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function () {
                var index,
                    data = dataPriv.get(this),
                    queue = data[type + "queue"],
                    hooks = data[type + "queueHooks"],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;

                // Enable finishing flag on private data
                data.finish = true;

                // Empty the queue first
                jQuery.queue(this, type, []);

                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }

                // Look for any active animations, and finish them
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }

                // Look for any animations in the old queue and finish them
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }

                // Turn off finishing flag
                delete data.finish;
            });
        }
    });

    jQuery.each(["toggle", "show", "hide"], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });

    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });

    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer,
            i = 0,
            timers = jQuery.timers;

        fxNow = Date.now();

        for (; i < timers.length; i++) {
            timer = timers[i];

            // Run the timer and safely remove it when done (allowing for external removal)
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }

        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };

    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
    };

    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
        if (inProgress) {
            return;
        }

        inProgress = true;
        schedule();
    };

    jQuery.fx.stop = function () {
        inProgress = null;
    };

    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,

        // Default speed
        _default: 400
    };

    // Based off of the plugin by Clint Helfers, with permission.
    // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";

        return this.queue(type, function (next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function () {
                window.clearTimeout(timeout);
            };
        });
    };

    (function () {
        var input = document.createElement("input"),
            select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"));

        input.type = "checkbox";

        // Support: Android <=4.3 only
        // Default value for a checkbox should be "on"
        support.checkOn = input.value !== "";

        // Support: IE <=11 only
        // Must access selectedIndex to make default options select
        support.optSelected = opt.selected;

        // Support: IE <=11 only
        // An input loses its value after becoming a radio
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();

    var boolHook,
        attrHandle = jQuery.expr.attrHandle;

    jQuery.fn.extend({
        attr: function attr(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },

        removeAttr: function removeAttr(name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });

    jQuery.extend({
        attr: function attr(elem, name, value) {
            var ret,
                hooks,
                nType = elem.nodeType;

            // Don't get/set attributes on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
            }

            // Attribute hooks are determined by the lowercase version
            // Grab necessary hook if one is defined
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            }

            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }

                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }

                elem.setAttribute(name, value + "");
                return value;
            }

            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }

            ret = jQuery.find.attr(elem, name);

            // Non-existent attributes return null, we normalize to undefined
            return ret == null ? undefined : ret;
        },

        attrHooks: {
            type: {
                set: function set(elem, value) {
                    if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },

        removeAttr: function removeAttr(elem, value) {
            var name,
                i = 0,


            // Attribute names can contain non-HTML whitespace characters
            // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
            attrNames = value && value.match(rnothtmlwhite);

            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    elem.removeAttribute(name);
                }
            }
        }
    });

    // Hooks for boolean attributes
    boolHook = {
        set: function set(elem, value, name) {
            if (value === false) {

                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };

    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;

        attrHandle[name] = function (elem, name, isXML) {
            var ret,
                handle,
                lowercaseName = name.toLowerCase();

            if (!isXML) {

                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[lowercaseName];
                attrHandle[lowercaseName] = ret;
                ret = getter(elem, name, isXML) != null ? lowercaseName : null;
                attrHandle[lowercaseName] = handle;
            }
            return ret;
        };
    });

    var rfocusable = /^(?:input|select|textarea|button)$/i,
        rclickable = /^(?:a|area)$/i;

    jQuery.fn.extend({
        prop: function prop(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },

        removeProp: function removeProp(name) {
            return this.each(function () {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });

    jQuery.extend({
        prop: function prop(elem, name, value) {
            var ret,
                hooks,
                nType = elem.nodeType;

            // Don't get/set properties on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }

                return elem[name] = value;
            }

            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }

            return elem[name];
        },

        propHooks: {
            tabIndex: {
                get: function get(elem) {

                    // Support: IE <=9 - 11 only
                    // elem.tabIndex doesn't always return the
                    // correct value when it hasn't been explicitly set
                    // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr(elem, "tabindex");

                    if (tabindex) {
                        return parseInt(tabindex, 10);
                    }

                    if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                        return 0;
                    }

                    return -1;
                }
            }
        },

        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    });

    // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    // eslint rule "no-unused-expressions" is disabled for this code
    // since it considers such accessions noop
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function get(elem) {

                /* eslint no-unused-expressions: "off" */

                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function set(elem) {

                /* eslint no-unused-expressions: "off" */

                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;

                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }

    jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });

    // Strip and collapse whitespace according to HTML spec
    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
    function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
    }

    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }

    function classesToArray(value) {
        if (Array.isArray(value)) {
            return value;
        }
        if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
        }
        return [];
    }

    jQuery.fn.extend({
        addClass: function addClass(value) {
            var classes,
                elem,
                cur,
                curValue,
                clazz,
                j,
                finalValue,
                i = 0;

            if (isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
            }

            classes = classesToArray(value);

            if (classes.length) {
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function removeClass(value) {
            var classes,
                elem,
                cur,
                curValue,
                clazz,
                j,
                finalValue,
                i = 0;

            if (isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
            }

            if (!arguments.length) {
                return this.attr("class", "");
            }

            classes = classesToArray(value);

            if (classes.length) {
                while (elem = this[i++]) {
                    curValue = getClass(elem);

                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {

                            // Remove *all* instances
                            while (cur.indexOf(" " + clazz + " ") > -1) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function toggleClass(value, stateVal) {
            var type = typeof value === "undefined" ? "undefined" : _typeof(value),
                isValidValue = type === "string" || Array.isArray(value);

            if (typeof stateVal === "boolean" && isValidValue) {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }

            if (isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
                });
            }

            return this.each(function () {
                var className, i, self, classNames;

                if (isValidValue) {

                    // Toggle individual class names
                    i = 0;
                    self = jQuery(this);
                    classNames = classesToArray(value);

                    while (className = classNames[i++]) {

                        // Check each className given, space separated list
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }

                    // Toggle whole class name
                } else if (value === undefined || type === "boolean") {
                    className = getClass(this);
                    if (className) {

                        // Store className if set
                        dataPriv.set(this, "__className__", className);
                    }

                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    if (this.setAttribute) {
                        this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
                    }
                }
            });
        },

        hasClass: function hasClass(selector) {
            var className,
                elem,
                i = 0;

            className = " " + selector + " ";
            while (elem = this[i++]) {
                if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                    return true;
                }
            }

            return false;
        }
    });

    var rreturn = /\r/g;

    jQuery.fn.extend({
        val: function val(value) {
            var hooks,
                ret,
                valueIsFunction,
                elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }

                    ret = elem.value;

                    // Handle most common string cases
                    if (typeof ret === "string") {
                        return ret.replace(rreturn, "");
                    }

                    // Handle cases where value is null/undef or number
                    return ret == null ? "" : ret;
                }

                return;
            }

            valueIsFunction = isFunction(value);

            return this.each(function (i) {
                var val;

                if (this.nodeType !== 1) {
                    return;
                }

                if (valueIsFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (Array.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function get(elem) {

                    var val = jQuery.find.attr(elem, "value");
                    return val != null ? val :

                    // Support: IE <=10 - 11 only
                    // option.text throws exceptions (#14686, #14858)
                    // Strip and collapse whitespace
                    // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                    stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function get(elem) {
                    var value,
                        option,
                        i,
                        options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one",
                        values = one ? null : [],
                        max = one ? index + 1 : options.length;

                    if (index < 0) {
                        i = max;
                    } else {
                        i = one ? index : 0;
                    }

                    // Loop through all the selected options
                    for (; i < max; i++) {
                        option = options[i];

                        // Support: IE <=9 only
                        // IE8-9 doesn't update selected after form reset (#2551)
                        if ((option.selected || i === index) &&

                        // Don't return options that are disabled or in a disabled optgroup
                        !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {

                            // Get the specific value for the option
                            value = jQuery(option).val();

                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }

                    return values;
                },

                set: function set(elem, value) {
                    var optionSet,
                        option,
                        options = elem.options,
                        values = jQuery.makeArray(value),
                        i = options.length;

                    while (i--) {
                        option = options[i];

                        /* eslint-disable no-cond-assign */

                        if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                            optionSet = true;
                        }

                        /* eslint-enable no-cond-assign */
                    }

                    // Force browsers to behave consistently when non-matching value is set
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });

    // Radios and checkboxes getter/setter
    jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = {
            set: function set(elem, value) {
                if (Array.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });

    // Return jQuery for attributes-only inclusion


    support.focusin = "onfocusin" in window;

    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        stopPropagationCallback = function stopPropagationCallback(e) {
        e.stopPropagation();
    };

    jQuery.extend(jQuery.event, {

        trigger: function trigger(event, data, elem, onlyHandlers) {

            var i,
                cur,
                tmp,
                bubbleType,
                ontype,
                handle,
                special,
                lastElement,
                eventPath = [elem || document],
                type = hasOwn.call(event, "type") ? event.type : event,
                namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

            cur = lastElement = tmp = elem = elem || document;

            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }

            if (type.indexOf(".") > -1) {

                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;

            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[jQuery.expando] ? event : new jQuery.Event(type, (typeof event === "undefined" ? "undefined" : _typeof(event)) === "object" && event);

            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ? [event] : jQuery.makeArray(data, [event]);

            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {

                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }

            // Fire handlers on the event path
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                lastElement = cur;
                event.type = i > 1 ? bubbleType : special.bindType || type;

                // jQuery handler
                handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }

                // Native handler
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {

                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {

                    // Call a native DOM method on the target with the same name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if (ontype && isFunction(elem[type]) && !isWindow(elem)) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ontype];

                        if (tmp) {
                            elem[ontype] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;

                        if (event.isPropagationStopped()) {
                            lastElement.addEventListener(type, stopPropagationCallback);
                        }

                        elem[type]();

                        if (event.isPropagationStopped()) {
                            lastElement.removeEventListener(type, stopPropagationCallback);
                        }

                        jQuery.event.triggered = undefined;

                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }

            return event.result;
        },

        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function simulate(type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
            });

            jQuery.event.trigger(e, null, elem);
        }

    });

    jQuery.fn.extend({

        trigger: function trigger(type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function triggerHandler(type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });

    // Support: Firefox <=44
    // Firefox doesn't have focus(in | out) events
    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    //
    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
    // focus(in | out) events fire after focus & blur events,
    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
    if (!support.focusin) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function handler(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };

            jQuery.event.special[fix] = {
                setup: function setup() {
                    var doc = this.ownerDocument || this,
                        attaches = dataPriv.access(doc, fix);

                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    dataPriv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function teardown() {
                    var doc = this.ownerDocument || this,
                        attaches = dataPriv.access(doc, fix) - 1;

                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        dataPriv.remove(doc, fix);
                    } else {
                        dataPriv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    var location = window.location;

    var nonce = Date.now();

    var rquery = /\?/;

    // Cross-browser xml parsing
    jQuery.parseXML = function (data) {
        var xml;
        if (!data || typeof data !== "string") {
            return null;
        }

        // Support: IE 9 - 11 only
        // IE throws on parseFromString with invalid input.
        try {
            xml = new window.DOMParser().parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }

        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };

    var rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams(prefix, obj, traditional, add) {
        var name;

        if (Array.isArray(obj)) {

            // Serialize array item.
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {

                    // Treat each array item as a scalar.
                    add(prefix, v);
                } else {

                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(prefix + "[" + ((typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" && v != null ? i : "") + "]", v, traditional, add);
                }
            });
        } else if (!traditional && toType(obj) === "object") {

            // Serialize object item.
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
        } else {

            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function (a, traditional) {
        var prefix,
            s = [],
            add = function add(key, valueOrFunction) {

            // If value is a function, invoke it and use its return value
            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;

            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };

        // If an array was passed in, assume that it is an array of form elements.
        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {

            // Serialize the form elements
            jQuery.each(a, function () {
                add(this.name, this.value);
            });
        } else {

            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }

        // Return the resulting serialization
        return s.join("&");
    };

    jQuery.fn.extend({
        serialize: function serialize() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function serializeArray() {
            return this.map(function () {

                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function () {
                var type = this.type;

                // Use .is( ":disabled" ) so that fieldset[disabled] works
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function (i, elem) {
                var val = jQuery(this).val();

                if (val == null) {
                    return null;
                }

                if (Array.isArray(val)) {
                    return jQuery.map(val, function (val) {
                        return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
                    });
                }

                return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }).get();
        }
    });

    var r20 = /%20/g,
        rhash = /#.*$/,
        rantiCache = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,


    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,


    /* Prefilters
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
     * 2) These are called:
     *    - BEFORE asking for a transport
     *    - AFTER param serialization (s.data is a string if s.processData is true)
     * 3) key is the dataType
     * 4) the catchall symbol "*" can be used
     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
     */
    prefilters = {},


    /* Transports bindings
     * 1) key is the dataType
     * 2) the catchall symbol "*" can be used
     * 3) selection will start with transport dataType and THEN go to "*" if needed
     */
    transports = {},


    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*"),


    // Anchor tag for parsing the document origin
    originAnchor = document.createElement("a");
    originAnchor.href = location.href;

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function (dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

            if (isFunction(func)) {

                // For each dataType in the dataTypeExpression
                while (dataType = dataTypes[i++]) {

                    // Prepend if requested
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);

                        // Otherwise append
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

        var inspected = {},
            seekingTransport = structure === transports;

        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {

                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }

        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }

    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var key,
            deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }

        return target;
    }

    /* Handles responses to an ajax request:
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
    function ajaxHandleResponses(s, jqXHR, responses) {

        var ct,
            type,
            finalDataType,
            firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes;

        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }

        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {

            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }

            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    /* Chain conversions given the request and the original response
     * Also sets the responseXXX fields on the jqXHR instance
     */
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2,
            current,
            conv,
            tmp,
            prev,
            converters = {},


        // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();

        // Create converters map with lowercased keys
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }

        current = dataTypes.shift();

        // Convert to each sequential dataType
        while (current) {

            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }

            // Apply the dataFilter if provided
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }

            prev = current;
            current = dataTypes.shift();

            if (current) {

                // There's only work to do if current dataType is non-auto
                if (current === "*") {

                    current = prev;

                    // Convert response if prev dataType is non-auto and differs from current
                } else if (prev !== "*" && prev !== current) {

                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];

                    // If none found, seek a pair
                    if (!conv) {
                        for (conv2 in converters) {

                            // If conv2 outputs current
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {

                                // If prev can be converted to accepted input
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                if (conv) {

                                    // Condense equivalence converters
                                    if (conv === true) {
                                        conv = converters[conv2];

                                        // Otherwise, insert the intermediate dataType
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    // Apply converter (if not an equivalence)
                    if (conv !== true) {

                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s.throws) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }

        return { state: "success", data: response };
    }

    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",

            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            throws: false,
            traditional: false,
            headers: {},
            */

            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },

            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },

            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {

                // Convert anything to text
                "* text": String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": JSON.parse,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function ajaxSetup(target, settings) {
            return settings ?

            // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

            // Extending ajaxSettings
            ajaxExtend(jQuery.ajaxSettings, target);
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function ajax(url, options) {

            // If url is an object, simulate pre-1.5 signature
            if ((typeof url === "undefined" ? "undefined" : _typeof(url)) === "object") {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var transport,


            // URL without anti-cache param
            cacheURL,


            // Response headers
            responseHeadersString,
                responseHeaders,


            // timeout handle
            timeoutTimer,


            // Url cleanup var
            urlAnchor,


            // Request state (becomes false upon send and true upon completion)
            completed,


            // To know if global events are to be dispatched
            fireGlobals,


            // Loop variable
            i,


            // uncached part of the url
            uncached,


            // Create the final options object
            s = jQuery.ajaxSetup({}, options),


            // Callbacks context
            callbackContext = s.context || s,


            // Context for global events is callbackContext if it is a DOM node or jQuery collection
            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,


            // Deferreds
            deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks("once memory"),


            // Status-dependent callbacks
            _statusCode = s.statusCode || {},


            // Headers (they are sent all at once)
            requestHeaders = {},
                requestHeadersNames = {},


            // Default abort message
            strAbort = "canceled",


            // Fake xhr
            jqXHR = {
                readyState: 0,

                // Builds headers hashtable if needed
                getResponseHeader: function getResponseHeader(key) {
                    var match;
                    if (completed) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while (match = rheaders.exec(responseHeadersString)) {
                                responseHeaders[match[1].toLowerCase()] = match[2];
                            }
                        }
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return match == null ? null : match;
                },

                // Raw string
                getAllResponseHeaders: function getAllResponseHeaders() {
                    return completed ? responseHeadersString : null;
                },

                // Caches the header
                setRequestHeader: function setRequestHeader(name, value) {
                    if (completed == null) {
                        name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },

                // Overrides response content-type header
                overrideMimeType: function overrideMimeType(type) {
                    if (completed == null) {
                        s.mimeType = type;
                    }
                    return this;
                },

                // Status-dependent callbacks
                statusCode: function statusCode(map) {
                    var code;
                    if (map) {
                        if (completed) {

                            // Execute the appropriate callbacks
                            jqXHR.always(map[jqXHR.status]);
                        } else {

                            // Lazy-add the new callbacks in a way that preserves old ones
                            for (code in map) {
                                _statusCode[code] = [_statusCode[code], map[code]];
                            }
                        }
                    }
                    return this;
                },

                // Cancel the request
                abort: function abort(statusText) {
                    var finalText = statusText || strAbort;
                    if (transport) {
                        transport.abort(finalText);
                    }
                    done(0, finalText);
                    return this;
                }
            };

            // Attach deferreds
            deferred.promise(jqXHR);

            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");

            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;

            // Extract dataTypes list
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];

            // A cross-domain request is in order when the origin doesn't match the current origin.
            if (s.crossDomain == null) {
                urlAnchor = document.createElement("a");

                // Support: IE <=8 - 11, Edge 12 - 15
                // IE throws exception on accessing the href property if url is malformed,
                // e.g. http://example.com:80x/
                try {
                    urlAnchor.href = s.url;

                    // Support: IE <=8 - 11 only
                    // Anchor's host property isn't correctly set when s.url is relative
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {

                    // If there is an error parsing the URL, assume it is crossDomain,
                    // it can be rejected by the transport if it is invalid
                    s.crossDomain = true;
                }
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefilter, stop there
            if (completed) {
                return jqXHR;
            }

            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            // Remove hash to simplify url manipulation
            cacheURL = s.url.replace(rhash, "");

            // More options handling for requests with no content
            if (!s.hasContent) {

                // Remember the hash so we can put it back
                uncached = s.url.slice(cacheURL.length);

                // If data is available and should be processed, append data to url
                if (s.data && (s.processData || typeof s.data === "string")) {
                    cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;

                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Add or update anti-cache param if needed
                if (s.cache === false) {
                    cacheURL = cacheURL.replace(rantiCache, "$1");
                    uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;
                }

                // Put hash and anti-cache on the URL that will be requested (gh-1732)
                s.url = cacheURL + uncached;

                // Change '%20' to '+' if this is encoded form body content (gh-2658)
            } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
                s.data = s.data.replace(r20, "+");
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }

            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {

                // Abort if not done already and return
                return jqXHR.abort();
            }

            // Aborting is no longer a cancellation
            strAbort = "abort";

            // Install callbacks on deferreds
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;

                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }

                // If request was aborted inside ajaxSend, stop there
                if (completed) {
                    return jqXHR;
                }

                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = window.setTimeout(function () {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }

                try {
                    completed = false;
                    transport.send(requestHeaders, done);
                } catch (e) {

                    // Rethrow post-completion exceptions
                    if (completed) {
                        throw e;
                    }

                    // Propagate others as results
                    done(-1, e);
                }
            }

            // Callback for when everything is done
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess,
                    success,
                    error,
                    response,
                    modified,
                    statusText = nativeStatusText;

                // Ignore repeat invocations
                if (completed) {
                    return;
                }

                completed = true;

                // Clear timeout if it exists
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;

                // Get response data
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }

                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess);

                // If successful, handle type chaining
                if (isSuccess) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }

                    // if no content
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";

                        // if not modified
                    } else if (status === 304) {
                        statusText = "notmodified";

                        // If we have data, let's convert it
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {

                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";

                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(_statusCode);
                _statusCode = undefined;

                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

                    // Handle the global AJAX counter
                    if (! --jQuery.active) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            return jqXHR;
        },

        getJSON: function getJSON(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        getScript: function getScript(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });

    jQuery.each(["get", "post"], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {

            // Shift arguments if data argument was omitted
            if (isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            // The url can be an options object (which then must have .url)
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });

    jQuery._evalUrl = function (url) {
        return jQuery.ajax({
            url: url,

            // Make this explicit, since user can override this through ajaxSetup (#11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            "throws": true
        });
    };

    jQuery.fn.extend({
        wrapAll: function wrapAll(html) {
            var wrap;

            if (this[0]) {
                if (isFunction(html)) {
                    html = html.call(this[0]);
                }

                // The elements to wrap the target around
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function () {
                    var elem = this;

                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function wrapInner(html) {
            if (isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function () {
                var self = jQuery(this),
                    contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },

        wrap: function wrap(html) {
            var htmlIsFunction = isFunction(html);

            return this.each(function (i) {
                jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
            });
        },

        unwrap: function unwrap(selector) {
            this.parent(selector).not("body").each(function () {
                jQuery(this).replaceWith(this.childNodes);
            });
            return this;
        }
    });

    jQuery.expr.pseudos.hidden = function (elem) {
        return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function (elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };

    jQuery.ajaxSettings.xhr = function () {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {}
    };

    var xhrSuccessStatus = {

        // File protocol always yields status code 0, assume 200
        0: 200,

        // Support: IE <=9 only
        // #1450: sometimes IE returns 1223 when it should be 204
        1223: 204
    },
        xhrSupported = jQuery.ajaxSettings.xhr();

    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;

    jQuery.ajaxTransport(function (options) {
        var _callback, errorCallback;

        // Cross domain only allowed if supported through XMLHttpRequest
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function send(headers, complete) {
                    var i,
                        xhr = options.xhr();

                    xhr.open(options.type, options.url, options.async, options.username, options.password);

                    // Apply custom fields if provided
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }

                    // Override mime type if needed
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }

                    // Set headers
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }

                    // Callback
                    _callback = function callback(type) {
                        return function () {
                            if (_callback) {
                                _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {

                                    // Support: IE <=9 only
                                    // On a manual native abort, IE9 throws
                                    // errors on any property access that is not readyState
                                    if (typeof xhr.status !== "number") {
                                        complete(0, "error");
                                    } else {
                                        complete(

                                        // File: protocol always yields status 0; see #8605, #14207
                                        xhr.status, xhr.statusText);
                                    }
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,

                                    // Support: IE <=9 only
                                    // IE9 has no XHR2 but throws on binary (trac-11426)
                                    // For XHR2 non-text, let the caller handle it (gh-2498)
                                    (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };

                    // Listen to events
                    xhr.onload = _callback();
                    errorCallback = xhr.onerror = xhr.ontimeout = _callback("error");

                    // Support: IE 9 only
                    // Use onreadystatechange to replace onabort
                    // to handle uncaught aborts
                    if (xhr.onabort !== undefined) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function () {

                            // Check readyState before timeout as it changes
                            if (xhr.readyState === 4) {

                                // Allow onerror to be called first,
                                // but that will not handle a native abort
                                // Also, save errorCallback to a variable
                                // as xhr.onerror cannot be accessed
                                window.setTimeout(function () {
                                    if (_callback) {
                                        errorCallback();
                                    }
                                });
                            }
                        };
                    }

                    // Create the abort callback
                    _callback = _callback("abort");

                    try {

                        // Do send the request (this may raise an exception)
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {

                        // #14683: Only rethrow if this hasn't been notified as an error yet
                        if (_callback) {
                            throw e;
                        }
                    }
                },

                abort: function abort() {
                    if (_callback) {
                        _callback();
                    }
                }
            };
        }
    });

    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
    jQuery.ajaxPrefilter(function (s) {
        if (s.crossDomain) {
            s.contents.script = false;
        }
    });

    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function textScript(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });

    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter("script", function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });

    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function (s) {

        // This transport only deals with cross domain requests
        if (s.crossDomain) {
            var script, _callback2;
            return {
                send: function send(_, complete) {
                    script = jQuery("<script>").prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", _callback2 = function callback(evt) {
                        script.remove();
                        _callback2 = null;
                        if (evt) {
                            complete(evt.type === "error" ? 404 : 200, evt.type);
                        }
                    });

                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    document.head.appendChild(script[0]);
                },
                abort: function abort() {
                    if (_callback2) {
                        _callback2();
                    }
                }
            };
        }
    });

    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;

    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function jsonpCallback() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            this[callback] = true;
            return callback;
        }
    });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

        var callbackName,
            overwritten,
            responseContainer,
            jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (jsonProp || s.dataTypes[0] === "jsonp") {

            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

            // Insert callback into url or form data
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };

            // Force json dataType
            s.dataTypes[0] = "json";

            // Install callback
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };

            // Clean-up function (fires after converters)
            jqXHR.always(function () {

                // If previous value didn't exist - remove it
                if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName);

                    // Otherwise restore preexisting value
                } else {
                    window[callbackName] = overwritten;
                }

                // Save back as free
                if (s[callbackName]) {

                    // Make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    // Save the callback name for future use
                    oldCallbacks.push(callbackName);
                }

                // Call if it was a function and we have a response
                if (responseContainer && isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }

                responseContainer = overwritten = undefined;
            });

            // Delegate to script
            return "script";
        }
    });

    // Support: Safari 8 only
    // In Safari 8 documents created via document.implementation.createHTMLDocument
    // collapse sibling forms: the second one becomes a child of the first one.
    // Because of that, this security measure has to be disabled in Safari 8.
    // https://bugs.webkit.org/show_bug.cgi?id=137337
    support.createHTMLDocument = function () {
        var body = document.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
    }();

    // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (typeof data !== "string") {
            return [];
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }

        var base, parsed, scripts;

        if (!context) {

            // Stop scripts or inline event handlers from being executed immediately
            // by using document.implementation
            if (support.createHTMLDocument) {
                context = document.implementation.createHTMLDocument("");

                // Set the base href for the created document
                // so any parsed elements with URLs
                // are based on the document's URL (gh-2965)
                base = context.createElement("base");
                base.href = document.location.href;
                context.head.appendChild(base);
            } else {
                context = document;
            }
        }

        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];

        // Single tag
        if (parsed) {
            return [context.createElement(parsed[1])];
        }

        parsed = buildFragment([data], context, scripts);

        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }

        return jQuery.merge([], parsed.childNodes);
    };

    /**
     * Load a url into a page
     */
    jQuery.fn.load = function (url, params, callback) {
        var selector,
            type,
            response,
            self = this,
            off = url.indexOf(" ");

        if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
        }

        // If it's a function
        if (isFunction(params)) {

            // We assume that it's the callback
            callback = params;
            params = undefined;

            // Otherwise, build a param string
        } else if (params && (typeof params === "undefined" ? "undefined" : _typeof(params)) === "object") {
            type = "POST";
        }

        // If we have elements to modify, make the request
        if (self.length > 0) {
            jQuery.ajax({
                url: url,

                // If "type" variable is undefined, then "GET" method will be used.
                // Make value of this field explicit since
                // user can override it through ajaxSetup method
                type: type || "GET",
                dataType: "html",
                data: params
            }).done(function (responseText) {

                // Save response for use in complete callback
                response = arguments;

                self.html(selector ?

                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

                // Otherwise use the full result
                responseText);

                // If the request succeeds, this function gets "data", "status", "jqXHR"
                // but they are ignored because response was set above.
                // If it fails, this function gets "jqXHR", "status", "error"
            }).always(callback && function (jqXHR, status) {
                self.each(function () {
                    callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
                });
            });
        }

        return this;
    };

    // Attach a bunch of functions for handling common AJAX events
    jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });

    jQuery.expr.pseudos.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };

    jQuery.offset = {
        setOffset: function setOffset(elem, options, i) {
            var curPosition,
                curLeft,
                curCSSTop,
                curTop,
                curOffset,
                curCSSLeft,
                calculatePosition,
                position = jQuery.css(elem, "position"),
                curElem = jQuery(elem),
                props = {};

            // Set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

            // Need to be able to calculate position if either
            // top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }

            if (isFunction(options)) {

                // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                options = options.call(elem, i, jQuery.extend({}, curOffset));
            }

            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }

            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };

    jQuery.fn.extend({

        // offset() relates an element's border box to the document origin
        offset: function offset(options) {

            // Preserve chaining for setter
            if (arguments.length) {
                return options === undefined ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            var rect,
                win,
                elem = this[0];

            if (!elem) {
                return;
            }

            // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
            // Support: IE <=11 only
            // Running getBoundingClientRect on a
            // disconnected node in IE throws an error
            if (!elem.getClientRects().length) {
                return { top: 0, left: 0 };
            }

            // Get document-relative position by adding viewport scroll to viewport-relative gBCR
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
                top: rect.top + win.pageYOffset,
                left: rect.left + win.pageXOffset
            };
        },

        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function position() {
            if (!this[0]) {
                return;
            }

            var offsetParent,
                offset,
                doc,
                elem = this[0],
                parentOffset = { top: 0, left: 0 };

            // position:fixed elements are offset from the viewport, which itself always has zero offset
            if (jQuery.css(elem, "position") === "fixed") {

                // Assume position:fixed implies availability of getBoundingClientRect
                offset = elem.getBoundingClientRect();
            } else {
                offset = this.offset();

                // Account for the *real* offset parent, which can be the document or its root element
                // when a statically positioned element is identified
                doc = elem.ownerDocument;
                offsetParent = elem.offsetParent || doc.documentElement;
                while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {

                    offsetParent = offsetParent.parentNode;
                }
                if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {

                    // Incorporate borders into its offset, since they are outside its content origin
                    parentOffset = jQuery(offsetParent).offset();
                    parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
                    parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
                }
            }

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },

        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function offsetParent() {
            return this.map(function () {
                var offsetParent = this.offsetParent;

                while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                    offsetParent = offsetParent.offsetParent;
                }

                return offsetParent || documentElement;
            });
        }
    });

    // Create scrollLeft and scrollTop methods
    jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
        var top = "pageYOffset" === prop;

        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {

                // Coalesce documents and windows
                var win;
                if (isWindow(elem)) {
                    win = elem;
                } else if (elem.nodeType === 9) {
                    win = elem.defaultView;
                }

                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }

                if (win) {
                    win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length);
        };
    });

    // Support: Safari <=7 - 9.1, Chrome <=37 - 49
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here
    jQuery.each(["top", "left"], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);

                // If curCSS returns percentage, fallback to offset
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });

    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
        jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {

            // Margin is only for outerHeight, outerWidth
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

                return access(this, function (elem, type, value) {
                    var doc;

                    if (isWindow(elem)) {

                        // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                        return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                    }

                    // Get document width or height
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;

                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                        // whichever is greatest
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }

                    return value === undefined ?

                    // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery.css(elem, type, extra) :

                    // Set width or height on the element
                    jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable);
            };
        });
    });

    jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (i, name) {

        // Handle event binding
        jQuery.fn[name] = function (data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });

    jQuery.fn.extend({
        hover: function hover(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });

    jQuery.fn.extend({

        bind: function bind(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function unbind(types, fn) {
            return this.off(types, null, fn);
        },

        delegate: function delegate(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function undelegate(selector, types, fn) {

            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    });

    // Bind a function to a context, optionally partially applying any
    // arguments.
    // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
    // However, it is not slated for removal any time soon
    jQuery.proxy = function (fn, context) {
        var tmp, args, proxy;

        if (typeof context === "string") {
            tmp = fn[context];
            context = fn;
            fn = tmp;
        }

        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if (!isFunction(fn)) {
            return undefined;
        }

        // Simulated bind
        args = _slice.call(arguments, 2);
        proxy = function proxy() {
            return fn.apply(context || this, args.concat(_slice.call(arguments)));
        };

        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;

        return proxy;
    };

    jQuery.holdReady = function (hold) {
        if (hold) {
            jQuery.readyWait++;
        } else {
            jQuery.ready(true);
        }
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;

    jQuery.now = Date.now;

    jQuery.isNumeric = function (obj) {

        // As of jQuery 3.0, isNumeric is limited to
        // strings and numbers (primitives or objects)
        // that can be coerced to finite numbers (gh-2662)
        var type = jQuery.type(obj);
        return (type === "number" || type === "string") &&

        // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
    };

    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.

    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
            return jQuery;
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }

    var

    // Map over jQuery in case of overwrite
    _jQuery = window.jQuery,


    // Map over the $ in case of overwrite
    _$ = window.$;

    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }

        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }

        return jQuery;
    };

    // Expose jQuery and $ identifiers, even in AMD
    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
    }

    return jQuery;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYmNhNjNkMTlkNTU4YThiYzY5MzgiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJtb2R1bGUiLCJleHBvcnRzIiwiZG9jdW1lbnQiLCJ3IiwiRXJyb3IiLCJ3aW5kb3ciLCJub0dsb2JhbCIsImFyciIsImdldFByb3RvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJzbGljZSIsImNvbmNhdCIsInB1c2giLCJpbmRleE9mIiwiY2xhc3MydHlwZSIsInRvU3RyaW5nIiwiaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJmblRvU3RyaW5nIiwiT2JqZWN0RnVuY3Rpb25TdHJpbmciLCJjYWxsIiwic3VwcG9ydCIsImlzRnVuY3Rpb24iLCJvYmoiLCJub2RlVHlwZSIsImlzV2luZG93IiwicHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyIsInR5cGUiLCJzcmMiLCJub01vZHVsZSIsIkRPTUV2YWwiLCJjb2RlIiwiZG9jIiwibm9kZSIsImkiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50IiwidGV4dCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInRvVHlwZSIsInZlcnNpb24iLCJqUXVlcnkiLCJzZWxlY3RvciIsImNvbnRleHQiLCJmbiIsImluaXQiLCJydHJpbSIsInByb3RvdHlwZSIsImpxdWVyeSIsImNvbnN0cnVjdG9yIiwibGVuZ3RoIiwidG9BcnJheSIsImdldCIsIm51bSIsInB1c2hTdGFjayIsImVsZW1zIiwicmV0IiwibWVyZ2UiLCJwcmV2T2JqZWN0IiwiZWFjaCIsImNhbGxiYWNrIiwibWFwIiwiZWxlbSIsImFwcGx5IiwiYXJndW1lbnRzIiwiZmlyc3QiLCJlcSIsImxhc3QiLCJsZW4iLCJqIiwiZW5kIiwic29ydCIsInNwbGljZSIsImV4dGVuZCIsIm9wdGlvbnMiLCJuYW1lIiwiY29weSIsImNvcHlJc0FycmF5IiwiY2xvbmUiLCJ0YXJnZXQiLCJkZWVwIiwiaXNQbGFpbk9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsImV4cGFuZG8iLCJNYXRoIiwicmFuZG9tIiwicmVwbGFjZSIsImlzUmVhZHkiLCJlcnJvciIsIm1zZyIsIm5vb3AiLCJwcm90byIsIkN0b3IiLCJpc0VtcHR5T2JqZWN0IiwiZ2xvYmFsRXZhbCIsImlzQXJyYXlMaWtlIiwidHJpbSIsIm1ha2VBcnJheSIsInJlc3VsdHMiLCJpbkFycmF5Iiwic2Vjb25kIiwiZ3JlcCIsImludmVydCIsImNhbGxiYWNrSW52ZXJzZSIsIm1hdGNoZXMiLCJjYWxsYmFja0V4cGVjdCIsImFyZyIsInZhbHVlIiwiZ3VpZCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwic3BsaXQiLCJ0b0xvd2VyQ2FzZSIsIlNpenpsZSIsIkV4cHIiLCJnZXRUZXh0IiwiaXNYTUwiLCJ0b2tlbml6ZSIsImNvbXBpbGUiLCJzZWxlY3QiLCJvdXRlcm1vc3RDb250ZXh0Iiwic29ydElucHV0IiwiaGFzRHVwbGljYXRlIiwic2V0RG9jdW1lbnQiLCJkb2NFbGVtIiwiZG9jdW1lbnRJc0hUTUwiLCJyYnVnZ3lRU0EiLCJyYnVnZ3lNYXRjaGVzIiwiY29udGFpbnMiLCJEYXRlIiwicHJlZmVycmVkRG9jIiwiZGlycnVucyIsImRvbmUiLCJjbGFzc0NhY2hlIiwiY3JlYXRlQ2FjaGUiLCJ0b2tlbkNhY2hlIiwiY29tcGlsZXJDYWNoZSIsInNvcnRPcmRlciIsImEiLCJiIiwicG9wIiwicHVzaF9uYXRpdmUiLCJsaXN0IiwiYm9vbGVhbnMiLCJ3aGl0ZXNwYWNlIiwiaWRlbnRpZmllciIsImF0dHJpYnV0ZXMiLCJwc2V1ZG9zIiwicndoaXRlc3BhY2UiLCJSZWdFeHAiLCJyY29tbWEiLCJyY29tYmluYXRvcnMiLCJyYXR0cmlidXRlUXVvdGVzIiwicnBzZXVkbyIsInJpZGVudGlmaWVyIiwibWF0Y2hFeHByIiwicmlucHV0cyIsInJoZWFkZXIiLCJybmF0aXZlIiwicnF1aWNrRXhwciIsInJzaWJsaW5nIiwicnVuZXNjYXBlIiwiZnVuZXNjYXBlIiwiXyIsImVzY2FwZWQiLCJlc2NhcGVkV2hpdGVzcGFjZSIsImhpZ2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJyY3NzZXNjYXBlIiwiZmNzc2VzY2FwZSIsImNoIiwiYXNDb2RlUG9pbnQiLCJjaGFyQ29kZUF0IiwidW5sb2FkSGFuZGxlciIsImRpc2FibGVkQW5jZXN0b3IiLCJhZGRDb21iaW5hdG9yIiwiZGlzYWJsZWQiLCJkaXIiLCJuZXh0IiwiY2hpbGROb2RlcyIsImUiLCJlbHMiLCJzZWVkIiwibSIsIm5pZCIsIm1hdGNoIiwiZ3JvdXBzIiwibmV3U2VsZWN0b3IiLCJuZXdDb250ZXh0Iiwib3duZXJEb2N1bWVudCIsImV4ZWMiLCJnZXRFbGVtZW50QnlJZCIsImlkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwicXNhIiwidGVzdCIsIm5vZGVOYW1lIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwidG9TZWxlY3RvciIsImpvaW4iLCJ0ZXN0Q29udGV4dCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJxc2FFcnJvciIsInJlbW92ZUF0dHJpYnV0ZSIsImtleXMiLCJjYWNoZSIsImtleSIsImNhY2hlTGVuZ3RoIiwic2hpZnQiLCJtYXJrRnVuY3Rpb24iLCJhc3NlcnQiLCJlbCIsImFkZEhhbmRsZSIsImF0dHJzIiwiaGFuZGxlciIsImF0dHJIYW5kbGUiLCJzaWJsaW5nQ2hlY2siLCJjdXIiLCJkaWZmIiwic291cmNlSW5kZXgiLCJuZXh0U2libGluZyIsImNyZWF0ZUlucHV0UHNldWRvIiwiY3JlYXRlQnV0dG9uUHNldWRvIiwiY3JlYXRlRGlzYWJsZWRQc2V1ZG8iLCJpc0Rpc2FibGVkIiwiY3JlYXRlUG9zaXRpb25hbFBzZXVkbyIsImFyZ3VtZW50IiwibWF0Y2hJbmRleGVzIiwiZG9jdW1lbnRFbGVtZW50IiwiaGFzQ29tcGFyZSIsInN1YldpbmRvdyIsImRlZmF1bHRWaWV3IiwidG9wIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiY2xhc3NOYW1lIiwiY3JlYXRlQ29tbWVudCIsImdldEJ5SWQiLCJnZXRFbGVtZW50c0J5TmFtZSIsImZpbHRlciIsImF0dHJJZCIsImZpbmQiLCJnZXRBdHRyaWJ1dGVOb2RlIiwidGFnIiwidG1wIiwiaW5uZXJIVE1MIiwiaW5wdXQiLCJtYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJkaXNjb25uZWN0ZWRNYXRjaCIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiYWRvd24iLCJidXAiLCJjb21wYXJlIiwic29ydERldGFjaGVkIiwiYXVwIiwiYXAiLCJicCIsInVuc2hpZnQiLCJleHByIiwiZWxlbWVudHMiLCJhdHRyIiwidmFsIiwic3BlY2lmaWVkIiwiZXNjYXBlIiwic2VsIiwidW5pcXVlU29ydCIsImR1cGxpY2F0ZXMiLCJkZXRlY3REdXBsaWNhdGVzIiwic29ydFN0YWJsZSIsInRleHRDb250ZW50IiwiZmlyc3RDaGlsZCIsIm5vZGVWYWx1ZSIsInNlbGVjdG9ycyIsImNyZWF0ZVBzZXVkbyIsInJlbGF0aXZlIiwicHJlRmlsdGVyIiwiZXhjZXNzIiwidW5xdW90ZWQiLCJub2RlTmFtZVNlbGVjdG9yIiwicGF0dGVybiIsIm9wZXJhdG9yIiwiY2hlY2siLCJyZXN1bHQiLCJ3aGF0Iiwic2ltcGxlIiwiZm9yd2FyZCIsIm9mVHlwZSIsInhtbCIsInVuaXF1ZUNhY2hlIiwib3V0ZXJDYWNoZSIsIm5vZGVJbmRleCIsInN0YXJ0IiwicGFyZW50IiwidXNlQ2FjaGUiLCJsYXN0Q2hpbGQiLCJ1bmlxdWVJRCIsInBzZXVkbyIsImFyZ3MiLCJzZXRGaWx0ZXJzIiwiaWR4IiwibWF0Y2hlZCIsIm1hdGNoZXIiLCJ1bm1hdGNoZWQiLCJpbm5lclRleHQiLCJsYW5nIiwiZWxlbUxhbmciLCJoYXNoIiwibG9jYXRpb24iLCJhY3RpdmVFbGVtZW50IiwiaGFzRm9jdXMiLCJocmVmIiwidGFiSW5kZXgiLCJjaGVja2VkIiwic2VsZWN0ZWQiLCJzZWxlY3RlZEluZGV4IiwicmFkaW8iLCJjaGVja2JveCIsImZpbGUiLCJwYXNzd29yZCIsImltYWdlIiwic3VibWl0IiwicmVzZXQiLCJmaWx0ZXJzIiwicGFyc2VPbmx5IiwidG9rZW5zIiwic29GYXIiLCJwcmVGaWx0ZXJzIiwiY2FjaGVkIiwiY29tYmluYXRvciIsImJhc2UiLCJza2lwIiwiY2hlY2tOb25FbGVtZW50cyIsImRvbmVOYW1lIiwib2xkQ2FjaGUiLCJuZXdDYWNoZSIsImVsZW1lbnRNYXRjaGVyIiwibWF0Y2hlcnMiLCJtdWx0aXBsZUNvbnRleHRzIiwiY29udGV4dHMiLCJjb25kZW5zZSIsIm5ld1VubWF0Y2hlZCIsIm1hcHBlZCIsInNldE1hdGNoZXIiLCJwb3N0RmlsdGVyIiwicG9zdEZpbmRlciIsInBvc3RTZWxlY3RvciIsInRlbXAiLCJwcmVNYXAiLCJwb3N0TWFwIiwicHJlZXhpc3RpbmciLCJtYXRjaGVySW4iLCJtYXRjaGVyT3V0IiwibWF0Y2hlckZyb21Ub2tlbnMiLCJjaGVja0NvbnRleHQiLCJsZWFkaW5nUmVsYXRpdmUiLCJpbXBsaWNpdFJlbGF0aXZlIiwibWF0Y2hDb250ZXh0IiwibWF0Y2hBbnlDb250ZXh0IiwibWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzIiwiZWxlbWVudE1hdGNoZXJzIiwic2V0TWF0Y2hlcnMiLCJieVNldCIsImJ5RWxlbWVudCIsInN1cGVyTWF0Y2hlciIsIm91dGVybW9zdCIsIm1hdGNoZWRDb3VudCIsInNldE1hdGNoZWQiLCJjb250ZXh0QmFja3VwIiwiZGlycnVuc1VuaXF1ZSIsInRva2VuIiwiY29tcGlsZWQiLCJkZWZhdWx0VmFsdWUiLCJ1bmlxdWUiLCJpc1hNTERvYyIsImVzY2FwZVNlbGVjdG9yIiwidW50aWwiLCJ0cnVuY2F0ZSIsImlzIiwic2libGluZ3MiLCJuIiwicm5lZWRzQ29udGV4dCIsIm5lZWRzQ29udGV4dCIsInJzaW5nbGVUYWciLCJ3aW5ub3ciLCJxdWFsaWZpZXIiLCJub3QiLCJzZWxmIiwicm9vdGpRdWVyeSIsInJvb3QiLCJwYXJzZUhUTUwiLCJyZWFkeSIsInJwYXJlbnRzcHJldiIsImd1YXJhbnRlZWRVbmlxdWUiLCJjaGlsZHJlbiIsImNvbnRlbnRzIiwicHJldiIsImhhcyIsInRhcmdldHMiLCJsIiwiY2xvc2VzdCIsImluZGV4IiwicHJldkFsbCIsImFkZCIsImFkZEJhY2siLCJzaWJsaW5nIiwicGFyZW50cyIsInBhcmVudHNVbnRpbCIsIm5leHRBbGwiLCJuZXh0VW50aWwiLCJwcmV2VW50aWwiLCJjb250ZW50RG9jdW1lbnQiLCJjb250ZW50IiwicmV2ZXJzZSIsInJub3RodG1sd2hpdGUiLCJjcmVhdGVPcHRpb25zIiwib2JqZWN0IiwiZmxhZyIsIkNhbGxiYWNrcyIsImZpcmluZyIsIm1lbW9yeSIsImZpcmVkIiwibG9ja2VkIiwicXVldWUiLCJmaXJpbmdJbmRleCIsImZpcmUiLCJvbmNlIiwic3RvcE9uRmFsc2UiLCJyZW1vdmUiLCJlbXB0eSIsImRpc2FibGUiLCJsb2NrIiwiZmlyZVdpdGgiLCJJZGVudGl0eSIsInYiLCJUaHJvd2VyIiwiZXgiLCJhZG9wdFZhbHVlIiwicmVzb2x2ZSIsInJlamVjdCIsIm5vVmFsdWUiLCJtZXRob2QiLCJwcm9taXNlIiwiZmFpbCIsInRoZW4iLCJEZWZlcnJlZCIsImZ1bmMiLCJ0dXBsZXMiLCJzdGF0ZSIsImFsd2F5cyIsImRlZmVycmVkIiwicGlwZSIsImZucyIsIm5ld0RlZmVyIiwidHVwbGUiLCJyZXR1cm5lZCIsInByb2dyZXNzIiwibm90aWZ5Iiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwib25Qcm9ncmVzcyIsIm1heERlcHRoIiwiZGVwdGgiLCJzcGVjaWFsIiwidGhhdCIsIm1pZ2h0VGhyb3ciLCJUeXBlRXJyb3IiLCJub3RpZnlXaXRoIiwicmVzb2x2ZVdpdGgiLCJwcm9jZXNzIiwiZXhjZXB0aW9uSG9vayIsInN0YWNrVHJhY2UiLCJyZWplY3RXaXRoIiwiZ2V0U3RhY2tIb29rIiwic2V0VGltZW91dCIsInN0YXRlU3RyaW5nIiwid2hlbiIsInNpbmdsZVZhbHVlIiwicmVtYWluaW5nIiwicmVzb2x2ZUNvbnRleHRzIiwicmVzb2x2ZVZhbHVlcyIsIm1hc3RlciIsInVwZGF0ZUZ1bmMiLCJyZXJyb3JOYW1lcyIsInN0YWNrIiwiY29uc29sZSIsIndhcm4iLCJtZXNzYWdlIiwicmVhZHlFeGNlcHRpb24iLCJyZWFkeUxpc3QiLCJjYXRjaCIsInJlYWR5V2FpdCIsIndhaXQiLCJjb21wbGV0ZWQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVhZHlTdGF0ZSIsImRvU2Nyb2xsIiwiYWNjZXNzIiwiY2hhaW5hYmxlIiwiZW1wdHlHZXQiLCJyYXciLCJidWxrIiwicm1zUHJlZml4IiwicmRhc2hBbHBoYSIsImZjYW1lbENhc2UiLCJhbGwiLCJsZXR0ZXIiLCJ0b1VwcGVyQ2FzZSIsImNhbWVsQ2FzZSIsInN0cmluZyIsImFjY2VwdERhdGEiLCJvd25lciIsIkRhdGEiLCJ1aWQiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsInNldCIsImRhdGEiLCJwcm9wIiwiaGFzRGF0YSIsImRhdGFQcml2IiwiZGF0YVVzZXIiLCJyYnJhY2UiLCJybXVsdGlEYXNoIiwiZ2V0RGF0YSIsIkpTT04iLCJwYXJzZSIsImRhdGFBdHRyIiwicmVtb3ZlRGF0YSIsIl9kYXRhIiwiX3JlbW92ZURhdGEiLCJkZXF1ZXVlIiwic3RhcnRMZW5ndGgiLCJob29rcyIsIl9xdWV1ZUhvb2tzIiwic3RvcCIsInNldHRlciIsImNsZWFyUXVldWUiLCJjb3VudCIsImRlZmVyIiwicG51bSIsInNvdXJjZSIsInJjc3NOdW0iLCJjc3NFeHBhbmQiLCJpc0hpZGRlbldpdGhpblRyZWUiLCJzdHlsZSIsImRpc3BsYXkiLCJjc3MiLCJzd2FwIiwib2xkIiwiYWRqdXN0Q1NTIiwidmFsdWVQYXJ0cyIsInR3ZWVuIiwiYWRqdXN0ZWQiLCJzY2FsZSIsIm1heEl0ZXJhdGlvbnMiLCJjdXJyZW50VmFsdWUiLCJpbml0aWFsIiwidW5pdCIsImNzc051bWJlciIsImluaXRpYWxJblVuaXQiLCJkZWZhdWx0RGlzcGxheU1hcCIsImdldERlZmF1bHREaXNwbGF5IiwiYm9keSIsInNob3dIaWRlIiwic2hvdyIsInZhbHVlcyIsImhpZGUiLCJ0b2dnbGUiLCJyY2hlY2thYmxlVHlwZSIsInJ0YWdOYW1lIiwicnNjcmlwdFR5cGUiLCJ3cmFwTWFwIiwib3B0aW9uIiwidGhlYWQiLCJjb2wiLCJ0ciIsInRkIiwiX2RlZmF1bHQiLCJvcHRncm91cCIsInRib2R5IiwidGZvb3QiLCJjb2xncm91cCIsImNhcHRpb24iLCJ0aCIsImdldEFsbCIsInNldEdsb2JhbEV2YWwiLCJyZWZFbGVtZW50cyIsInJodG1sIiwiYnVpbGRGcmFnbWVudCIsInNjcmlwdHMiLCJzZWxlY3Rpb24iLCJpZ25vcmVkIiwid3JhcCIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIm5vZGVzIiwiY3JlYXRlVGV4dE5vZGUiLCJodG1sUHJlZmlsdGVyIiwiZGl2IiwiY2hlY2tDbG9uZSIsImNsb25lTm9kZSIsIm5vQ2xvbmVDaGVja2VkIiwicmtleUV2ZW50Iiwicm1vdXNlRXZlbnQiLCJydHlwZW5hbWVzcGFjZSIsInJldHVyblRydWUiLCJyZXR1cm5GYWxzZSIsInNhZmVBY3RpdmVFbGVtZW50IiwiZXJyIiwib24iLCJ0eXBlcyIsIm9uZSIsIm9yaWdGbiIsImV2ZW50Iiwib2ZmIiwiaGFuZGxlT2JqSW4iLCJldmVudEhhbmRsZSIsImV2ZW50cyIsInQiLCJoYW5kbGVPYmoiLCJoYW5kbGVycyIsIm5hbWVzcGFjZXMiLCJvcmlnVHlwZSIsImVsZW1EYXRhIiwiaGFuZGxlIiwidHJpZ2dlcmVkIiwiZGlzcGF0Y2giLCJkZWxlZ2F0ZVR5cGUiLCJiaW5kVHlwZSIsIm5hbWVzcGFjZSIsImRlbGVnYXRlQ291bnQiLCJzZXR1cCIsIm1hcHBlZFR5cGVzIiwib3JpZ0NvdW50IiwidGVhcmRvd24iLCJyZW1vdmVFdmVudCIsIm5hdGl2ZUV2ZW50IiwiZml4IiwiaGFuZGxlclF1ZXVlIiwiZGVsZWdhdGVUYXJnZXQiLCJwcmVEaXNwYXRjaCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiY3VycmVudFRhcmdldCIsImlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkIiwicm5hbWVzcGFjZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwicG9zdERpc3BhdGNoIiwibWF0Y2hlZEhhbmRsZXJzIiwibWF0Y2hlZFNlbGVjdG9ycyIsImJ1dHRvbiIsImFkZFByb3AiLCJob29rIiwiRXZlbnQiLCJlbnVtZXJhYmxlIiwib3JpZ2luYWxFdmVudCIsIndyaXRhYmxlIiwibG9hZCIsIm5vQnViYmxlIiwiZm9jdXMiLCJ0cmlnZ2VyIiwiYmx1ciIsImNsaWNrIiwiYmVmb3JldW5sb2FkIiwicmV0dXJuVmFsdWUiLCJwcm9wcyIsImlzRGVmYXVsdFByZXZlbnRlZCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJyZWxhdGVkVGFyZ2V0IiwidGltZVN0YW1wIiwibm93IiwiaXNTaW11bGF0ZWQiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJhbHRLZXkiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImNoYW5nZWRUb3VjaGVzIiwiY3RybEtleSIsImRldGFpbCIsImV2ZW50UGhhc2UiLCJtZXRhS2V5IiwicGFnZVgiLCJwYWdlWSIsInNoaWZ0S2V5IiwidmlldyIsImNoYXJDb2RlIiwia2V5Q29kZSIsImJ1dHRvbnMiLCJjbGllbnRYIiwiY2xpZW50WSIsIm9mZnNldFgiLCJvZmZzZXRZIiwicG9pbnRlcklkIiwicG9pbnRlclR5cGUiLCJzY3JlZW5YIiwic2NyZWVuWSIsInRhcmdldFRvdWNoZXMiLCJ0b0VsZW1lbnQiLCJ0b3VjaGVzIiwid2hpY2giLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJsZWF2ZSIsIm9yaWciLCJyZWxhdGVkIiwicnhodG1sVGFnIiwicm5vSW5uZXJodG1sIiwicmNoZWNrZWQiLCJyY2xlYW5TY3JpcHQiLCJtYW5pcHVsYXRpb25UYXJnZXQiLCJkaXNhYmxlU2NyaXB0IiwicmVzdG9yZVNjcmlwdCIsImNsb25lQ29weUV2ZW50IiwiZGVzdCIsInBkYXRhT2xkIiwicGRhdGFDdXIiLCJ1ZGF0YU9sZCIsInVkYXRhQ3VyIiwiZml4SW5wdXQiLCJkb21NYW5pcCIsImNvbGxlY3Rpb24iLCJoYXNTY3JpcHRzIiwiaU5vQ2xvbmUiLCJ2YWx1ZUlzRnVuY3Rpb24iLCJodG1sIiwiX2V2YWxVcmwiLCJrZWVwRGF0YSIsImNsZWFuRGF0YSIsImRhdGFBbmRFdmVudHMiLCJkZWVwRGF0YUFuZEV2ZW50cyIsInNyY0VsZW1lbnRzIiwiZGVzdEVsZW1lbnRzIiwiaW5QYWdlIiwiZGV0YWNoIiwiYXBwZW5kIiwicHJlcGVuZCIsImluc2VydEJlZm9yZSIsImJlZm9yZSIsImFmdGVyIiwicmVwbGFjZVdpdGgiLCJyZXBsYWNlQ2hpbGQiLCJhcHBlbmRUbyIsInByZXBlbmRUbyIsImluc2VydEFmdGVyIiwicmVwbGFjZUFsbCIsIm9yaWdpbmFsIiwiaW5zZXJ0Iiwicm51bW5vbnB4IiwiZ2V0U3R5bGVzIiwib3BlbmVyIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInJib3hTdHlsZSIsImNvbXB1dGVTdHlsZVRlc3RzIiwiY29udGFpbmVyIiwiY3NzVGV4dCIsImRpdlN0eWxlIiwicGl4ZWxQb3NpdGlvblZhbCIsInJlbGlhYmxlTWFyZ2luTGVmdFZhbCIsInJvdW5kUGl4ZWxNZWFzdXJlcyIsIm1hcmdpbkxlZnQiLCJyaWdodCIsInBpeGVsQm94U3R5bGVzVmFsIiwiYm94U2l6aW5nUmVsaWFibGVWYWwiLCJ3aWR0aCIsInBvc2l0aW9uIiwic2Nyb2xsYm94U2l6ZVZhbCIsIm9mZnNldFdpZHRoIiwibWVhc3VyZSIsInJvdW5kIiwicGFyc2VGbG9hdCIsImJhY2tncm91bmRDbGlwIiwiY2xlYXJDbG9uZVN0eWxlIiwiYm94U2l6aW5nUmVsaWFibGUiLCJwaXhlbEJveFN0eWxlcyIsInBpeGVsUG9zaXRpb24iLCJyZWxpYWJsZU1hcmdpbkxlZnQiLCJzY3JvbGxib3hTaXplIiwiY3VyQ1NTIiwiY29tcHV0ZWQiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImFkZEdldEhvb2tJZiIsImNvbmRpdGlvbkZuIiwiaG9va0ZuIiwicmRpc3BsYXlzd2FwIiwicmN1c3RvbVByb3AiLCJjc3NTaG93IiwidmlzaWJpbGl0eSIsImNzc05vcm1hbFRyYW5zZm9ybSIsImxldHRlclNwYWNpbmciLCJmb250V2VpZ2h0IiwiY3NzUHJlZml4ZXMiLCJlbXB0eVN0eWxlIiwidmVuZG9yUHJvcE5hbWUiLCJjYXBOYW1lIiwiZmluYWxQcm9wTmFtZSIsImNzc1Byb3BzIiwic2V0UG9zaXRpdmVOdW1iZXIiLCJzdWJ0cmFjdCIsIm1heCIsImJveE1vZGVsQWRqdXN0bWVudCIsImRpbWVuc2lvbiIsImJveCIsImlzQm9yZGVyQm94Iiwic3R5bGVzIiwiY29tcHV0ZWRWYWwiLCJleHRyYSIsImRlbHRhIiwiY2VpbCIsImdldFdpZHRoT3JIZWlnaHQiLCJ2YWx1ZUlzQm9yZGVyQm94IiwiY3NzSG9va3MiLCJvcGFjaXR5Iiwib3JpZ05hbWUiLCJpc0N1c3RvbVByb3AiLCJzZXRQcm9wZXJ0eSIsImlzRmluaXRlIiwiZ2V0Q2xpZW50UmVjdHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJsZWZ0IiwibWFyZ2luIiwicGFkZGluZyIsImJvcmRlciIsInByZWZpeCIsInN1ZmZpeCIsImV4cGFuZCIsImV4cGFuZGVkIiwicGFydHMiLCJUd2VlbiIsImVhc2luZyIsInByb3BIb29rcyIsInJ1biIsInBlcmNlbnQiLCJlYXNlZCIsImR1cmF0aW9uIiwicG9zIiwic3RlcCIsImZ4Iiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsImxpbmVhciIsInAiLCJzd2luZyIsImNvcyIsIlBJIiwiZnhOb3ciLCJpblByb2dyZXNzIiwicmZ4dHlwZXMiLCJycnVuIiwic2NoZWR1bGUiLCJoaWRkZW4iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJpbnRlcnZhbCIsInRpY2siLCJjcmVhdGVGeE5vdyIsImdlbkZ4IiwiaW5jbHVkZVdpZHRoIiwiaGVpZ2h0IiwiY3JlYXRlVHdlZW4iLCJhbmltYXRpb24iLCJBbmltYXRpb24iLCJ0d2VlbmVycyIsImRlZmF1bHRQcmVmaWx0ZXIiLCJvcHRzIiwib2xkZmlyZSIsInByb3BUd2VlbiIsInJlc3RvcmVEaXNwbGF5IiwiaXNCb3giLCJhbmltIiwiZGF0YVNob3ciLCJ1bnF1ZXVlZCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwicHJvcEZpbHRlciIsInNwZWNpYWxFYXNpbmciLCJwcm9wZXJ0aWVzIiwic3RvcHBlZCIsInByZWZpbHRlcnMiLCJjdXJyZW50VGltZSIsInN0YXJ0VGltZSIsInR3ZWVucyIsIm9yaWdpbmFsUHJvcGVydGllcyIsIm9yaWdpbmFsT3B0aW9ucyIsImdvdG9FbmQiLCJiaW5kIiwiY29tcGxldGUiLCJ0aW1lciIsInR3ZWVuZXIiLCJwcmVmaWx0ZXIiLCJzcGVlZCIsIm9wdCIsInNwZWVkcyIsImZhZGVUbyIsInRvIiwiYW5pbWF0ZSIsIm9wdGFsbCIsImRvQW5pbWF0aW9uIiwiZmluaXNoIiwic3RvcFF1ZXVlIiwidGltZXJzIiwiY3NzRm4iLCJzbGlkZURvd24iLCJzbGlkZVVwIiwic2xpZGVUb2dnbGUiLCJmYWRlSW4iLCJmYWRlT3V0IiwiZmFkZVRvZ2dsZSIsInNsb3ciLCJmYXN0IiwiZGVsYXkiLCJ0aW1lIiwidGltZW91dCIsImNsZWFyVGltZW91dCIsImNoZWNrT24iLCJvcHRTZWxlY3RlZCIsInJhZGlvVmFsdWUiLCJib29sSG9vayIsInJlbW92ZUF0dHIiLCJuVHlwZSIsImF0dHJIb29rcyIsImJvb2wiLCJhdHRyTmFtZXMiLCJnZXR0ZXIiLCJsb3dlcmNhc2VOYW1lIiwicmZvY3VzYWJsZSIsInJjbGlja2FibGUiLCJyZW1vdmVQcm9wIiwicHJvcEZpeCIsInRhYmluZGV4IiwicGFyc2VJbnQiLCJzdHJpcEFuZENvbGxhcHNlIiwiZ2V0Q2xhc3MiLCJjbGFzc2VzVG9BcnJheSIsImFkZENsYXNzIiwiY2xhc3NlcyIsImN1clZhbHVlIiwiY2xhenoiLCJmaW5hbFZhbHVlIiwicmVtb3ZlQ2xhc3MiLCJ0b2dnbGVDbGFzcyIsInN0YXRlVmFsIiwiaXNWYWxpZFZhbHVlIiwiY2xhc3NOYW1lcyIsImhhc0NsYXNzIiwicnJldHVybiIsInZhbEhvb2tzIiwib3B0aW9uU2V0IiwiZm9jdXNpbiIsInJmb2N1c01vcnBoIiwic3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2siLCJvbmx5SGFuZGxlcnMiLCJidWJibGVUeXBlIiwib250eXBlIiwibGFzdEVsZW1lbnQiLCJldmVudFBhdGgiLCJpc1RyaWdnZXIiLCJwYXJlbnRXaW5kb3ciLCJzaW11bGF0ZSIsInRyaWdnZXJIYW5kbGVyIiwiYXR0YWNoZXMiLCJub25jZSIsInJxdWVyeSIsInBhcnNlWE1MIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwicmJyYWNrZXQiLCJyQ1JMRiIsInJzdWJtaXR0ZXJUeXBlcyIsInJzdWJtaXR0YWJsZSIsImJ1aWxkUGFyYW1zIiwidHJhZGl0aW9uYWwiLCJwYXJhbSIsInMiLCJ2YWx1ZU9yRnVuY3Rpb24iLCJlbmNvZGVVUklDb21wb25lbnQiLCJzZXJpYWxpemUiLCJzZXJpYWxpemVBcnJheSIsInIyMCIsInJoYXNoIiwicmFudGlDYWNoZSIsInJoZWFkZXJzIiwicmxvY2FsUHJvdG9jb2wiLCJybm9Db250ZW50IiwicnByb3RvY29sIiwidHJhbnNwb3J0cyIsImFsbFR5cGVzIiwib3JpZ2luQW5jaG9yIiwiYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzIiwic3RydWN0dXJlIiwiZGF0YVR5cGVFeHByZXNzaW9uIiwiZGF0YVR5cGUiLCJkYXRhVHlwZXMiLCJpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyIsImpxWEhSIiwiaW5zcGVjdGVkIiwic2Vla2luZ1RyYW5zcG9ydCIsImluc3BlY3QiLCJwcmVmaWx0ZXJPckZhY3RvcnkiLCJkYXRhVHlwZU9yVHJhbnNwb3J0IiwiYWpheEV4dGVuZCIsImZsYXRPcHRpb25zIiwiYWpheFNldHRpbmdzIiwiYWpheEhhbmRsZVJlc3BvbnNlcyIsInJlc3BvbnNlcyIsImN0IiwiZmluYWxEYXRhVHlwZSIsImZpcnN0RGF0YVR5cGUiLCJtaW1lVHlwZSIsImdldFJlc3BvbnNlSGVhZGVyIiwiY29udmVydGVycyIsImFqYXhDb252ZXJ0IiwicmVzcG9uc2UiLCJpc1N1Y2Nlc3MiLCJjb252MiIsImN1cnJlbnQiLCJjb252IiwicmVzcG9uc2VGaWVsZHMiLCJkYXRhRmlsdGVyIiwidGhyb3dzIiwiYWN0aXZlIiwibGFzdE1vZGlmaWVkIiwiZXRhZyIsInVybCIsImlzTG9jYWwiLCJwcm90b2NvbCIsInByb2Nlc3NEYXRhIiwiYXN5bmMiLCJjb250ZW50VHlwZSIsImFjY2VwdHMiLCJqc29uIiwiYWpheFNldHVwIiwic2V0dGluZ3MiLCJhamF4UHJlZmlsdGVyIiwiYWpheFRyYW5zcG9ydCIsImFqYXgiLCJ0cmFuc3BvcnQiLCJjYWNoZVVSTCIsInJlc3BvbnNlSGVhZGVyc1N0cmluZyIsInJlc3BvbnNlSGVhZGVycyIsInRpbWVvdXRUaW1lciIsInVybEFuY2hvciIsImZpcmVHbG9iYWxzIiwidW5jYWNoZWQiLCJjYWxsYmFja0NvbnRleHQiLCJnbG9iYWxFdmVudENvbnRleHQiLCJjb21wbGV0ZURlZmVycmVkIiwic3RhdHVzQ29kZSIsInJlcXVlc3RIZWFkZXJzIiwicmVxdWVzdEhlYWRlcnNOYW1lcyIsInN0ckFib3J0IiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwic2V0UmVxdWVzdEhlYWRlciIsIm92ZXJyaWRlTWltZVR5cGUiLCJzdGF0dXMiLCJhYm9ydCIsInN0YXR1c1RleHQiLCJmaW5hbFRleHQiLCJjcm9zc0RvbWFpbiIsImhvc3QiLCJoYXNDb250ZW50IiwiaWZNb2RpZmllZCIsImhlYWRlcnMiLCJiZWZvcmVTZW5kIiwic3VjY2VzcyIsInNlbmQiLCJuYXRpdmVTdGF0dXNUZXh0IiwibW9kaWZpZWQiLCJnZXRKU09OIiwiZ2V0U2NyaXB0Iiwid3JhcEFsbCIsImZpcnN0RWxlbWVudENoaWxkIiwid3JhcElubmVyIiwiaHRtbElzRnVuY3Rpb24iLCJ1bndyYXAiLCJ2aXNpYmxlIiwib2Zmc2V0SGVpZ2h0IiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJ4aHJTdWNjZXNzU3RhdHVzIiwieGhyU3VwcG9ydGVkIiwiY29ycyIsImVycm9yQ2FsbGJhY2siLCJvcGVuIiwidXNlcm5hbWUiLCJ4aHJGaWVsZHMiLCJvbmxvYWQiLCJvbmVycm9yIiwib25hYm9ydCIsIm9udGltZW91dCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlc3BvbnNlVHlwZSIsInJlc3BvbnNlVGV4dCIsImJpbmFyeSIsImNoYXJzZXQiLCJzY3JpcHRDaGFyc2V0IiwiZXZ0Iiwib2xkQ2FsbGJhY2tzIiwicmpzb25wIiwianNvbnAiLCJqc29ucENhbGxiYWNrIiwib3JpZ2luYWxTZXR0aW5ncyIsImNhbGxiYWNrTmFtZSIsIm92ZXJ3cml0dGVuIiwicmVzcG9uc2VDb250YWluZXIiLCJqc29uUHJvcCIsImNyZWF0ZUhUTUxEb2N1bWVudCIsImltcGxlbWVudGF0aW9uIiwia2VlcFNjcmlwdHMiLCJwYXJzZWQiLCJwYXJhbXMiLCJhbmltYXRlZCIsIm9mZnNldCIsInNldE9mZnNldCIsImN1clBvc2l0aW9uIiwiY3VyTGVmdCIsImN1ckNTU1RvcCIsImN1clRvcCIsImN1ck9mZnNldCIsImN1ckNTU0xlZnQiLCJjYWxjdWxhdGVQb3NpdGlvbiIsImN1ckVsZW0iLCJ1c2luZyIsInJlY3QiLCJ3aW4iLCJwYWdlWU9mZnNldCIsInBhZ2VYT2Zmc2V0Iiwib2Zmc2V0UGFyZW50IiwicGFyZW50T2Zmc2V0Iiwic2Nyb2xsVG8iLCJIZWlnaHQiLCJXaWR0aCIsImRlZmF1bHRFeHRyYSIsImZ1bmNOYW1lIiwiaG92ZXIiLCJmbk92ZXIiLCJmbk91dCIsInVuYmluZCIsImRlbGVnYXRlIiwidW5kZWxlZ2F0ZSIsInByb3h5IiwiaG9sZFJlYWR5IiwiaG9sZCIsInBhcnNlSlNPTiIsImlzTnVtZXJpYyIsImlzTmFOIiwiZGVmaW5lIiwiX2pRdWVyeSIsIl8kIiwiJCIsIm5vQ29uZmxpY3QiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDN0RBOzs7Ozs7Ozs7Ozs7O0FBYUEsQ0FBQyxVQUFVQSxNQUFWLEVBQWtCQyxPQUFsQixFQUEyQjs7QUFFeEI7O0FBRUEsUUFBSSxnQ0FBT0MsTUFBUCxPQUFrQixRQUFsQixJQUE4QixRQUFPQSxPQUFPQyxPQUFkLE1BQTBCLFFBQTVELEVBQXNFOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBRCxlQUFPQyxPQUFQLEdBQWlCSCxPQUFPSSxRQUFQLEdBQ2JILFFBQVFELE1BQVIsRUFBZ0IsSUFBaEIsQ0FEYSxHQUViLFVBQVVLLENBQVYsRUFBYTtBQUNULGdCQUFJLENBQUNBLEVBQUVELFFBQVAsRUFBaUI7QUFDYixzQkFBTSxJQUFJRSxLQUFKLENBQVUsMENBQVYsQ0FBTjtBQUNIO0FBQ0QsbUJB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b0MsQ0FOaEI7O0FBUUEvbEMsV0FBT2dtQyxVQUFQLEdBQW9CLFVBQVV6akMsSUFBVixFQUFnQjtBQUNoQyxZQUFJL0UsT0FBT3VvQyxDQUFQLEtBQWEvbEMsTUFBakIsRUFBeUI7QUFDckJ4QyxtQkFBT3VvQyxDQUFQLEdBQVdELEVBQVg7QUFDSDs7QUFFRCxZQUFJdmpDLFFBQVEvRSxPQUFPd0MsTUFBUCxLQUFrQkEsTUFBOUIsRUFBc0M7QUFDbEN4QyxtQkFBT3dDLE1BQVAsR0FBZ0I2bEMsT0FBaEI7QUFDSDs7QUFFRCxlQUFPN2xDLE1BQVA7QUFDSCxLQVZEOztBQVlBO0FBQ0E7QUFDQTtBQUNBLFFBQUksQ0FBQ3ZDLFFBQUwsRUFBZTtBQUNYRCxlQUFPd0MsTUFBUCxHQUFnQnhDLE9BQU91b0MsQ0FBUCxHQUFXL2xDLE1BQTNCO0FBQ0g7O0FBS0QsV0FBT0EsTUFBUDtBQUNILENBL21VRCxFOzs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImpxdWVyeS1qcy9hcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvYnVpbGQvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2Fzc2V0cy9qcy9qcXVlcnkuanNcIik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYmNhNjNkMTlkNTU4YThiYzY5MzgiLCIvKiFcclxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4zLjFcclxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xyXG4gKlxyXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcclxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXHJcbiAqXHJcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXHJcbiAqXHJcbiAqIERhdGU6IDIwMTgtMDEtMjBUMTc6MjRaXHJcbiAqL1xyXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG5cclxuICAgICAgICAvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXHJcbiAgICAgICAgLy8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cclxuICAgICAgICAvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxyXG4gICAgICAgIC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxyXG4gICAgICAgIC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXHJcbiAgICAgICAgLy8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xyXG4gICAgICAgIC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xyXG4gICAgICAgICAgICBmYWN0b3J5KGdsb2JhbCwgdHJ1ZSkgOlxyXG4gICAgICAgICAgICBmdW5jdGlvbiAodykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF3LmRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KHcpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmYWN0b3J5KGdsb2JhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcclxufSkodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uICh3aW5kb3csIG5vR2xvYmFsKSB7XHJcblxyXG4gICAgLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXHJcbiAgICAvLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcclxuICAgIC8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXHJcbiAgICAvLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBhcnIgPSBbXTtcclxuXHJcbiAgICB2YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XHJcblxyXG4gICAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xyXG5cclxuICAgIHZhciBzbGljZSA9IGFyci5zbGljZTtcclxuXHJcbiAgICB2YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcclxuXHJcbiAgICB2YXIgcHVzaCA9IGFyci5wdXNoO1xyXG5cclxuICAgIHZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XHJcblxyXG4gICAgdmFyIGNsYXNzMnR5cGUgPSB7fTtcclxuXHJcbiAgICB2YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xyXG5cclxuICAgIHZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxuICAgIHZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xyXG5cclxuICAgIHZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbChPYmplY3QpO1xyXG5cclxuICAgIHZhciBzdXBwb3J0ID0ge307XHJcblxyXG4gICAgdmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXHJcbiAgICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXHJcbiAgICAgICAgLy8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cclxuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgdmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcclxuICAgIH07XHJcblxyXG5cclxuXHJcblxyXG4gICAgdmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XHJcbiAgICAgICAgdHlwZTogdHJ1ZSxcclxuICAgICAgICBzcmM6IHRydWUsXHJcbiAgICAgICAgbm9Nb2R1bGU6IHRydWVcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gRE9NRXZhbChjb2RlLCBkb2MsIG5vZGUpIHtcclxuICAgICAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XHJcblxyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcclxuXHJcbiAgICAgICAgc2NyaXB0LnRleHQgPSBjb2RlO1xyXG4gICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZVtpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdFtpXSA9IG5vZGVbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jLmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHRvVHlwZShvYmopIHtcclxuICAgICAgICBpZiAob2JqID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iaiArIFwiXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcclxuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xyXG4gICAgICAgICAgICBjbGFzczJ0eXBlW3RvU3RyaW5nLmNhbGwob2JqKV0gfHwgXCJvYmplY3RcIiA6XHJcbiAgICAgICAgICAgIHR5cGVvZiBvYmo7XHJcbiAgICB9XHJcbiAgICAvKiBnbG9iYWwgU3ltYm9sICovXHJcbiAgICAvLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxyXG4gICAgLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcclxuXHJcblxyXG5cclxuICAgIHZhclxyXG4gICAgICAgIHZlcnNpb24gPSBcIjMuMy4xXCIsXHJcblxyXG4gICAgICAgIC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XHJcbiAgICAgICAgalF1ZXJ5ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcclxuICAgICAgICAgICAgLy8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdChzZWxlY3RvciwgY29udGV4dCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXHJcbiAgICAgICAgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XHJcblxyXG4gICAgalF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxyXG4gICAgICAgIGpxdWVyeTogdmVyc2lvbixcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3I6IGpRdWVyeSxcclxuXHJcbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXHJcbiAgICAgICAgbGVuZ3RoOiAwLFxyXG5cclxuICAgICAgICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbGljZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1JcclxuICAgICAgICAvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKG51bSkge1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxyXG4gICAgICAgICAgICBpZiAobnVtID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzbGljZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XHJcbiAgICAgICAgICAgIHJldHVybiBudW0gPCAwID8gdGhpc1tudW0gKyB0aGlzLmxlbmd0aF0gOiB0aGlzW251bV07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xyXG4gICAgICAgIC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxyXG4gICAgICAgIHB1c2hTdGFjazogZnVuY3Rpb24gKGVsZW1zKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxyXG4gICAgICAgICAgICB2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcclxuICAgICAgICAgICAgcmV0LnByZXZPYmplY3QgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxyXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmVhY2godGhpcywgY2FsbGJhY2spO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG1hcDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhqUXVlcnkubWFwKHRoaXMsIGZ1bmN0aW9uIChlbGVtLCBpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChlbGVtLCBpLCBlbGVtKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNsaWNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhzbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmaXJzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcSgwKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBsYXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKC0xKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBlcTogZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgaiA9ICtpICsgKGkgPCAwID8gbGVuIDogMCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhqID49IDAgJiYgaiA8IGxlbiA/IFt0aGlzW2pdXSA6IFtdKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBlbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxyXG4gICAgICAgIC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxyXG4gICAgICAgIHB1c2g6IHB1c2gsXHJcbiAgICAgICAgc29ydDogYXJyLnNvcnQsXHJcbiAgICAgICAgc3BsaWNlOiBhcnIuc3BsaWNlXHJcbiAgICB9O1xyXG5cclxuICAgIGpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcclxuICAgICAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxyXG4gICAgICAgICAgICBpID0gMSxcclxuICAgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcclxuICAgICAgICAgICAgZGVlcCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgICAgIGRlZXAgPSB0YXJnZXQ7XHJcblxyXG4gICAgICAgICAgICAvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XHJcbiAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1tpXSB8fCB7fTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24odGFyZ2V0KSkge1xyXG4gICAgICAgICAgICB0YXJnZXQgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxyXG4gICAgICAgIGlmIChpID09PSBsZW5ndGgpIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcztcclxuICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICAgICAgICBpZiAoKG9wdGlvbnMgPSBhcmd1bWVudHNbaV0pICE9IG51bGwpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XHJcbiAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHRhcmdldFtuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gb3B0aW9uc1tuYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IGNvcHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcCAmJiBjb3B5ICYmIChqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGNvcHkpKSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3B5SXNBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGpRdWVyeS5leHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGNvcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGpRdWVyeS5leHRlbmQoe1xyXG5cclxuICAgICAgICAvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2VcclxuICAgICAgICBleHBhbmRvOiBcImpRdWVyeVwiICsgKHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKC9cXEQvZywgXCJcIiksXHJcblxyXG4gICAgICAgIC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXHJcbiAgICAgICAgaXNSZWFkeTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbm9vcDogZnVuY3Rpb24gKCkgeyB9LFxyXG5cclxuICAgICAgICBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm90bywgQ3RvcjtcclxuXHJcbiAgICAgICAgICAgIC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xyXG4gICAgICAgICAgICAvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcclxuICAgICAgICAgICAgaWYgKCFvYmogfHwgdG9TdHJpbmcuY2FsbChvYmopICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByb3RvID0gZ2V0UHJvdG8ob2JqKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cclxuICAgICAgICAgICAgaWYgKCFwcm90bykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIEN0b3IgPSBoYXNPd24uY2FsbChwcm90bywgXCJjb25zdHJ1Y3RvclwiKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKEN0b3IpID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XHJcblxyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcclxuICAgICAgICAgICAgdmFyIG5hbWU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcclxuICAgICAgICBnbG9iYWxFdmFsOiBmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgICAgICAgICBET01FdmFsKGNvZGUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGgsIGkgPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcclxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IG9iai5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwob2JqW2ldLCBpLCBvYmpbaV0pID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwob2JqW2ldLCBpLCBvYmpbaV0pID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XHJcbiAgICAgICAgdHJpbTogZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRleHQgPT0gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICBcIlwiIDpcclxuICAgICAgICAgICAgICAgICh0ZXh0ICsgXCJcIikucmVwbGFjZShydHJpbSwgXCJcIik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxyXG4gICAgICAgIG1ha2VBcnJheTogZnVuY3Rpb24gKGFyciwgcmVzdWx0cykge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChhcnIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKE9iamVjdChhcnIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZShyZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Fycl0gOiBhcnJcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwocmV0LCBhcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGluQXJyYXk6IGZ1bmN0aW9uIChlbGVtLCBhcnIsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoYXJyLCBlbGVtLCBpKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcclxuICAgICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XHJcbiAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGogPSAwLFxyXG4gICAgICAgICAgICAgICAgaSA9IGZpcnN0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBqIDwgbGVuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGZpcnN0W2krK10gPSBzZWNvbmRbal07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZpcnN0Lmxlbmd0aCA9IGk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmlyc3Q7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ3JlcDogZnVuY3Rpb24gKGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0KSB7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFja0ludmVyc2UsXHJcbiAgICAgICAgICAgICAgICBtYXRjaGVzID0gW10sXHJcbiAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcclxuXHJcbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcclxuICAgICAgICAgICAgLy8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKGVsZW1zW2ldLCBpKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGVsZW1zW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XHJcbiAgICAgICAgbWFwOiBmdW5jdGlvbiAoZWxlbXMsIGNhbGxiYWNrLCBhcmcpIHtcclxuICAgICAgICAgICAgdmFyIGxlbmd0aCwgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgIHJldCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKGVsZW1zKSkge1xyXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soZWxlbXNbaV0sIGksIGFyZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSBpbiBlbGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soZWxlbXNbaV0sIGksIGFyZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcclxuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseShbXSwgcmV0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcclxuICAgICAgICBndWlkOiAxLFxyXG5cclxuICAgICAgICAvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcclxuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxyXG4gICAgICAgIHN1cHBvcnQ6IHN1cHBvcnRcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBqUXVlcnkuZm5bU3ltYm9sLml0ZXJhdG9yXSA9IGFycltTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxyXG4gICAgalF1ZXJ5LmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KFwiIFwiKSxcclxuICAgICAgICBmdW5jdGlvbiAoaSwgbmFtZSkge1xyXG4gICAgICAgICAgICBjbGFzczJ0eXBlW1wiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIl0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2Uob2JqKSB7XHJcblxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcclxuICAgICAgICAvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXHJcbiAgICAgICAgLy8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXHJcbiAgICAgICAgLy8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxyXG4gICAgICAgIHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxyXG4gICAgICAgICAgICB0eXBlID0gdG9UeXBlKG9iaik7XHJcblxyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9iaikgfHwgaXNXaW5kb3cob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxyXG4gICAgICAgICAgICB0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKGxlbmd0aCAtIDEpIGluIG9iajtcclxuICAgIH1cclxuICAgIHZhciBTaXp6bGUgPVxyXG4gICAgICAgIC8qIVxyXG4gICAgICAgICAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuM1xyXG4gICAgICAgICAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcclxuICAgICAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICAgICAgICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBEYXRlOiAyMDE2LTA4LTA4XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgKGZ1bmN0aW9uICh3aW5kb3cpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICAgICAgc3VwcG9ydCxcclxuICAgICAgICAgICAgICAgIEV4cHIsXHJcbiAgICAgICAgICAgICAgICBnZXRUZXh0LFxyXG4gICAgICAgICAgICAgICAgaXNYTUwsXHJcbiAgICAgICAgICAgICAgICB0b2tlbml6ZSxcclxuICAgICAgICAgICAgICAgIGNvbXBpbGUsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3QsXHJcbiAgICAgICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgc29ydElucHV0LFxyXG4gICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIExvY2FsIGRvY3VtZW50IHZhcnNcclxuICAgICAgICAgICAgICAgIHNldERvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgICBkb2NFbGVtLFxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJc0hUTUwsXHJcbiAgICAgICAgICAgICAgICByYnVnZ3lRU0EsXHJcbiAgICAgICAgICAgICAgICByYnVnZ3lNYXRjaGVzLFxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyxcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5zLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcclxuICAgICAgICAgICAgICAgIGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgICBkaXJydW5zID0gMCxcclxuICAgICAgICAgICAgICAgIGRvbmUgPSAwLFxyXG4gICAgICAgICAgICAgICAgY2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXHJcbiAgICAgICAgICAgICAgICB0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcclxuICAgICAgICAgICAgICAgIGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxyXG4gICAgICAgICAgICAgICAgc29ydE9yZGVyID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW5zdGFuY2UgbWV0aG9kc1xyXG4gICAgICAgICAgICAgICAgaGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgIGFyciA9IFtdLFxyXG4gICAgICAgICAgICAgICAgcG9wID0gYXJyLnBvcCxcclxuICAgICAgICAgICAgICAgIHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXHJcbiAgICAgICAgICAgICAgICBwdXNoID0gYXJyLnB1c2gsXHJcbiAgICAgICAgICAgICAgICBzbGljZSA9IGFyci5zbGljZSxcclxuICAgICAgICAgICAgICAgIC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxyXG4gICAgICAgICAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChsaXN0LCBlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBsaXN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0W2ldID09PSBlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgXCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcclxuICAgICAgICAgICAgICAgICAgICAvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxyXG4gICAgICAgICAgICAgICAgICAgIFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcclxuICAgICAgICAgICAgICAgICAgICBcIipcXFxcXVwiLFxyXG5cclxuICAgICAgICAgICAgICAgIHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXHJcbiAgICAgICAgICAgICAgICAgICAgXCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXHJcbiAgICAgICAgICAgICAgICAgICAgXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcclxuICAgICAgICAgICAgICAgICAgICBcIi4qXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiKVxcXFwpfClcIixcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXHJcbiAgICAgICAgICAgICAgICByd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAod2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiksXHJcbiAgICAgICAgICAgICAgICBydHJpbSA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIpLFxyXG5cclxuICAgICAgICAgICAgICAgIHJjb21tYSA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiKSxcclxuICAgICAgICAgICAgICAgIHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiKSxcclxuXHJcbiAgICAgICAgICAgICAgICByYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cChcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiKSxcclxuXHJcbiAgICAgICAgICAgICAgICBycHNldWRvID0gbmV3IFJlZ0V4cChwc2V1ZG9zKSxcclxuICAgICAgICAgICAgICAgIHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiksXHJcblxyXG4gICAgICAgICAgICAgICAgbWF0Y2hFeHByID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiSURcIjogbmV3IFJlZ0V4cChcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiKSxcclxuICAgICAgICAgICAgICAgICAgICBcIkNMQVNTXCI6IG5ldyBSZWdFeHAoXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiVEFHXCI6IG5ldyBSZWdFeHAoXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJBVFRSXCI6IG5ldyBSZWdFeHAoXCJeXCIgKyBhdHRyaWJ1dGVzKSxcclxuICAgICAgICAgICAgICAgICAgICBcIlBTRVVET1wiOiBuZXcgUmVnRXhwKFwiXlwiICsgcHNldWRvcyksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJDSElMRFwiOiBuZXcgUmVnRXhwKFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiYm9vbFwiOiBuZXcgUmVnRXhwKFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiKSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXHJcbiAgICAgICAgICAgICAgICAgICAgXCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cChcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICByaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcclxuICAgICAgICAgICAgICAgIHJoZWFkZXIgPSAvXmhcXGQkL2ksXHJcblxyXG4gICAgICAgICAgICAgICAgcm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICBycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXHJcblxyXG4gICAgICAgICAgICAgICAgcnNpYmxpbmcgPSAvWyt+XS8sXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ1NTIGVzY2FwZXNcclxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcclxuICAgICAgICAgICAgICAgIHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIpLFxyXG4gICAgICAgICAgICAgICAgZnVuZXNjYXBlID0gZnVuY3Rpb24gKF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcclxuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWQgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdoIDwgMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCTVAgY29kZXBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGhpZ2ggKyAweDEwMDAwKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xyXG4gICAgICAgICAgICAgICAgcmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxyXG4gICAgICAgICAgICAgICAgZmNzc2VzY2FwZSA9IGZ1bmN0aW9uIChjaCwgYXNDb2RlUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXNDb2RlUG9pbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IFwiXFwwXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcdUZGRkRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoLnNsaWNlKDAsIC0xKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdChjaC5sZW5ndGggLSAxKS50b1N0cmluZygxNikgKyBcIiBcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcXCIgKyBjaDtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXNlZCBmb3IgaWZyYW1lc1xyXG4gICAgICAgICAgICAgICAgLy8gU2VlIHNldERvY3VtZW50KClcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxyXG4gICAgICAgICAgICAgICAgLy8gZXJyb3IgaW4gSUVcclxuICAgICAgICAgICAgICAgIHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZWRBbmNlc3RvciA9IGFkZENvbWJpbmF0b3IoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgKFwiZm9ybVwiIGluIGVsZW0gfHwgXCJsYWJlbFwiIGluIGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcHVzaC5hcHBseShcclxuICAgICAgICAgICAgICAgICAgICAoYXJyID0gc2xpY2UuY2FsbChwcmVmZXJyZWREb2MuY2hpbGROb2RlcykpLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZDw0LjBcclxuICAgICAgICAgICAgICAgIC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcclxuICAgICAgICAgICAgICAgIGFycltwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGhdLm5vZGVUeXBlO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcGx5OiBhcnIubGVuZ3RoID9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh0YXJnZXQsIGVscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaF9uYXRpdmUuYXBwbHkodGFyZ2V0LCBzbGljZS5jYWxsKGVscykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodGFyZ2V0LCBlbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSkgeyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQubGVuZ3RoID0gaiAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNpenpsZShzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcclxuICAgICAgICAgICAgICAgIGlmICghc2VlZCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYykgIT09IGRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldERvY3VtZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50SXNIVE1MKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKHNlbGVjdG9yKSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRCBzZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtID0gbWF0Y2hbMV0pKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IGNvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZChtKSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLmlkID09PSBtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZChtKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKGNvbnRleHQsIGVsZW0pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmlkID09PSBtKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFR5cGUgc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoc2VsZWN0b3IpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xhc3Mgc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKG0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydC5xc2EgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFjb21waWxlckNhY2hlW3NlbGVjdG9yICsgXCIgXCJdICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3Qoc2VsZWN0b3IpKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD04XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaWQgPSBuaWQucmVwbGFjZShyY3NzZXNjYXBlLCBmY3NzZXNjYXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldEF0dHJpYnV0ZShcImlkXCIsIChuaWQgPSBleHBhbmRvKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cHMgPSB0b2tlbml6ZShzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGdyb3Vwcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3Rvcihncm91cHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKFwiLFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3Qoc2VsZWN0b3IpICYmIHRlc3RDb250ZXh0KGNvbnRleHQucGFyZW50Tm9kZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwobmV3U2VsZWN0b3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHFzYUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5pZCA9PT0gZXhwYW5kbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgb3RoZXJzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0KHNlbGVjdG9yLnJlcGxhY2UocnRyaW0sIFwiJDFcIiksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcclxuICAgICAgICAgICAgICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXHJcbiAgICAgICAgICAgICAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2FjaGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXMucHVzaChrZXkgKyBcIiBcIikgPiBFeHByLmNhY2hlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVba2V5cy5zaGlmdCgpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjYWNoZVtrZXkgKyBcIiBcIl0gPSB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gbWFya0Z1bmN0aW9uKGZuKSB7XHJcbiAgICAgICAgICAgICAgICBmbltleHBhbmRvXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBhc3NlcnQoZm4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWZuKGVsKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxyXG4gICAgICAgICAgICAgICAgICAgIGVsID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcclxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZEhhbmRsZShhdHRycywgaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcclxuICAgICAgICAgICAgICAgICAgICBpID0gYXJyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRXhwci5hdHRySGFuZGxlW2FycltpXV0gPSBoYW5kbGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGFcclxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBiXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gc2libGluZ0NoZWNrKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXIgPSBiICYmIGEsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoZGlmZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaWZmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjdXIgPSBjdXIubmV4dFNpYmxpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcclxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyhkaXNhYmxlZCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZm9ybVwiIGluIGVsZW0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwibGFiZWxcIiBpbiBlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA2IC0gMTFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGpzaGludCAtVzAxOCAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWRBbmNlc3RvcihlbGVtKSA9PT0gZGlzYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJsYWJlbFwiIGluIGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoYXJndW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudCA9ICthcmd1bWVudDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWVkLCBtYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzID0gZm4oW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VlZFsoaiA9IG1hdGNoSW5kZXhlc1tpXSldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcclxuICAgICAgICAgICAgICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiB0ZXN0Q29udGV4dChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxyXG4gICAgICAgICAgICBzdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZXRlY3RzIFhNTCBub2Rlc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XHJcbiAgICAgICAgICAgICAgICAvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcclxuICAgICAgICAgICAgICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcclxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcclxuICAgICAgICAgICAgICAgICAgICBkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcclxuICAgICAgICAgICAgICAgIGlmIChkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQgPSBkb2M7XHJcbiAgICAgICAgICAgICAgICBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoZG9jdW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2VcclxuICAgICAgICAgICAgICAgIC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcclxuICAgICAgICAgICAgICAgIGlmIChwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTEsIEVkZ2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1YldpbmRvdy5hdHRhY2hFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJXaW5kb3cuYXR0YWNoRXZlbnQoXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyogQXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDhcclxuICAgICAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgLy8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXHJcbiAgICAgICAgICAgICAgICBzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gXCJpXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKiBnZXRFbGVtZW50KHMpQnkqXHJcbiAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw5XHJcbiAgICAgICAgICAgICAgICBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8MTBcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXHJcbiAgICAgICAgICAgICAgICAvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3RcclxuICAgICAgICAgICAgICAgIHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKGVsKS5pZCA9IGV4cGFuZG87XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoZXhwYW5kbykubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSUQgZmlsdGVyIGFuZCBmaW5kXHJcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydC5nZXRCeUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24gKGlkLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtID8gW2VsZW1dIDogW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxyXG4gICAgICAgICAgICAgICAgICAgIEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24gKGlkLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUsIGksIGVsZW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKGlkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2VsZW1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtc1tpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUudmFsdWUgPT09IGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2VsZW1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGFnXHJcbiAgICAgICAgICAgICAgICBFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodGFnLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnFzYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCh0YWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh0YWcsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gXCIqXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IHJlc3VsdHNbaSsrXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAucHVzaChlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENsYXNzXHJcbiAgICAgICAgICAgICAgICBFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiAoY2xhc3NOYW1lLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyogUVNBL21hdGNoZXNTZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxyXG4gICAgICAgICAgICAgICAgcmJ1Z2d5TWF0Y2hlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3JcclxuICAgICAgICAgICAgICAgIC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcclxuICAgICAgICAgICAgICAgIC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXHJcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XHJcbiAgICAgICAgICAgICAgICByYnVnZ3lRU0EgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkIFFTQSByZWdleFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZChlbCkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiaGlkZGVuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChpbnB1dCkuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcIkRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRThcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU5LTExK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZChlbCkuZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCgobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcclxuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcclxuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoZWwsIFwiKlwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLmNhbGwoZWwsIFwiW3MhPScnXTp4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lNYXRjaGVzLnB1c2goXCIhPVwiLCBwc2V1ZG9zKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAocmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpKTtcclxuICAgICAgICAgICAgICAgIHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKHJidWdneU1hdGNoZXMuam9pbihcInxcIikpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qIENvbnRhaW5zXHJcbiAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICAgICAgICAgICAgICBoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxyXG4gICAgICAgICAgICAgICAgLy8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXHJcbiAgICAgICAgICAgICAgICAvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxyXG4gICAgICAgICAgICAgICAgY29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdChkb2NFbGVtLmNvbnRhaW5zKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYnVwIHx8ICEhKGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRvd24uY29udGFpbnMgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkb3duLmNvbnRhaW5zKGJ1cCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihidXApICYgMTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSA6XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoYiA9IGIucGFyZW50Tm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYiA9PT0gYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyogU29ydGluZ1xyXG4gICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcclxuICAgICAgICAgICAgICAgIHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChhLCBiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmUgPSAoYS5vd25lckRvY3VtZW50IHx8IGEpID09PSAoYi5vd25lckRvY3VtZW50IHx8IGIpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZSAmIDEgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihhKSA9PT0gY29tcGFyZSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRJbnB1dCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGluZGV4T2Yoc29ydElucHV0LCBhKSAtIGluZGV4T2Yoc29ydElucHV0LCBiKSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgICAgICB9IDpcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1cCA9IGEucGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1cCA9IGIucGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwID0gW2FdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnAgPSBbYl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWF1cCB8fCAhYnVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9PT0gZG9jdW1lbnQgPyAxIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVwID8gLTEgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVwID8gMSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydElucHV0ID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGluZGV4T2Yoc29ydElucHV0LCBhKSAtIGluZGV4T2Yoc29ydElucHV0LCBiKSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXVwID09PSBidXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWJsaW5nQ2hlY2soYSwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY3VyID0gY3VyLnBhcmVudE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcC51bnNoaWZ0KGN1cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjdXIgPSBjdXIucGFyZW50Tm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJwLnVuc2hpZnQoY3VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFwW2ldID09PSBicFtpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmdDaGVjayhhcFtpXSwgYnBbaV0pIDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiAoZXhwciwgZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTaXp6bGUoZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uIChlbGVtLCBleHByKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGlmICgoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pICE9PSBkb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldERvY3VtZW50KGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxyXG4gICAgICAgICAgICAgICAgZXhwciA9IGV4cHIucmVwbGFjZShyYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcclxuICAgICAgICAgICAgICAgICAgICAhY29tcGlsZXJDYWNoZVtleHByICsgXCIgXCJdICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKCFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoZXhwcikpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KGV4cHIpKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKGVsZW0sIGV4cHIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcmFnbWVudCBpbiBJRSA5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNpenpsZShleHByLCBkb2N1bWVudCwgbnVsbCwgW2VsZW1dKS5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZW0pIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKChjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCkgIT09IGRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbnMoY29udGV4dCwgZWxlbSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBTaXp6bGUuYXR0ciA9IGZ1bmN0aW9uIChlbGVtLCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGlmICgoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pICE9PSBkb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldERvY3VtZW50KGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVtuYW1lLnRvTG93ZXJDYXNlKCldLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGZuICYmIGhhc093bi5jYWxsKEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuKGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgICAgICB2YWwgOlxyXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZShuYW1lKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLnZhbHVlIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBTaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24gKHNlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgU2l6emxlLmVycm9yID0gZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZXMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBqID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXHJcbiAgICAgICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xyXG4gICAgICAgICAgICAgICAgc29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKDApO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5zb3J0KHNvcnRPcmRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0R1cGxpY2F0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IHJlc3VsdHNbaSsrXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0gPT09IHJlc3VsdHNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSBkdXBsaWNhdGVzLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGotLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnNwbGljZShkdXBsaWNhdGVzW2pdLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcclxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxyXG4gICAgICAgICAgICAgICAgc29ydElucHV0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSxcclxuICAgICAgICAgICAgICAgICAgICByZXQgPSBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG5vZGUgPSBlbGVtW2krK10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBnZXRUZXh0KG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnRleHRDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgKz0gZ2V0VGV4dChlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXHJcbiAgICAgICAgICAgICAgICBjYWNoZUxlbmd0aDogNTAsXHJcblxyXG4gICAgICAgICAgICAgICAgY3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXHJcblxyXG4gICAgICAgICAgICAgICAgbWF0Y2g6IG1hdGNoRXhwcixcclxuXHJcbiAgICAgICAgICAgICAgICBhdHRySGFuZGxlOiB7fSxcclxuXHJcbiAgICAgICAgICAgICAgICBmaW5kOiB7fSxcclxuXHJcbiAgICAgICAgICAgICAgICByZWxhdGl2ZToge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcclxuICAgICAgICAgICAgICAgICAgICBcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBwcmVGaWx0ZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICBcIkFUVFJcIjogZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFszXSA9IChtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiKS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFsyXSA9PT0gXCJ+PVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDAsIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiQ0hJTERcIjogZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMSB0eXBlIChvbmx5fG50aHwuLi4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1IHNpZ24gb2YgeG4tY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA2IHggb2YgeG4tY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA3IHNpZ24gb2YgeS1jb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDggeSBvZiB5LWNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0uc2xpY2UoMCwgMykgPT09IFwibnRoXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoWzNdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKG1hdGNoWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzRdID0gKyhtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqIChtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzVdID0gKygobWF0Y2hbN10gKyBtYXRjaFs4XSkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzNdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IobWF0Y2hbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJQU0VVRE9cIjogZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleGNlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KG1hdGNoWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KHVucXVvdGVkKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleGNlc3MgPSB0b2tlbml6ZSh1bnF1b3RlZCwgdHJ1ZSkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MpIC0gdW5xdW90ZWQubGVuZ3RoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKDAsIGV4Y2Vzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKDAsIGV4Y2Vzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2guc2xpY2UoMCwgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJUQUdcIjogZnVuY3Rpb24gKG5vZGVOYW1lU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiQ0xBU1NcIjogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbY2xhc3NOYW1lICsgXCIgXCJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm4gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwYXR0ZXJuID0gbmV3IFJlZ0V4cChcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIikpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc0NhY2hlKGNsYXNzTmFtZSwgZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiQVRUUlwiOiBmdW5jdGlvbiAobmFtZSwgb3BlcmF0b3IsIGNoZWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKGVsZW0sIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZihjaGVjaykgPT09IDAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKGNoZWNrKSA+IC0xIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKC1jaGVjay5sZW5ndGgpID09PSBjaGVjayA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcIn49XCIgPyAoXCIgXCIgKyByZXN1bHQucmVwbGFjZShyd2hpdGVzcGFjZSwgXCIgXCIpICsgXCIgXCIpLmluZGV4T2YoY2hlY2spID4gLTEgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKDAsIGNoZWNrLmxlbmd0aCArIDEpID09PSBjaGVjayArIFwiLVwiIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcIkNISUxEXCI6IGZ1bmN0aW9uICh0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoMCwgMykgIT09IFwibnRoXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkID0gdHlwZS5zbGljZSgtNCkgIT09IFwibGFzdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2ltcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZVtkaXJdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2ZUeXBlID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVUeXBlID09PSAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IFtmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkICYmIHVzZUNhY2hlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBub2RlW2V4cGFuZG9dIHx8IChub2RlW2V4cGFuZG9dID0ge30pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlW25vZGUudW5pcXVlSURdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gPSB7fSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSB1bmlxdWVDYWNoZVt0eXBlXSB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbbm9kZUluZGV4XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbZGlyXSB8fFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVbdHlwZV0gPSBbZGlycnVucywgbm9kZUluZGV4LCBkaWZmXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZUNhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBub2RlW2V4cGFuZG9dIHx8IChub2RlW2V4cGFuZG9dID0ge30pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlW25vZGUudW5pcXVlSURdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvdXRlckNhY2hlW25vZGUudW5pcXVlSURdID0ge30pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IHVuaXF1ZUNhY2hlW3R5cGVdIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBub2RlSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geG1sIDpudGgtY2hpbGQoLi4uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbZGlyXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvZlR5cGUgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDEpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2RpZmYpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlQ2FjaGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gbm9kZVtleHBhbmRvXSB8fCAobm9kZVtleHBhbmRvXSA9IHt9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPDkgb25seVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSA9IHt9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVbdHlwZV0gPSBbZGlycnVucywgZGlmZl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiAtPSBsYXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcIlBTRVVET1wiOiBmdW5jdGlvbiAocHNldWRvLCBhcmd1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBFeHByLnBzZXVkb3NbcHNldWRvXSB8fCBFeHByLnNldEZpbHRlcnNbcHNldWRvLnRvTG93ZXJDYXNlKCldIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuW2V4cGFuZG9dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oYXJndW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkocHNldWRvLnRvTG93ZXJDYXNlKCkpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlZWQsIG1hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmbihzZWVkLCBhcmd1bWVudCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2hlZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGluZGV4T2Yoc2VlZCwgbWF0Y2hlZFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVkW2lkeF0gPSAhKG1hdGNoZXNbaWR4XSA9IG1hdGNoZWRbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihlbGVtLCAwLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBwc2V1ZG9zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXHJcbiAgICAgICAgICAgICAgICAgICAgXCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyID0gY29tcGlsZShzZWxlY3Rvci5yZXBsYWNlKHJ0cmltLCBcIiQxXCIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVyW2V4cGFuZG9dID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZCA9IG1hdGNoZXIoc2VlZCwgbnVsbCwgeG1sLCBbXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBzZWVkLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlbGVtID0gdW5tYXRjaGVkW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0sIGNvbnRleHQsIHhtbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0WzBdID0gZWxlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyKGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRbMF0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhcmVzdWx0cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2l6emxlKHNlbGVjdG9yLCBlbGVtKS5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dChlbGVtKSkuaW5kZXhPZih0ZXh0KSA+IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xyXG4gICAgICAgICAgICAgICAgICAgIFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKGxhbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5nID0gbGFuZy5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtTGFuZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmxhbmcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YobGFuZyArIFwiLVwiKSA9PT0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1pc2NlbGxhbmVvdXNcclxuICAgICAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSgxKSA9PT0gZWxlbS5pZDtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInJvb3RcIjogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJmb2N1c1wiOiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgIFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyhmYWxzZSksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyh0cnVlKSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjaGVja2VkXCI6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzZWxlY3RlZFwiOiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgXCJlbXB0eVwiOiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPCA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwicGFyZW50XCI6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRWxlbWVudC9pbnB1dCB0eXBlc1xyXG4gICAgICAgICAgICAgICAgICAgIFwiaGVhZGVyXCI6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByaGVhZGVyLnRlc3QoZWxlbS5ub2RlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpbnB1dFwiOiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlucHV0cy50ZXN0KGVsZW0ubm9kZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiYnV0dG9uXCI6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgXCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFswXTtcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24gKG1hdGNoSW5kZXhlcywgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAobWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudF07XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChtYXRjaEluZGV4ZXMsIGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24gKG1hdGNoSW5kZXhlcywgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgLS1pID49IDA7KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24gKG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyArK2kgPCBsZW5ndGg7KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBFeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXHJcbiAgICAgICAgICAgIGZvciAoaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0pIHtcclxuICAgICAgICAgICAgICAgIEV4cHIucHNldWRvc1tpXSA9IGNyZWF0ZUlucHV0UHNldWRvKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSkge1xyXG4gICAgICAgICAgICAgICAgRXhwci5wc2V1ZG9zW2ldID0gY3JlYXRlQnV0dG9uUHNldWRvKGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcclxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0RmlsdGVycygpIHsgfVxyXG4gICAgICAgICAgICBzZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcclxuICAgICAgICAgICAgRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcclxuXHJcbiAgICAgICAgICAgIHRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBwYXJzZU9ubHkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gdG9rZW5DYWNoZVtzZWxlY3RvciArIFwiIFwiXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc29GYXIgPSBzZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgIGdyb3VwcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgcHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChzb0Zhcikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21tYSBhbmQgZmlyc3QgcnVuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKHNvRmFyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZShtYXRjaFswXS5sZW5ndGgpIHx8IHNvRmFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKCh0b2tlbnMgPSBbXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5hdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyhzb0ZhcikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbWF0Y2hbMF0ucmVwbGFjZShydHJpbSwgXCIgXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoZWQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlcnNcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHR5cGUgaW4gRXhwci5maWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYXRjaCA9IG1hdGNoRXhwclt0eXBlXS5leGVjKHNvRmFyKSkgJiYgKCFwcmVGaWx0ZXJzW3R5cGVdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF0Y2ggPSBwcmVGaWx0ZXJzW3R5cGVdKG1hdGNoKSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXM6IG1hdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UobWF0Y2hlZC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUganVzdCBwYXJzaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZU9ubHkgP1xyXG4gICAgICAgICAgICAgICAgICAgIHNvRmFyLmxlbmd0aCA6XHJcbiAgICAgICAgICAgICAgICAgICAgc29GYXIgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3Ioc2VsZWN0b3IpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHRva2Vuc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkNhY2hlKHNlbGVjdG9yLCBncm91cHMpLnNsaWNlKDApO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gdG9TZWxlY3Rvcih0b2tlbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBsZW4gPSB0b2tlbnMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZENvbWJpbmF0b3IobWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxyXG4gICAgICAgICAgICAgICAgICAgIHNraXAgPSBjb21iaW5hdG9yLm5leHQsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gc2tpcCB8fCBkaXIsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcclxuICAgICAgICAgICAgICAgICAgICBkb25lTmFtZSA9IGRvbmUrKztcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tYmluYXRvci5maXJzdCA/XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0sIGNvbnRleHQsIHhtbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtW2Rpcl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIoZWxlbSwgY29udGV4dCwgeG1sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhY2hlID0gW2RpcnJ1bnMsIGRvbmVOYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeG1sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtW2Rpcl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcihlbGVtLCBjb250ZXh0LCB4bWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW1bZGlyXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBlbGVtW2V4cGFuZG9dIHx8IChlbGVtW2V4cGFuZG9dID0ge30pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPDkgb25seVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlW2VsZW0udW5pcXVlSURdIHx8IChvdXRlckNhY2hlW2VsZW0udW5pcXVlSURdID0ge30pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbVtkaXJdIHx8IGVsZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVba2V5XSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZENhY2hlWzBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWzFdID09PSBkb25lTmFtZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5ld0NhY2hlWzJdID0gb2xkQ2FjaGVbMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVba2V5XSA9IG5ld0NhY2hlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChuZXdDYWNoZVsyXSA9IG1hdGNoZXIoZWxlbSwgY29udGV4dCwgeG1sKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXJzW2ldKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSA6XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcnNbMF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gY29udGV4dHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIFNpenpsZShzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbmRlbnNlKHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VW5tYXRjaGVkID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBtYXBwZWQgPSBtYXAgIT0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChlbGVtID0gdW5tYXRjaGVkW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZWxlbSwgY29udGV4dCwgeG1sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VW5tYXRjaGVkLnB1c2goZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1VubWF0Y2hlZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0TWF0Y2hlcihwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyW2V4cGFuZG9dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zdEZpbHRlciA9IHNldE1hdGNoZXIocG9zdEZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlcltleHBhbmRvXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKHBvc3RGaW5kZXIsIHBvc3RTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCwgaSwgZWxlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlTWFwID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNYXAgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gW2NvbnRleHRdIDogY29udGV4dCwgW10pLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoc2VlZCB8fCAhc2VsZWN0b3IpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRlbnNlKGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtcyxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0RmluZGVyIHx8IChzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlcikgP1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXSA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlckluO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIobWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcG9zdEZpbHRlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3N0RmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBjb25kZW5zZShtYXRjaGVyT3V0LCBwb3N0TWFwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdEZpbHRlcih0ZW1wLCBbXSwgY29udGV4dCwgeG1sKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHRlbXAubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSB0ZW1wW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXRbcG9zdE1hcFtpXV0gPSAhKG1hdGNoZXJJbltwb3N0TWFwW2ldXSA9IGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3N0RmluZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZWxlbSA9IG1hdGNoZXJPdXRbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5wdXNoKChtYXRjaGVySW5baV0gPSBlbGVtKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlcihudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2Yoc2VlZCwgZWxlbSkgOiBwcmVNYXBbaV0pID4gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXQgPSBjb25kZW5zZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXQuc3BsaWNlKHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3RGaW5kZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RGaW5kZXIobnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgbWF0Y2hlck91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVt0b2tlbnNbMF0udHlwZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgaW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcclxuICAgICAgICAgICAgICAgICAgICBpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvcihmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4T2YoY2hlY2tDb250ZXh0LCBlbGVtKSA+IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXJzID0gW2Z1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9ICghbGVhZGluZ1JlbGF0aXZlICYmICh4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCkpIHx8IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hDb250ZXh0KGVsZW0sIGNvbnRleHQsIHhtbCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQW55Q29udGV4dChlbGVtLCBjb250ZXh0LCB4bWwpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQ29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfV07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbdG9rZW5zW2ldLnR5cGVdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVycyA9IFthZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKG1hdGNoZXJzKSwgbWF0Y2hlcildO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIgPSBFeHByLmZpbHRlclt0b2tlbnNbaV0udHlwZV0uYXBwbHkobnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXJbZXhwYW5kb10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9ICsraTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBqIDwgbGVuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRXhwci5yZWxhdGl2ZVt0b2tlbnNbal0udHlwZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldE1hdGNoZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA+IDEgJiYgZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPiAxICYmIHRvU2VsZWN0b3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5zbGljZSgwLCBpIC0gMSkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1tpIC0gMl0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLnJlcGxhY2UocnRyaW0sIFwiJDFcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2Vucyh0b2tlbnMuc2xpY2UoaSwgaikpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoKHRva2VucyA9IHRva2Vucy5zbGljZShqKSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPCBsZW4gJiYgdG9TZWxlY3Rvcih0b2tlbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJzLnB1c2gobWF0Y2hlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyhlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uIChzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSwgaiwgbWF0Y2hlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRDb3VudCA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gXCIwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXShcIipcIiwgb3V0ZXJtb3N0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGVsZW1zLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRlcm1vc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5RWxlbWVudCAmJiBlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbCA9ICFkb2N1bWVudElzSFRNTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyKGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRlcm1vc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieVNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1hdGNoZWQucHVzaChlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZENvdW50ICs9IGk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtZXJpY2FsbHkgemVyby5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIodW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbChyZXN1bHRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNYXRjaGVkID0gY29uZGVuc2Uoc2V0TWF0Y2hlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBzZXRNYXRjaGVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCkgPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS51bmlxdWVTb3J0KHJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGVybW9zdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVubWF0Y2hlZDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBieVNldCA/XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya0Z1bmN0aW9uKHN1cGVyTWF0Y2hlcikgOlxyXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyTWF0Y2hlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlcnMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBjb21waWxlckNhY2hlW3NlbGVjdG9yICsgXCIgXCJdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghY2FjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHRva2VuaXplKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKG1hdGNoW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZFtleHBhbmRvXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlcnMucHVzaChjYWNoZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzLnB1c2goY2FjaGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gY29tcGlsZXJDYWNoZShzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcclxuICAgICAgICAgICAgICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxyXG4gICAgICAgICAgICAgKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcclxuICAgICAgICAgICAgICAgICAgICBjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxyXG4gICAgICAgICAgICAgICAgLy8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA9PT0gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVt0b2tlbnNbMV0udHlwZV0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSAoRXhwci5maW5kW1wiSURcIl0odG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCkgfHwgW10pWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21waWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSh0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdChzZWxlY3RvcikgPyAwIDogdG9rZW5zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRXhwci5yZWxhdGl2ZVsodHlwZSA9IHRva2VuLnR5cGUpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmaW5kID0gRXhwci5maW5kW3R5cGVdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHNlZWQgPSBmaW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnNpYmxpbmcudGVzdCh0b2tlbnNbMF0udHlwZSkgJiYgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSB8fCBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3Rvcih0b2tlbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBzZWVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcclxuICAgICAgICAgICAgICAgIC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcclxuICAgICAgICAgICAgICAgIChjb21waWxlZCB8fCBjb21waWxlKHNlbGVjdG9yLCBtYXRjaCkpKFxyXG4gICAgICAgICAgICAgICAgICAgIHNlZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAhZG9jdW1lbnRJc0hUTUwsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyxcclxuICAgICAgICAgICAgICAgICAgICAhY29udGV4dCB8fCByc2libGluZy50ZXN0KHNlbGVjdG9yKSAmJiB0ZXN0Q29udGV4dChjb250ZXh0LnBhcmVudE5vZGUpIHx8IGNvbnRleHRcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXHJcblxyXG4gICAgICAgICAgICAvLyBTb3J0IHN0YWJpbGl0eVxyXG4gICAgICAgICAgICBzdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoc29ydE9yZGVyKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xyXG5cclxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xyXG4gICAgICAgICAgICAvLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIHN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xyXG5cclxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XHJcbiAgICAgICAgICAgIHNldERvY3VtZW50KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxyXG4gICAgICAgICAgICAvLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcclxuICAgICAgICAgICAgc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikpICYgMTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw4XHJcbiAgICAgICAgICAgIC8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XHJcbiAgICAgICAgICAgIGlmICghYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIjtcclxuICAgICAgICAgICAgfSkpIHtcclxuICAgICAgICAgICAgICAgIGFkZEhhbmRsZShcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1hNTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OVxyXG4gICAgICAgICAgICAvLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXHJcbiAgICAgICAgICAgIGlmICghc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XHJcbiAgICAgICAgICAgICAgICBlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IFwiXCI7XHJcbiAgICAgICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGUoXCJ2YWx1ZVwiLCBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgaXNYTUwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OVxyXG4gICAgICAgICAgICAvLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXHJcbiAgICAgICAgICAgIGlmICghYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XHJcbiAgICAgICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGUoYm9vbGVhbnMsIGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBpc1hNTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1hNTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbVtuYW1lXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwudmFsdWUgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBTaXp6bGU7XHJcblxyXG4gICAgICAgIH0pKHdpbmRvdyk7XHJcblxyXG5cclxuXHJcbiAgICBqUXVlcnkuZmluZCA9IFNpenpsZTtcclxuICAgIGpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcclxuXHJcbiAgICAvLyBEZXByZWNhdGVkXHJcbiAgICBqUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xyXG4gICAgalF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XHJcbiAgICBqUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xyXG4gICAgalF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xyXG4gICAgalF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xyXG4gICAgalF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgZGlyID0gZnVuY3Rpb24gKGVsZW0sIGRpciwgdW50aWwpIHtcclxuICAgICAgICB2YXIgbWF0Y2hlZCA9IFtdLFxyXG4gICAgICAgICAgICB0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW1bZGlyXSkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSkge1xyXG4gICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRydW5jYXRlICYmIGpRdWVyeShlbGVtKS5pcyh1bnRpbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaChlbGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0Y2hlZDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIHZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uIChuLCBlbGVtKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICg7IG47IG4gPSBuLm5leHRTaWJsaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0pIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaChuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICB2YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcclxuXHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIG5vZGVOYW1lKGVsZW0sIG5hbWUpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgfTtcclxuICAgIHZhciByc2luZ2xlVGFnID0gKC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pKTtcclxuXHJcblxyXG5cclxuICAgIC8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XHJcbiAgICBmdW5jdGlvbiB3aW5ub3coZWxlbWVudHMsIHF1YWxpZmllciwgbm90KSB7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocXVhbGlmaWVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtLCBpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISFxdWFsaWZpZXIuY2FsbChlbGVtLCBpLCBlbGVtKSAhPT0gbm90O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNpbmdsZSBlbGVtZW50XHJcbiAgICAgICAgaWYgKHF1YWxpZmllci5ub2RlVHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGVsZW0gPT09IHF1YWxpZmllcikgIT09IG5vdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcclxuICAgICAgICBpZiAodHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4T2YuY2FsbChxdWFsaWZpZXIsIGVsZW0pID4gLTEpICE9PSBub3Q7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xyXG4gICAgICAgIHJldHVybiBqUXVlcnkuZmlsdGVyKHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCk7XHJcbiAgICB9XHJcblxyXG4gICAgalF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uIChleHByLCBlbGVtcywgbm90KSB7XHJcbiAgICAgICAgdmFyIGVsZW0gPSBlbGVtc1swXTtcclxuXHJcbiAgICAgICAgaWYgKG5vdCkge1xyXG4gICAgICAgICAgICBleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoZWxlbSwgZXhwcikgPyBbZWxlbV0gOiBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKGV4cHIsIGpRdWVyeS5ncmVwKGVsZW1zLCBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgaSwgcmV0LFxyXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhqUXVlcnkoc2VsZWN0b3IpLmZpbHRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuY29udGFpbnMoc2VsZltpXSwgdGhpcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXQgPSB0aGlzLnB1c2hTdGFjayhbXSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kKHNlbGVjdG9yLCBzZWxmW2ldLCByZXQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KHJldCkgOiByZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sod2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbm90OiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXM6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gISF3aW5ub3coXHJcbiAgICAgICAgICAgICAgICB0aGlzLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcclxuICAgICAgICAgICAgICAgIC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cclxuICAgICAgICAgICAgICAgIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3Qoc2VsZWN0b3IpID9cclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoc2VsZWN0b3IpIDpcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciB8fCBbXSxcclxuICAgICAgICAgICAgICAgIGZhbHNlXHJcbiAgICAgICAgICAgICkubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxyXG5cclxuXHJcbiAgICAvLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcclxuICAgIHZhciByb290alF1ZXJ5LFxyXG5cclxuICAgICAgICAvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xyXG4gICAgICAgIC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcclxuICAgICAgICAvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcclxuICAgICAgICAvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXHJcbiAgICAgICAgcnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxyXG5cclxuICAgICAgICBpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoLCBlbGVtO1xyXG5cclxuICAgICAgICAgICAgLy8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXHJcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcclxuICAgICAgICAgICAgLy8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxyXG4gICAgICAgICAgICByb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIEhUTUwgc3RyaW5nc1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JbMF0gPT09IFwiPFwiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV0gPT09IFwiPlwiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IubGVuZ3RoID49IDMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IFtudWxsLCBzZWxlY3RvciwgbnVsbF07XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyhzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmIChtYXRjaFsxXSB8fCAhY29udGV4dCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFswXSA6IGNvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnNpbmdsZVRhZy50ZXN0KG1hdGNoWzFdKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChtYXRjaCBpbiBjb250ZXh0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW21hdGNoXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1ttYXRjaF0oY29udGV4dFttYXRjaF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cihtYXRjaCwgY29udGV4dFttYXRjaF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoI2lkKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtYXRjaFsyXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzBdID0gZWxlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjb250ZXh0IHx8IHJvb3QpLmZpbmQoc2VsZWN0b3IpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcclxuICAgICAgICAgICAgICAgICAgICAvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IoY29udGV4dCkuZmluZChzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKERPTUVsZW1lbnQpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3Iubm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbMF0gPSBzZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChmdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgICAgICByb290LnJlYWR5KHNlbGVjdG9yKSA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcihqUXVlcnkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm1ha2VBcnJheShzZWxlY3RvciwgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAvLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXHJcbiAgICBpbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXHJcbiAgICByb290alF1ZXJ5ID0galF1ZXJ5KGRvY3VtZW50KTtcclxuXHJcblxyXG4gICAgdmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxyXG5cclxuICAgICAgICAvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxyXG4gICAgICAgIGd1YXJhbnRlZWRVbmlxdWUgPSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0cnVlLFxyXG4gICAgICAgICAgICBjb250ZW50czogdHJ1ZSxcclxuICAgICAgICAgICAgbmV4dDogdHJ1ZSxcclxuICAgICAgICAgICAgcHJldjogdHJ1ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICAgICAgaGFzOiBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRzID0galF1ZXJ5KHRhcmdldCwgdGhpcyksXHJcbiAgICAgICAgICAgICAgICBsID0gdGFyZ2V0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmNvbnRhaW5zKHRoaXMsIHRhcmdldHNbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2xvc2VzdDogZnVuY3Rpb24gKHNlbGVjdG9ycywgY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgY3VyLFxyXG4gICAgICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICBsID0gdGhpcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gW10sXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoc2VsZWN0b3JzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcclxuICAgICAgICAgICAgaWYgKCFybmVlZHNDb250ZXh0LnRlc3Qoc2VsZWN0b3JzKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGN1ciA9IHRoaXNbaV07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA8IDExICYmICh0YXJnZXRzID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldHMuaW5kZXgoY3VyKSA+IC0xIDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGN1ciwgc2VsZWN0b3JzKSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2goY3VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sobWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQobWF0Y2hlZCkgOiBtYXRjaGVkKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcclxuICAgICAgICBpbmRleDogZnVuY3Rpb24gKGVsZW0pIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XHJcbiAgICAgICAgICAgIGlmICghZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZSkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbmRleCBpbiBzZWxlY3RvclxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwoalF1ZXJ5KGVsZW0pLCB0aGlzWzBdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwodGhpcyxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcclxuICAgICAgICAgICAgICAgIGVsZW0uanF1ZXJ5ID8gZWxlbVswXSA6IGVsZW1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soXHJcbiAgICAgICAgICAgICAgICBqUXVlcnkudW5pcXVlU29ydChcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2UodGhpcy5nZXQoKSwgalF1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0KSlcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhZGRCYWNrOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHNlbGVjdG9yID09IG51bGwgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihzZWxlY3RvcilcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBzaWJsaW5nKGN1ciwgZGlyKSB7XHJcbiAgICAgICAgd2hpbGUgKChjdXIgPSBjdXJbZGlyXSkgJiYgY3VyLm5vZGVUeXBlICE9PSAxKSB7IH1cclxuICAgICAgICByZXR1cm4gY3VyO1xyXG4gICAgfVxyXG5cclxuICAgIGpRdWVyeS5lYWNoKHtcclxuICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXJlbnRzOiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwicGFyZW50Tm9kZVwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmVudHNVbnRpbDogZnVuY3Rpb24gKGVsZW0sIGksIHVudGlsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nKGVsZW0sIFwibmV4dFNpYmxpbmdcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcmV2OiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2libGluZyhlbGVtLCBcInByZXZpb3VzU2libGluZ1wiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHRBbGw6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJuZXh0U2libGluZ1wiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByZXZBbGw6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0VW50aWw6IGZ1bmN0aW9uIChlbGVtLCBpLCB1bnRpbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJldlVudGlsOiBmdW5jdGlvbiAoZWxlbSwgaSwgdW50aWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpcihlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaWJsaW5nczogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdzKChlbGVtLnBhcmVudE5vZGUgfHwge30pLmZpcnN0Q2hpbGQsIGVsZW0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5ncyhlbGVtLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udGVudHM6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlTmFtZShlbGVtLCBcImlmcmFtZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcclxuICAgICAgICAgICAgLy8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XHJcbiAgICAgICAgICAgIC8vIGRvbid0IHN1cHBvcnQgaXQuXHJcbiAgICAgICAgICAgIGlmIChub2RlTmFtZShlbGVtLCBcInRlbXBsYXRlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoW10sIGVsZW0uY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHVudGlsLCBzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAodGhpcywgZm4sIHVudGlsKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuYW1lLnNsaWNlKC01KSAhPT0gXCJVbnRpbFwiKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVudGlsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0galF1ZXJ5LmZpbHRlcihzZWxlY3RvciwgbWF0Y2hlZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZHVwbGljYXRlc1xyXG4gICAgICAgICAgICAgICAgaWYgKCFndWFyYW50ZWVkVW5pcXVlW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnVuaXF1ZVNvcnQobWF0Y2hlZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcclxuICAgICAgICAgICAgICAgIGlmIChycGFyZW50c3ByZXYudGVzdChuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sobWF0Y2hlZCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgdmFyIHJub3RodG1sd2hpdGUgPSAoL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nKTtcclxuXHJcblxyXG5cclxuICAgIC8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgb2JqZWN0ID0ge307XHJcbiAgICAgICAgalF1ZXJ5LmVhY2gob3B0aW9ucy5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXSwgZnVuY3Rpb24gKF8sIGZsYWcpIHtcclxuICAgICAgICAgICAgb2JqZWN0W2ZsYWddID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcclxuICAgICAqXHJcbiAgICAgKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xyXG4gICAgICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XHJcbiAgICAgKlxyXG4gICAgICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcclxuICAgICAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cclxuICAgICAqXHJcbiAgICAgKiBQb3NzaWJsZSBvcHRpb25zOlxyXG4gICAgICpcclxuICAgICAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcclxuICAgICAqXHJcbiAgICAgKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcclxuICAgICAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcclxuICAgICAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxyXG4gICAgICpcclxuICAgICAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXHJcbiAgICAgKlxyXG4gICAgICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBqUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxyXG4gICAgICAgIC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcclxuICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xyXG4gICAgICAgICAgICBjcmVhdGVPcHRpb25zKG9wdGlvbnMpIDpcclxuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh7fSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXHJcbiAgICAgICAgICAgIGZpcmluZyxcclxuXHJcbiAgICAgICAgICAgIC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXHJcbiAgICAgICAgICAgIG1lbW9yeSxcclxuXHJcbiAgICAgICAgICAgIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXHJcbiAgICAgICAgICAgIGZpcmVkLFxyXG5cclxuICAgICAgICAgICAgLy8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xyXG4gICAgICAgICAgICBsb2NrZWQsXHJcblxyXG4gICAgICAgICAgICAvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxyXG4gICAgICAgICAgICBsaXN0ID0gW10sXHJcblxyXG4gICAgICAgICAgICAvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xyXG4gICAgICAgICAgICBxdWV1ZSA9IFtdLFxyXG5cclxuICAgICAgICAgICAgLy8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXHJcbiAgICAgICAgICAgIGZpcmluZ0luZGV4ID0gLTEsXHJcblxyXG4gICAgICAgICAgICAvLyBGaXJlIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICBmaXJlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xyXG4gICAgICAgICAgICAgICAgbG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcclxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcclxuICAgICAgICAgICAgICAgIGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgrK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0W2ZpcmluZ0luZGV4XS5hcHBseShtZW1vcnlbMF0sIG1lbW9yeVsxXSkgPT09IGZhbHNlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0b3BPbkZhbHNlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9yeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcclxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5tZW1vcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZW1vcnkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmaXJpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxyXG4gICAgICAgICAgICAgICAgaWYgKGxvY2tlZCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbW9yeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3RcclxuICAgICAgICAgICAgc2VsZiA9IHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbW9yeSAmJiAhZmlyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gobWVtb3J5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uIGFkZChhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaChhcmdzLCBmdW5jdGlvbiAoXywgYXJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyhhcmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goYXJnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKGFyZykgIT09IFwic3RyaW5nXCIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtb3J5ICYmICFmaXJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbiAoXywgYXJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChpbmRleCA9IGpRdWVyeS5pbkFycmF5KGFyZywgbGlzdCwgaW5kZXgpKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGZpcmluZyBpbmRleGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPD0gZmlyaW5nSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJpbmdJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cclxuICAgICAgICAgICAgICAgIGhhczogZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmluQXJyYXkoZm4sIGxpc3QpID4gLTEgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0Lmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgIGVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxyXG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2NrZWQgPSBxdWV1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFsaXN0O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIC5maXJlXHJcbiAgICAgICAgICAgICAgICAvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxyXG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xyXG4gICAgICAgICAgICAgICAgbG9jazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2tlZCA9IHF1ZXVlID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZW1vcnkgJiYgIWZpcmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gbWVtb3J5ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbG9ja2VkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhbG9ja2VkO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICBmaXJlV2l0aDogZnVuY3Rpb24gKGNvbnRleHQsIGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJncyB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJnc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICBmaXJlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maXJlV2l0aCh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2VcclxuICAgICAgICAgICAgICAgIGZpcmVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZmlyZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gSWRlbnRpdHkodikge1xyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gVGhyb3dlcihleCkge1xyXG4gICAgICAgIHRocm93IGV4O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkb3B0VmFsdWUodmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSkge1xyXG4gICAgICAgIHZhciBtZXRob2Q7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBpc0Z1bmN0aW9uKChtZXRob2QgPSB2YWx1ZS5wcm9taXNlKSkpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZC5jYWxsKHZhbHVlKS5kb25lKHJlc29sdmUpLmZhaWwocmVqZWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlciB0aGVuYWJsZXNcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiBpc0Z1bmN0aW9uKChtZXRob2QgPSB2YWx1ZS50aGVuKSkpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZC5jYWxsKHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE90aGVyIG5vbi10aGVuYWJsZXNcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XHJcbiAgICAgICAgICAgICAgICAvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXHJcbiAgICAgICAgICAgICAgICAvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZS5hcHBseSh1bmRlZmluZWQsIFt2YWx1ZV0uc2xpY2Uobm9WYWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcclxuICAgICAgICAgICAgLy8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxyXG4gICAgICAgICAgICAvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxyXG4gICAgICAgIH0gY2F0Y2ggKHZhbHVlKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XHJcbiAgICAgICAgICAgIC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcclxuICAgICAgICAgICAgcmVqZWN0LmFwcGx5KHVuZGVmaW5lZCwgW3ZhbHVlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGpRdWVyeS5leHRlbmQoe1xyXG5cclxuICAgICAgICBEZWZlcnJlZDogZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICAgICAgdmFyIHR1cGxlcyA9IFtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxyXG4gICAgICAgICAgICAgICAgLy8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxyXG4gICAgICAgICAgICAgICAgW1wibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm1lbW9yeVwiKSxcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLCAyXSxcclxuICAgICAgICAgICAgICAgIFtcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIDAsIFwicmVzb2x2ZWRcIl0sXHJcbiAgICAgICAgICAgICAgICBbXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIDEsIFwicmVqZWN0ZWRcIl1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gXCJwZW5kaW5nXCIsXHJcbiAgICAgICAgICAgICAgICBwcm9taXNlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGFsd2F5czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4obnVsbCwgZm4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcclxuICAgICAgICAgICAgICAgICAgICBwaXBlOiBmdW5jdGlvbiAoIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbnMgPSBhcmd1bWVudHM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LkRlZmVycmVkKGZ1bmN0aW9uIChuZXdEZWZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2godHVwbGVzLCBmdW5jdGlvbiAoaSwgdHVwbGUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gaXNGdW5jdGlvbihmbnNbdHVwbGVbNF1dKSAmJiBmbnNbdHVwbGVbNF1dO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkW3R1cGxlWzFdXShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKHJldHVybmVkLnByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZC5wcm9taXNlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvZ3Jlc3MobmV3RGVmZXIubm90aWZ5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kb25lKG5ld0RlZmVyLnJlc29sdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZhaWwobmV3RGVmZXIucmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyW3R1cGxlWzBdICsgXCJXaXRoXCJdKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPyBbcmV0dXJuZWRdIDogYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZucyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnByb21pc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4RGVwdGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlKGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZ2h0VGhyb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuZWQsIHRoZW47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA8IG1heERlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkID0gaGFuZGxlci5hcHBseSh0aGF0LCBhcmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuID0gcmV0dXJuZWQgJiZcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZC50aGVuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGVuKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbi5jYWxsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhEZXB0aCsrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbi5jYWxsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSBJZGVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gW3JldHVybmVkXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCkodGhhdCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyA9IHNwZWNpYWwgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlnaHRUaHJvdyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlnaHRUaHJvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLnN0YWNrVHJhY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggKyAxID49IG1heERlcHRoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gVGhyb3dlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKHRoYXQsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWJzZXF1ZW50IGVycm9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChwcm9jZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LkRlZmVycmVkKGZ1bmN0aW9uIChuZXdEZWZlcikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1swXVszXS5hZGQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24ob25Qcm9ncmVzcykgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZGVudGl0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXIubm90aWZ5V2l0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1sxXVszXS5hZGQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24ob25GdWxmaWxsZWQpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRnVsZmlsbGVkIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElkZW50aXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dXBsZXNbMl1bM10uYWRkKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKG9uUmVqZWN0ZWQpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVqZWN0ZWQgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhyb3dlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnByb21pc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2U6IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZChvYmosIHByb21pc2UpIDogcHJvbWlzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcclxuICAgICAgICAgICAgalF1ZXJ5LmVhY2godHVwbGVzLCBmdW5jdGlvbiAoaSwgdHVwbGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gdHVwbGVbMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTdHJpbmcgPSB0dXBsZVs1XTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcclxuICAgICAgICAgICAgICAgIC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxyXG4gICAgICAgICAgICAgICAgcHJvbWlzZVt0dXBsZVsxXV0gPSBsaXN0LmFkZDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgc3RhdGVcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZVN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QuYWRkKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1szIC0gaV1bMl0uZGlzYWJsZSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHVwbGVzWzMgLSBpXVszXS5kaXNhYmxlLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHVwbGVzWzBdWzJdLmxvY2ssXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1swXVszXS5sb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXHJcbiAgICAgICAgICAgICAgICAvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxyXG4gICAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxyXG4gICAgICAgICAgICAgICAgbGlzdC5hZGQodHVwbGVbM10uZmlyZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XHJcbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxyXG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZFt0dXBsZVswXV0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRbdHVwbGVbMF0gKyBcIldpdGhcIl0odGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxyXG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXHJcbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWRbdHVwbGVbMF0gKyBcIldpdGhcIl0gPSBsaXN0LmZpcmVXaXRoO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxyXG4gICAgICAgICAgICBwcm9taXNlLnByb21pc2UoZGVmZXJyZWQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxyXG4gICAgICAgICAgICBpZiAoZnVuYykge1xyXG4gICAgICAgICAgICAgICAgZnVuYy5jYWxsKGRlZmVycmVkLCBkZWZlcnJlZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFsbCBkb25lIVxyXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gRGVmZXJyZWQgaGVscGVyXHJcbiAgICAgICAgd2hlbjogZnVuY3Rpb24gKHNpbmdsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhclxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xyXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcclxuICAgICAgICAgICAgICAgIGkgPSByZW1haW5pbmcsXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoaSksXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcclxuICAgICAgICAgICAgICAgIG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3RvcnlcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNvbnRleHRzW2ldID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVZhbHVlc1tpXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbChhcmd1bWVudHMpIDogdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKC0tcmVtYWluaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFzdGVyLnJlc29sdmVXaXRoKHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxyXG4gICAgICAgICAgICBpZiAocmVtYWluaW5nIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIGFkb3B0VmFsdWUoc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKHVwZGF0ZUZ1bmMoaSkpLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgIXJlbWFpbmluZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24ocmVzb2x2ZVZhbHVlc1tpXSAmJiByZXNvbHZlVmFsdWVzW2ldLnRoZW4pKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXN0ZXIudGhlbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xyXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBhZG9wdFZhbHVlKHJlc29sdmVWYWx1ZXNbaV0sIHVwZGF0ZUZ1bmMoaSksIG1hc3Rlci5yZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXHJcbiAgICAvLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cclxuICAgIHZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xyXG5cclxuICAgIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24gKGVycm9yLCBzdGFjaykge1xyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XHJcbiAgICAgICAgLy8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcclxuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KGVycm9yLm5hbWUpKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgICBqUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgICAvLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcclxuICAgIHZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcclxuXHJcbiAgICBqUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiAoZm4pIHtcclxuXHJcbiAgICAgICAgcmVhZHlMaXN0XHJcbiAgICAgICAgICAgIC50aGVuKGZuKVxyXG5cclxuICAgICAgICAgICAgLy8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcclxuICAgICAgICAgICAgLy8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXHJcbiAgICAgICAgICAgIC8vIHJlZ2lzdHJhdGlvbi5cclxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uKGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgLy8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cclxuICAgICAgICBpc1JlYWR5OiBmYWxzZSxcclxuXHJcbiAgICAgICAgLy8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxyXG4gICAgICAgIC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXHJcbiAgICAgICAgcmVhZHlXYWl0OiAxLFxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XHJcbiAgICAgICAgcmVhZHk6IGZ1bmN0aW9uICh3YWl0KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XHJcbiAgICAgICAgICAgIGlmICh3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XHJcbiAgICAgICAgICAgIGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXHJcbiAgICAgICAgICAgIGlmICh3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxyXG4gICAgICAgICAgICByZWFkeUxpc3QucmVzb2x2ZVdpdGgoZG9jdW1lbnQsIFtqUXVlcnldKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xyXG5cclxuICAgIC8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXHJcbiAgICBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgY29tcGxldGVkKTtcclxuICAgICAgICBqUXVlcnkucmVhZHkoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxyXG4gICAgLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXHJcbiAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XHJcbiAgICAvLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cclxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcclxuICAgICAgICAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCkpIHtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XHJcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoalF1ZXJ5LnJlYWR5KTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkKTtcclxuXHJcbiAgICAgICAgLy8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgY29tcGxldGVkKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICAvLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cclxuICAgIC8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxyXG4gICAgdmFyIGFjY2VzcyA9IGZ1bmN0aW9uIChlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdykge1xyXG4gICAgICAgIHZhciBpID0gMCxcclxuICAgICAgICAgICAgbGVuID0gZWxlbXMubGVuZ3RoLFxyXG4gICAgICAgICAgICBidWxrID0ga2V5ID09IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFNldHMgbWFueSB2YWx1ZXNcclxuICAgICAgICBpZiAodG9UeXBlKGtleSkgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgY2hhaW5hYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgZm9yIChpIGluIGtleSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzKGVsZW1zLCBmbiwgaSwga2V5W2ldLCB0cnVlLCBlbXB0eUdldCwgcmF3KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2V0cyBvbmUgdmFsdWVcclxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY2hhaW5hYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJhdyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChidWxrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XHJcbiAgICAgICAgICAgICAgICBpZiAocmF3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4uY2FsbChlbGVtcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZuID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBidWxrID0gZm47XHJcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBmdW5jdGlvbiAoZWxlbSwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVsay5jYWxsKGpRdWVyeShlbGVtKSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChmbikge1xyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZuKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtc1tpXSwga2V5LCByYXcgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuY2FsbChlbGVtc1tpXSwgaSwgZm4oZWxlbXNbaV0sIGtleSkpXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNoYWluYWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBHZXRzXHJcbiAgICAgICAgaWYgKGJ1bGspIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlbXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGxlbiA/IGZuKGVsZW1zWzBdLCBrZXkpIDogZW1wdHlHZXQ7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcclxuICAgIHZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxyXG4gICAgICAgIHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcclxuXHJcbiAgICAvLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcclxuICAgIGZ1bmN0aW9uIGZjYW1lbENhc2UoYWxsLCBsZXR0ZXIpIHtcclxuICAgICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xyXG4gICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxyXG4gICAgLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxyXG4gICAgZnVuY3Rpb24gY2FtZWxDYXNlKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShybXNQcmVmaXgsIFwibXMtXCIpLnJlcGxhY2UocmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uIChvd25lcikge1xyXG5cclxuICAgICAgICAvLyBBY2NlcHRzIG9ubHk6XHJcbiAgICAgICAgLy8gIC0gTm9kZVxyXG4gICAgICAgIC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcclxuICAgICAgICAvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxyXG4gICAgICAgIC8vICAtIE9iamVjdFxyXG4gICAgICAgIC8vICAgIC0gQW55XHJcbiAgICAgICAgcmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoK293bmVyLm5vZGVUeXBlKTtcclxuICAgIH07XHJcblxyXG5cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gRGF0YSgpIHtcclxuICAgICAgICB0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XHJcbiAgICB9XHJcblxyXG4gICAgRGF0YS51aWQgPSAxO1xyXG5cclxuICAgIERhdGEucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICBjYWNoZTogZnVuY3Rpb24gKG93bmVyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gb3duZXJbdGhpcy5leHBhbmRvXTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIG5vdCwgY3JlYXRlIG9uZVxyXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cclxuICAgICAgICAgICAgICAgIC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgaWYgKGFjY2VwdERhdGEob3duZXIpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvd25lci5ub2RlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvd25lclt0aGlzLmV4cGFuZG9dID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvd25lciwgdGhpcy5leHBhbmRvLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvd25lciwgZGF0YSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHByb3AsXHJcbiAgICAgICAgICAgICAgICBjYWNoZSA9IHRoaXMuY2FjaGUob3duZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xyXG4gICAgICAgICAgICAvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVbY2FtZWxDYXNlKGRhdGEpXSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3RcclxuICAgICAgICAgICAgICAgIGZvciAocHJvcCBpbiBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVbY2FtZWxDYXNlKHByb3ApXSA9IGRhdGFbcHJvcF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAob3duZXIsIGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZShvd25lcikgOlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1NylcclxuICAgICAgICAgICAgICAgIG93bmVyW3RoaXMuZXhwYW5kb10gJiYgb3duZXJbdGhpcy5leHBhbmRvXVtjYW1lbENhc2Uoa2V5KV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhY2Nlc3M6IGZ1bmN0aW9uIChvd25lciwga2V5LCB2YWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgLy8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcclxuICAgICAgICAgICAgLy8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XHJcbiAgICAgICAgICAgIC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgICAgICAoKGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChvd25lciwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcclxuICAgICAgICAgICAgLy8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgLy8gICAyLiBBIGtleSBhbmQgdmFsdWVcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgdGhpcy5zZXQob3duZXIsIGtleSwgdmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXHJcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAob3duZXIsIGtleSkge1xyXG4gICAgICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgICAgIGNhY2hlID0gb3duZXJbdGhpcy5leHBhbmRvXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjYWNoZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5Lm1hcChjYW1lbENhc2UpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBjYW1lbENhc2Uoa2V5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5IGluIGNhY2hlID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgW2tleV0gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoa2V5Lm1hdGNoKHJub3RodG1sd2hpdGUpIHx8IFtdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpID0ga2V5Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2tleVtpXV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoY2FjaGUpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxyXG4gICAgICAgICAgICAgICAgLy8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgIC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXHJcbiAgICAgICAgICAgICAgICBpZiAob3duZXIubm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvd25lclt0aGlzLmV4cGFuZG9dID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3duZXJbdGhpcy5leHBhbmRvXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzRGF0YTogZnVuY3Rpb24gKG93bmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IG93bmVyW3RoaXMuZXhwYW5kb107XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdChjYWNoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XHJcblxyXG4gICAgdmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcclxuXHJcblxyXG5cclxuICAgIC8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XHJcbiAgICAvL1xyXG4gICAgLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcclxuICAgIC8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2VcclxuICAgIC8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cclxuICAgIC8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxyXG4gICAgLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcclxuICAgIC8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcclxuICAgIC8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcclxuXHJcbiAgICB2YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxyXG4gICAgICAgIHJtdWx0aURhc2ggPSAvW0EtWl0vZztcclxuXHJcbiAgICBmdW5jdGlvbiBnZXREYXRhKGRhdGEpIHtcclxuICAgICAgICBpZiAoZGF0YSA9PT0gXCJ0cnVlXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGF0YSA9PT0gXCJmYWxzZVwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkYXRhID09PSBcIm51bGxcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXHJcbiAgICAgICAgaWYgKGRhdGEgPT09ICtkYXRhICsgXCJcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gK2RhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmJyYWNlLnRlc3QoZGF0YSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkYXRhQXR0cihlbGVtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICB2YXIgbmFtZTtcclxuXHJcbiAgICAgICAgLy8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxyXG4gICAgICAgIC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxyXG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgICAgICAgICBuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2Uocm11bHRpRGFzaCwgXCItJCZcIikudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBnZXREYXRhKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXHJcbiAgICAgICAgICAgICAgICBkYXRhVXNlci5zZXQoZWxlbSwga2V5LCBkYXRhKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgalF1ZXJ5LmV4dGVuZCh7XHJcbiAgICAgICAgaGFzRGF0YTogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoZWxlbSkgfHwgZGF0YVByaXYuaGFzRGF0YShlbGVtKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkYXRhOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YVVzZXIuYWNjZXNzKGVsZW0sIG5hbWUsIGRhdGEpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uIChlbGVtLCBuYW1lKSB7XHJcbiAgICAgICAgICAgIGRhdGFVc2VyLnJlbW92ZShlbGVtLCBuYW1lKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxyXG4gICAgICAgIC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxyXG4gICAgICAgIF9kYXRhOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YVByaXYuYWNjZXNzKGVsZW0sIG5hbWUsIGRhdGEpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9yZW1vdmVEYXRhOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSkge1xyXG4gICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZWxlbSwgbmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICAgICAgZGF0YTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGksIG5hbWUsIGRhdGEsXHJcbiAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1swXSxcclxuICAgICAgICAgICAgICAgIGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXRzIGFsbCB2YWx1ZXNcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVVzZXIuZ2V0KGVsZW0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBhdHRycy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoXCJkYXRhLVwiKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gY2FtZWxDYXNlKG5hbWUuc2xpY2UoNSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQXR0cihlbGVtLCBuYW1lLCBkYXRhW25hbWVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuc2V0KGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVc2VyLnNldCh0aGlzLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxyXG4gICAgICAgICAgICAgICAgLy8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXHJcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVVzZXIuZ2V0KGVsZW0sIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhQXR0cihlbGVtLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgZGF0YS4uLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVc2VyLnNldCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhVXNlci5yZW1vdmUodGhpcywga2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIGpRdWVyeS5leHRlbmQoe1xyXG4gICAgICAgIHF1ZXVlOiBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgcXVldWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9ICh0eXBlIHx8IFwiZnhcIikgKyBcInF1ZXVlXCI7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IGRhdGFQcml2LmdldChlbGVtLCB0eXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcXVldWUgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyhlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KGRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBxdWV1ZSB8fCBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRlcXVldWU6IGZ1bmN0aW9uIChlbGVtLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcclxuXHJcbiAgICAgICAgICAgIHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZShlbGVtLCB0eXBlKSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpLFxyXG4gICAgICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoZWxlbSwgdHlwZSksXHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKGVsZW0sIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcclxuICAgICAgICAgICAgaWYgKGZuID09PSBcImlucHJvZ3Jlc3NcIikge1xyXG4gICAgICAgICAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRMZW5ndGgtLTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGZuKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xyXG4gICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZnhcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBob29rcy5zdG9wO1xyXG4gICAgICAgICAgICAgICAgZm4uY2FsbChlbGVtLCBuZXh0LCBob29rcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghc3RhcnRMZW5ndGggJiYgaG9va3MpIHtcclxuICAgICAgICAgICAgICAgIGhvb2tzLmVtcHR5LmZpcmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXHJcbiAgICAgICAgX3F1ZXVlSG9va3M6IGZ1bmN0aW9uIChlbGVtLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhUHJpdi5nZXQoZWxlbSwga2V5KSB8fCBkYXRhUHJpdi5hY2Nlc3MoZWxlbSwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICBlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYucmVtb3ZlKGVsZW0sIFt0eXBlICsgXCJxdWV1ZVwiLCBrZXldKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgICAgIHF1ZXVlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgc2V0dGVyID0gMjtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJmeFwiO1xyXG4gICAgICAgICAgICAgICAgc2V0dGVyLS07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnF1ZXVlKHRoaXNbMF0sIHR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgIHRoaXMgOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcXVldWUgPSBqUXVlcnkucXVldWUodGhpcywgdHlwZSwgZGF0YSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9xdWV1ZUhvb2tzKHRoaXMsIHR5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCB0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlcXVldWU6IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUodGhpcywgdHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUodHlwZSB8fCBcImZ4XCIsIFtdKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXHJcbiAgICAgICAgLy8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXHJcbiAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24gKHR5cGUsIG9iaikge1xyXG4gICAgICAgICAgICB2YXIgdG1wLFxyXG4gICAgICAgICAgICAgICAgY291bnQgPSAxLFxyXG4gICAgICAgICAgICAgICAgZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGkgPSB0aGlzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHJlc29sdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoLS1jb3VudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZVdpdGgoZWxlbWVudHMsIFtlbGVtZW50c10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIG9iaiA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICAgIHRtcCA9IGRhdGFQcml2LmdldChlbGVtZW50c1tpXSwgdHlwZSArIFwicXVldWVIb29rc1wiKTtcclxuICAgICAgICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmVtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB0bXAuZW1wdHkuYWRkKHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2Uob2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZhciBwbnVtID0gKC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvKS5zb3VyY2U7XHJcblxyXG4gICAgdmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiKTtcclxuXHJcblxyXG4gICAgdmFyIGNzc0V4cGFuZCA9IFtcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiXTtcclxuXHJcbiAgICB2YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24gKGVsZW0sIGVsKSB7XHJcblxyXG4gICAgICAgIC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xyXG4gICAgICAgIC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxyXG4gICAgICAgIGVsZW0gPSBlbCB8fCBlbGVtO1xyXG5cclxuICAgICAgICAvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxyXG4gICAgICAgIHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XHJcbiAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxyXG4gICAgICAgICAgICAvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcclxuICAgICAgICAgICAgLy8gaW4gdGhlIGRvY3VtZW50LlxyXG4gICAgICAgICAgICBqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKSAmJlxyXG5cclxuICAgICAgICAgICAgalF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIikgPT09IFwibm9uZVwiO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc3dhcCA9IGZ1bmN0aW9uIChlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncykge1xyXG4gICAgICAgIHZhciByZXQsIG5hbWUsXHJcbiAgICAgICAgICAgIG9sZCA9IHt9O1xyXG5cclxuICAgICAgICAvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcclxuICAgICAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBvbGRbbmFtZV0gPSBlbGVtLnN0eWxlW25hbWVdO1xyXG4gICAgICAgICAgICBlbGVtLnN0eWxlW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldCA9IGNhbGxiYWNrLmFwcGx5KGVsZW0sIGFyZ3MgfHwgW10pO1xyXG5cclxuICAgICAgICAvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcclxuICAgICAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBlbGVtLnN0eWxlW25hbWVdID0gb2xkW25hbWVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH07XHJcblxyXG5cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gYWRqdXN0Q1NTKGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuKSB7XHJcbiAgICAgICAgdmFyIGFkanVzdGVkLCBzY2FsZSxcclxuICAgICAgICAgICAgbWF4SXRlcmF0aW9ucyA9IDIwLFxyXG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSB0d2VlbiA/XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVuLmN1cigpO1xyXG4gICAgICAgICAgICAgICAgfSA6XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5jc3MoZWxlbSwgcHJvcCwgXCJcIik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbml0aWFsID0gY3VycmVudFZhbHVlKCksXHJcbiAgICAgICAgICAgIHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbM10gfHwgKGpRdWVyeS5jc3NOdW1iZXJbcHJvcF0gPyBcIlwiIDogXCJweFwiKSxcclxuXHJcbiAgICAgICAgICAgIC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXHJcbiAgICAgICAgICAgIGluaXRpYWxJblVuaXQgPSAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwpICYmXHJcbiAgICAgICAgICAgICAgICByY3NzTnVtLmV4ZWMoalF1ZXJ5LmNzcyhlbGVtLCBwcm9wKSk7XHJcblxyXG4gICAgICAgIGlmIChpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbM10gIT09IHVuaXQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxyXG4gICAgICAgICAgICAvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXHJcbiAgICAgICAgICAgIGluaXRpYWwgPSBpbml0aWFsIC8gMjtcclxuXHJcbiAgICAgICAgICAgIC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3NcclxuICAgICAgICAgICAgdW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFszXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XHJcbiAgICAgICAgICAgIGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKG1heEl0ZXJhdGlvbnMtLSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXHJcbiAgICAgICAgICAgICAgICAvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCgxIC0gc2NhbGUpICogKDEgLSAoc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41KSkgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heEl0ZXJhdGlvbnMgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcclxuICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cclxuICAgICAgICAgICAgdmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodmFsdWVQYXJ0cykge1xyXG4gICAgICAgICAgICBpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxyXG4gICAgICAgICAgICBhZGp1c3RlZCA9IHZhbHVlUGFydHNbMV0gP1xyXG4gICAgICAgICAgICAgICAgaW5pdGlhbEluVW5pdCArICh2YWx1ZVBhcnRzWzFdICsgMSkgKiB2YWx1ZVBhcnRzWzJdIDpcclxuICAgICAgICAgICAgICAgICt2YWx1ZVBhcnRzWzJdO1xyXG4gICAgICAgICAgICBpZiAodHdlZW4pIHtcclxuICAgICAgICAgICAgICAgIHR3ZWVuLnVuaXQgPSB1bml0O1xyXG4gICAgICAgICAgICAgICAgdHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xyXG4gICAgICAgICAgICAgICAgdHdlZW4uZW5kID0gYWRqdXN0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFkanVzdGVkO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICB2YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheShlbGVtKSB7XHJcbiAgICAgICAgdmFyIHRlbXAsXHJcbiAgICAgICAgICAgIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcclxuICAgICAgICAgICAgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxyXG4gICAgICAgICAgICBkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbbm9kZU5hbWVdO1xyXG5cclxuICAgICAgICBpZiAoZGlzcGxheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzcGxheTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlRWxlbWVudChub2RlTmFtZSkpO1xyXG4gICAgICAgIGRpc3BsYXkgPSBqUXVlcnkuY3NzKHRlbXAsIFwiZGlzcGxheVwiKTtcclxuXHJcbiAgICAgICAgdGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXApO1xyXG5cclxuICAgICAgICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIpIHtcclxuICAgICAgICAgICAgZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVmYXVsdERpc3BsYXlNYXBbbm9kZU5hbWVdID0gZGlzcGxheTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRpc3BsYXk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2hvd0hpZGUoZWxlbWVudHMsIHNob3cpIHtcclxuICAgICAgICB2YXIgZGlzcGxheSwgZWxlbSxcclxuICAgICAgICAgICAgdmFsdWVzID0gW10sXHJcbiAgICAgICAgICAgIGluZGV4ID0gMCxcclxuICAgICAgICAgICAgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2VcclxuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgZWxlbSA9IGVsZW1lbnRzW2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKCFlbGVtLnN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcclxuICAgICAgICAgICAgaWYgKHNob3cpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcclxuICAgICAgICAgICAgICAgIC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcclxuICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5ID09PSBcIm5vbmVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBkYXRhUHJpdi5nZXQoZWxlbSwgXCJkaXNwbGF5XCIpIHx8IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZXNbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoZWxlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gZ2V0RGVmYXVsdERpc3BsYXkoZWxlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGxheSAhPT0gXCJub25lXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gXCJub25lXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcclxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5zZXQoZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XHJcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbaW5kZXhdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzW2luZGV4XS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzW2luZGV4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNob3dIaWRlKHRoaXMsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2hvd0hpZGUodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNIaWRkZW5XaXRoaW5UcmVlKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnNob3coKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgcmNoZWNrYWJsZVR5cGUgPSAoL14oPzpjaGVja2JveHxyYWRpbykkL2kpO1xyXG5cclxuICAgIHZhciBydGFnTmFtZSA9ICgvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kpO1xyXG5cclxuICAgIHZhciByc2NyaXB0VHlwZSA9ICgvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pKTtcclxuXHJcblxyXG5cclxuICAgIC8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXHJcbiAgICB2YXIgd3JhcE1hcCA9IHtcclxuXHJcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcclxuICAgICAgICBvcHRpb246IFsxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIl0sXHJcblxyXG4gICAgICAgIC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXHJcbiAgICAgICAgLy8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxyXG4gICAgICAgIC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cclxuICAgICAgICB0aGVhZDogWzEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCJdLFxyXG4gICAgICAgIGNvbDogWzIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCJdLFxyXG4gICAgICAgIHRyOiBbMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIl0sXHJcbiAgICAgICAgdGQ6IFszLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiXSxcclxuXHJcbiAgICAgICAgX2RlZmF1bHQ6IFswLCBcIlwiLCBcIlwiXVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxyXG4gICAgd3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xyXG5cclxuICAgIHdyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XHJcbiAgICB3cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0QWxsKGNvbnRleHQsIHRhZykge1xyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XHJcbiAgICAgICAgLy8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxyXG4gICAgICAgIHZhciByZXQ7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICByZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyB8fCBcIipcIik7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICByZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwodGFnIHx8IFwiKlwiKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0ID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKGNvbnRleHQsIHRhZykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZShbY29udGV4dF0sIHJldCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcclxuICAgIGZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoZWxlbXMsIHJlZkVsZW1lbnRzKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICBsID0gZWxlbXMubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBkYXRhUHJpdi5zZXQoXHJcbiAgICAgICAgICAgICAgICBlbGVtc1tpXSxcclxuICAgICAgICAgICAgICAgIFwiZ2xvYmFsRXZhbFwiLFxyXG4gICAgICAgICAgICAgICAgIXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldChyZWZFbGVtZW50c1tpXSwgXCJnbG9iYWxFdmFsXCIpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICB2YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XHJcblxyXG4gICAgZnVuY3Rpb24gYnVpbGRGcmFnbWVudChlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkKSB7XHJcbiAgICAgICAgdmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcclxuICAgICAgICAgICAgZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcclxuICAgICAgICAgICAgbm9kZXMgPSBbXSxcclxuICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgIGwgPSBlbGVtcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlbGVtIHx8IGVsZW0gPT09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgbm9kZXMgZGlyZWN0bHlcclxuICAgICAgICAgICAgICAgIGlmICh0b1R5cGUoZWxlbSkgPT09IFwib2JqZWN0XCIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZShub2RlcywgZWxlbS5ub2RlVHlwZSA/IFtlbGVtXSA6IGVsZW0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJodG1sLnRlc3QoZWxlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoZWxlbSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cclxuICAgICAgICAgICAgICAgICAgICB0YWcgPSAocnRhZ05hbWUuZXhlYyhlbGVtKSB8fCBbXCJcIiwgXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcCA9IHdyYXBNYXBbdGFnXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcC5pbm5lckhUTUwgPSB3cmFwWzFdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoZWxlbSkgKyB3cmFwWzJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICBqID0gd3JhcFswXTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoai0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcclxuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKG5vZGVzLCB0bXAuY2hpbGROb2Rlcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxyXG4gICAgICAgICAgICAgICAgICAgIHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcclxuICAgICAgICBmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XHJcblxyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlICgoZWxlbSA9IG5vZGVzW2krK10pKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxyXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KGVsZW0sIHNlbGVjdGlvbikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZ25vcmVkLnB1c2goZWxlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0byBmcmFnbWVudFxyXG4gICAgICAgICAgICB0bXAgPSBnZXRBbGwoZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWxlbSksIFwic2NyaXB0XCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxyXG4gICAgICAgICAgICBpZiAoY29udGFpbnMpIHtcclxuICAgICAgICAgICAgICAgIHNldEdsb2JhbEV2YWwodG1wKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2FwdHVyZSBleGVjdXRhYmxlc1xyXG4gICAgICAgICAgICBpZiAoc2NyaXB0cykge1xyXG4gICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSB0bXBbaisrXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocnNjcmlwdFR5cGUudGVzdChlbGVtLnR5cGUgfHwgXCJcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0cy5wdXNoKGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcclxuICAgICAgICAgICAgZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSksXHJcbiAgICAgICAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XHJcbiAgICAgICAgLy8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcclxuICAgICAgICAvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXHJcbiAgICAgICAgLy8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXHJcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInJhZGlvXCIpO1xyXG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIpO1xyXG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJ0XCIpO1xyXG5cclxuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcclxuICAgICAgICAvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcclxuICAgICAgICBzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKHRydWUpLmNsb25lTm9kZSh0cnVlKS5sYXN0Q2hpbGQuY2hlY2tlZDtcclxuXHJcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcclxuICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XHJcbiAgICAgICAgc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSh0cnVlKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xyXG4gICAgfSkoKTtcclxuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG5cclxuXHJcbiAgICB2YXJcclxuICAgICAgICBya2V5RXZlbnQgPSAvXmtleS8sXHJcbiAgICAgICAgcm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXHJcbiAgICAgICAgcnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XHJcbiAgICAvLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cclxuICAgIGZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikgeyB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb24oZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lKSB7XHJcbiAgICAgICAgdmFyIG9yaWdGbiwgdHlwZTtcclxuXHJcbiAgICAgICAgLy8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIikge1xyXG5cclxuICAgICAgICAgICAgLy8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh0eXBlIGluIHR5cGVzKSB7XHJcbiAgICAgICAgICAgICAgICBvbihlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbdHlwZV0sIG9uZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGVsZW07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwpIHtcclxuXHJcbiAgICAgICAgICAgIC8vICggdHlwZXMsIGZuIClcclxuICAgICAgICAgICAgZm4gPSBzZWxlY3RvcjtcclxuICAgICAgICAgICAgZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZm4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcclxuICAgICAgICAgICAgICAgIGZuID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gKCB0eXBlcywgZGF0YSwgZm4gKVxyXG4gICAgICAgICAgICAgICAgZm4gPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZuID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBmbiA9IHJldHVybkZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWZuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9uZSA9PT0gMSkge1xyXG4gICAgICAgICAgICBvcmlnRm4gPSBmbjtcclxuICAgICAgICAgICAgZm4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cclxuICAgICAgICAgICAgICAgIGpRdWVyeSgpLm9mZihldmVudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ0ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxyXG4gICAgICAgICAgICBmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbGVtLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXHJcbiAgICAgKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxyXG4gICAgICovXHJcbiAgICBqUXVlcnkuZXZlbnQgPSB7XHJcblxyXG4gICAgICAgIGdsb2JhbDoge30sXHJcblxyXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3Rvcikge1xyXG5cclxuICAgICAgICAgICAgdmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRzLCB0LCBoYW5kbGVPYmosXHJcbiAgICAgICAgICAgICAgICBzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXHJcbiAgICAgICAgICAgICAgICBlbGVtRGF0YSA9IGRhdGFQcml2LmdldChlbGVtKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXHJcbiAgICAgICAgICAgIGlmICghZWxlbURhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXHJcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZU9iakluID0gaGFuZGxlcjtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3RvcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxyXG4gICAgICAgICAgICAvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcclxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoZG9jdW1lbnRFbGVtZW50LCBzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxyXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuZ3VpZCkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICBpZiAoIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIShldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSkpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24gKGUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KGVsZW0sIGFyZ3VtZW50cykgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXHJcbiAgICAgICAgICAgIHR5cGVzID0gKHR5cGVzIHx8IFwiXCIpLm1hdGNoKHJub3RodG1sd2hpdGUpIHx8IFtcIlwiXTtcclxuICAgICAgICAgICAgdCA9IHR5cGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUgKHQtLSkge1xyXG4gICAgICAgICAgICAgICAgdG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyh0eXBlc1t0XSkgfHwgW107XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gb3JpZ1R5cGUgPSB0bXBbMV07XHJcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gKHRtcFsyXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXHJcbiAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXHJcbiAgICAgICAgICAgICAgICB0eXBlID0gKHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlKSB8fCB0eXBlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcclxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBvcmlnVHlwZTogb3JpZ1R5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGd1aWQ6IGhhbmRsZXIuZ3VpZCxcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdChzZWxlY3RvciksXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpXHJcbiAgICAgICAgICAgICAgICB9LCBoYW5kbGVPYmpJbik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3RcclxuICAgICAgICAgICAgICAgIGlmICghKGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3BlY2lhbC5zZXR1cCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLnNldHVwLmNhbGwoZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUpID09PSBmYWxzZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGV2ZW50SGFuZGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbC5hZGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLmFkZC5jYWxsKGVsZW0sIGhhbmRsZU9iaik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVPYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cclxuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5nbG9iYWxbdHlwZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBqLCBvcmlnQ291bnQsIHRtcCxcclxuICAgICAgICAgICAgICAgIGV2ZW50cywgdCwgaGFuZGxlT2JqLFxyXG4gICAgICAgICAgICAgICAgc3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxyXG4gICAgICAgICAgICAgICAgZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKGVsZW0pICYmIGRhdGFQcml2LmdldChlbGVtKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZWxlbURhdGEgfHwgIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcclxuICAgICAgICAgICAgdHlwZXMgPSAodHlwZXMgfHwgXCJcIikubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW1wiXCJdO1xyXG4gICAgICAgICAgICB0ID0gdHlwZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZSAodC0tKSB7XHJcbiAgICAgICAgICAgICAgICB0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKHR5cGVzW3RdKSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcclxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSAodG1wWzJdIHx8IFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHR5cGUgaW4gZXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoZWxlbSwgdHlwZSArIHR5cGVzW3RdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSAoc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUpIHx8IHR5cGU7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIHRtcCA9IHRtcFsyXSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgb3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBoYW5kbGVyc1tqXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCF0bXAgfHwgdG1wLnRlc3QoaGFuZGxlT2JqLm5hbWVzcGFjZSkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShqLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVPYmouc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbC5yZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWwucmVtb3ZlLmNhbGwoZWxlbSwgaGFuZGxlT2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XHJcbiAgICAgICAgICAgICAgICAvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3BlY2lhbC50ZWFyZG93biB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLnRlYXJkb3duLmNhbGwoZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlKSA9PT0gZmFsc2UpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudChlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcclxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0VtcHR5T2JqZWN0KGV2ZW50cykpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFQcml2LnJlbW92ZShlbGVtLCBcImhhbmRsZSBldmVudHNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gKG5hdGl2ZUV2ZW50KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3RcclxuICAgICAgICAgICAgdmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeChuYXRpdmVFdmVudCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVycyA9IChkYXRhUHJpdi5nZXQodGhpcywgXCJldmVudHNcIikgfHwge30pW2V2ZW50LnR5cGVdIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW2V2ZW50LnR5cGVdIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcclxuICAgICAgICAgICAgYXJnc1swXSA9IGV2ZW50O1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxyXG4gICAgICAgICAgICBpZiAoc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwodGhpcywgZXZlbnQpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaGFuZGxlcnNcclxuICAgICAgICAgICAgaGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwodGhpcywgZXZlbnQsIGhhbmRsZXJzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAoKG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XHJcblxyXG4gICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbaisrXSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdChoYW5kbGVPYmoubmFtZXNwYWNlKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSAoKGpRdWVyeS5ldmVudC5zcGVjaWFsW2hhbmRsZU9iai5vcmlnVHlwZV0gfHwge30pLmhhbmRsZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLmhhbmRsZXIpLmFwcGx5KG1hdGNoZWQuZWxlbSwgYXJncyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZXZlbnQucmVzdWx0ID0gcmV0KSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXHJcbiAgICAgICAgICAgIGlmIChzcGVjaWFsLnBvc3REaXNwYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgc3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLCBldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBldmVudC5yZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaGFuZGxlcnM6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgdmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyUXVldWUgPSBbXSxcclxuICAgICAgICAgICAgICAgIGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxyXG4gICAgICAgICAgICAgICAgY3VyID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuICAgICAgICAgICAgLy8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xyXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVDb3VudCAmJlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OVxyXG4gICAgICAgICAgICAgICAgLy8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXHJcbiAgICAgICAgICAgICAgICBjdXIubm9kZVR5cGUgJiZcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcclxuICAgICAgICAgICAgICAgIC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcclxuICAgICAgICAgICAgICAgIC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0MylcclxuICAgICAgICAgICAgICAgICEoZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRIYW5kbGVycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkU2VsZWN0b3JzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZXJzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZFNlbGVjdG9yc1tzZWxdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkU2VsZWN0b3JzW3NlbF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHNlbCwgdGhpcykuaW5kZXgoY3VyKSA+IC0xIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmZpbmQoc2VsLCB0aGlzLCBudWxsLCBbY3VyXSkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRTZWxlY3RvcnNbc2VsXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRIYW5kbGVycy5wdXNoKGhhbmRsZU9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRIYW5kbGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXHJcbiAgICAgICAgICAgIGN1ciA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyUXVldWUucHVzaCh7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKGRlbGVnYXRlQ291bnQpIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlclF1ZXVlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFkZFByb3A6IGZ1bmN0aW9uIChuYW1lLCBob29rKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICAgICAgICAgIGdldDogaXNGdW5jdGlvbihob29rKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5hbEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaG9vayh0aGlzLm9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSA6XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5hbEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50W25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmaXg6IGZ1bmN0aW9uIChvcmlnaW5hbEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEV2ZW50W2pRdWVyeS5leHBhbmRvXSA/XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50IDpcclxuICAgICAgICAgICAgICAgIG5ldyBqUXVlcnkuRXZlbnQob3JpZ2luYWxFdmVudCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3BlY2lhbDoge1xyXG4gICAgICAgICAgICBsb2FkOiB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxyXG4gICAgICAgICAgICAgICAgbm9CdWJibGU6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZm9jdXM6IHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3RcclxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJsdXI6IHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ibHVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xpY2s6IHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIG5vZGVOYW1lKHRoaXMsIFwiaW5wdXRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGljaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3NcclxuICAgICAgICAgICAgICAgIF9kZWZhdWx0OiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZU5hbWUoZXZlbnQudGFyZ2V0LCBcImFcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBiZWZvcmV1bmxvYWQ6IHtcclxuICAgICAgICAgICAgICAgIHBvc3REaXNwYXRjaDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgaGFuZGxlKSB7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xyXG4gICAgICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiAoc3JjLCBwcm9wcykge1xyXG5cclxuICAgICAgICAvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcclxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGpRdWVyeS5FdmVudChzcmMsIHByb3BzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV2ZW50IG9iamVjdFxyXG4gICAgICAgIGlmIChzcmMgJiYgc3JjLnR5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xyXG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBzcmMudHlwZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXHJcbiAgICAgICAgICAgIC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxyXG4gICAgICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XHJcbiAgICAgICAgICAgICAgICBzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XHJcbiAgICAgICAgICAgICAgICBzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cclxuICAgICAgICAgICAgICAgIHJldHVyblRydWUgOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuRmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcclxuICAgICAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxyXG4gICAgICAgICAgICAvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxyXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IChzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMpID9cclxuICAgICAgICAgICAgICAgIHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XHJcbiAgICAgICAgICAgICAgICBzcmMudGFyZ2V0O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XHJcbiAgICAgICAgICAgIHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuICAgICAgICAgICAgLy8gRXZlbnQgdHlwZVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHNyYztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XHJcbiAgICAgICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodGhpcywgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcclxuICAgICAgICB0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgIC8vIE1hcmsgaXQgYXMgZml4ZWRcclxuICAgICAgICB0aGlzW2pRdWVyeS5leHBhbmRvXSA9IHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xyXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxyXG4gICAgalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxyXG4gICAgICAgIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXHJcbiAgICAgICAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxyXG4gICAgICAgIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcclxuICAgICAgICBpc1NpbXVsYXRlZDogZmFsc2UsXHJcblxyXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXHJcbiAgICBqUXVlcnkuZWFjaCh7XHJcbiAgICAgICAgYWx0S2V5OiB0cnVlLFxyXG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXHJcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcclxuICAgICAgICBjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcclxuICAgICAgICBjdHJsS2V5OiB0cnVlLFxyXG4gICAgICAgIGRldGFpbDogdHJ1ZSxcclxuICAgICAgICBldmVudFBoYXNlOiB0cnVlLFxyXG4gICAgICAgIG1ldGFLZXk6IHRydWUsXHJcbiAgICAgICAgcGFnZVg6IHRydWUsXHJcbiAgICAgICAgcGFnZVk6IHRydWUsXHJcbiAgICAgICAgc2hpZnRLZXk6IHRydWUsXHJcbiAgICAgICAgdmlldzogdHJ1ZSxcclxuICAgICAgICBcImNoYXJcIjogdHJ1ZSxcclxuICAgICAgICBjaGFyQ29kZTogdHJ1ZSxcclxuICAgICAgICBrZXk6IHRydWUsXHJcbiAgICAgICAga2V5Q29kZTogdHJ1ZSxcclxuICAgICAgICBidXR0b246IHRydWUsXHJcbiAgICAgICAgYnV0dG9uczogdHJ1ZSxcclxuICAgICAgICBjbGllbnRYOiB0cnVlLFxyXG4gICAgICAgIGNsaWVudFk6IHRydWUsXHJcbiAgICAgICAgb2Zmc2V0WDogdHJ1ZSxcclxuICAgICAgICBvZmZzZXRZOiB0cnVlLFxyXG4gICAgICAgIHBvaW50ZXJJZDogdHJ1ZSxcclxuICAgICAgICBwb2ludGVyVHlwZTogdHJ1ZSxcclxuICAgICAgICBzY3JlZW5YOiB0cnVlLFxyXG4gICAgICAgIHNjcmVlblk6IHRydWUsXHJcbiAgICAgICAgdGFyZ2V0VG91Y2hlczogdHJ1ZSxcclxuICAgICAgICB0b0VsZW1lbnQ6IHRydWUsXHJcbiAgICAgICAgdG91Y2hlczogdHJ1ZSxcclxuXHJcbiAgICAgICAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXHJcbiAgICAgICAgICAgIGlmIChldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KGV2ZW50LnR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxyXG4gICAgICAgICAgICBpZiAoIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoZXZlbnQudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChidXR0b24gJiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJ1dHRvbiAmIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uICYgNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQud2hpY2g7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgalF1ZXJ5LmV2ZW50LmFkZFByb3ApO1xyXG5cclxuICAgIC8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xyXG4gICAgLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cclxuICAgIC8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XHJcbiAgICAvL1xyXG4gICAgLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxyXG4gICAgLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XHJcbiAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcclxuICAgIC8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXHJcbiAgICBqUXVlcnkuZWFjaCh7XHJcbiAgICAgICAgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcclxuICAgICAgICBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXHJcbiAgICAgICAgcG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXHJcbiAgICAgICAgcG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxyXG4gICAgfSwgZnVuY3Rpb24gKG9yaWcsIGZpeCkge1xyXG4gICAgICAgIGpRdWVyeS5ldmVudC5zcGVjaWFsW29yaWddID0ge1xyXG4gICAgICAgICAgICBkZWxlZ2F0ZVR5cGU6IGZpeCxcclxuICAgICAgICAgICAgYmluZFR5cGU6IGZpeCxcclxuXHJcbiAgICAgICAgICAgIGhhbmRsZTogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0LFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICAgICAgICAvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyh0YXJnZXQsIHJlbGF0ZWQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gZml4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgb246IGZ1bmN0aW9uICh0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvbih0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uZTogZnVuY3Rpb24gKHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9uKHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb2ZmOiBmdW5jdGlvbiAodHlwZXMsIHNlbGVjdG9yLCBmbikge1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlT2JqLCB0eXBlO1xyXG4gICAgICAgICAgICBpZiAodHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5KHR5cGVzLmRlbGVnYXRlVGFyZ2V0KS5vZmYoXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLm5hbWVzcGFjZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5vcmlnVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmouc2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLmhhbmRsZXJcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcclxuICAgICAgICAgICAgICAgIGZvciAodHlwZSBpbiB0eXBlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKHR5cGUsIHNlbGVjdG9yLCB0eXBlc1t0eXBlXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gKCB0eXBlcyBbLCBmbl0gKVxyXG4gICAgICAgICAgICAgICAgZm4gPSBzZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmbiA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGZuID0gcmV0dXJuRmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgdmFyXHJcblxyXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cclxuXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XHJcbiAgICAgICAgcnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksXHJcblxyXG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cclxuXHJcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxyXG4gICAgICAgIC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cclxuICAgICAgICBybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcclxuXHJcbiAgICAgICAgLy8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXHJcbiAgICAgICAgcmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxyXG4gICAgICAgIHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcclxuXHJcbiAgICAvLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcclxuICAgIGZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldChlbGVtLCBjb250ZW50KSB7XHJcbiAgICAgICAgaWYgKG5vZGVOYW1lKGVsZW0sIFwidGFibGVcIikgJiZcclxuICAgICAgICAgICAgbm9kZU5hbWUoY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIpKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5KGVsZW0pLmNoaWxkcmVuKFwidGJvZHlcIilbMF0gfHwgZWxlbTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBlbGVtO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cclxuICAgIGZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoZWxlbSkge1xyXG4gICAgICAgIGVsZW0udHlwZSA9IChlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikgIT09IG51bGwpICsgXCIvXCIgKyBlbGVtLnR5cGU7XHJcbiAgICAgICAgcmV0dXJuIGVsZW07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXN0b3JlU2NyaXB0KGVsZW0pIHtcclxuICAgICAgICBpZiAoKGVsZW0udHlwZSB8fCBcIlwiKS5zbGljZSgwLCA1KSA9PT0gXCJ0cnVlL1wiKSB7XHJcbiAgICAgICAgICAgIGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSg1KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZWxlbTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbG9uZUNvcHlFdmVudChzcmMsIGRlc3QpIHtcclxuICAgICAgICB2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcclxuXHJcbiAgICAgICAgaWYgKGRlc3Qubm9kZVR5cGUgIT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cclxuICAgICAgICBpZiAoZGF0YVByaXYuaGFzRGF0YShzcmMpKSB7XHJcbiAgICAgICAgICAgIHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKHNyYyk7XHJcbiAgICAgICAgICAgIHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KGRlc3QsIHBkYXRhT2xkKTtcclxuICAgICAgICAgICAgZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xyXG5cclxuICAgICAgICAgICAgaWYgKGV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcclxuICAgICAgICAgICAgICAgIHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodHlwZSBpbiBldmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXZlbnRzW3R5cGVdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKGRlc3QsIHR5cGUsIGV2ZW50c1t0eXBlXVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAyLiBDb3B5IHVzZXIgZGF0YVxyXG4gICAgICAgIGlmIChkYXRhVXNlci5oYXNEYXRhKHNyYykpIHtcclxuICAgICAgICAgICAgdWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3Moc3JjKTtcclxuICAgICAgICAgICAgdWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKHt9LCB1ZGF0YU9sZCk7XHJcblxyXG4gICAgICAgICAgICBkYXRhVXNlci5zZXQoZGVzdCwgdWRhdGFDdXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcclxuICAgIGZ1bmN0aW9uIGZpeElucHV0KHNyYywgZGVzdCkge1xyXG4gICAgICAgIHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgLy8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXHJcbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdChzcmMudHlwZSkpIHtcclxuICAgICAgICAgICAgZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XHJcblxyXG4gICAgICAgICAgICAvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xyXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiKSB7XHJcbiAgICAgICAgICAgIGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZG9tTWFuaXAoY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQpIHtcclxuXHJcbiAgICAgICAgLy8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xyXG4gICAgICAgIGFyZ3MgPSBjb25jYXQuYXBwbHkoW10sIGFyZ3MpO1xyXG5cclxuICAgICAgICB2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXHJcbiAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICBsID0gY29sbGVjdGlvbi5sZW5ndGgsXHJcbiAgICAgICAgICAgIGlOb0Nsb25lID0gbCAtIDEsXHJcbiAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXSxcclxuICAgICAgICAgICAgdmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbih2YWx1ZSk7XHJcblxyXG4gICAgICAgIC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxyXG4gICAgICAgIGlmICh2YWx1ZUlzRnVuY3Rpb24gfHxcclxuICAgICAgICAgICAgKGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxyXG4gICAgICAgICAgICAgICAgIXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KHZhbHVlKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gY29sbGVjdGlvbi5lcShpbmRleCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVJc0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnc1swXSA9IHZhbHVlLmNhbGwodGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRvbU1hbmlwKHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobCkge1xyXG4gICAgICAgICAgICBmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoYXJncywgY29sbGVjdGlvblswXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCk7XHJcbiAgICAgICAgICAgIGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHJcbiAgICAgICAgICAgIGlmIChmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBmaXJzdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXHJcbiAgICAgICAgICAgIGlmIChmaXJzdCB8fCBpZ25vcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBzY3JpcHRzID0galF1ZXJ5Lm1hcChnZXRBbGwoZnJhZ21lbnQsIFwic2NyaXB0XCIpLCBkaXNhYmxlU2NyaXB0KTtcclxuICAgICAgICAgICAgICAgIGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXHJcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcclxuICAgICAgICAgICAgICAgIC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBmcmFnbWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGlOb0Nsb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBqUXVlcnkuY2xvbmUobm9kZSwgdHJ1ZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNTY3JpcHRzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2Uoc2NyaXB0cywgZ2V0QWxsKG5vZGUsIFwic2NyaXB0XCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjb2xsZWN0aW9uW2ldLCBub2RlLCBpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2NyaXB0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5vd25lckRvY3VtZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZWVuYWJsZSBzY3JpcHRzXHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1hcChzY3JpcHRzLCByZXN0b3JlU2NyaXB0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHNjcmlwdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyc2NyaXB0VHlwZS50ZXN0KG5vZGUudHlwZSB8fCBcIlwiKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWRhdGFQcml2LmFjY2Vzcyhub2RlLCBcImdsb2JhbEV2YWxcIikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jb250YWlucyhkb2MsIG5vZGUpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3JjICYmIChub2RlLnR5cGUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSAhPT0gXCJtb2R1bGVcIikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuX2V2YWxVcmwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9ldmFsVXJsKG5vZGUuc3JjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERPTUV2YWwobm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKHJjbGVhblNjcmlwdCwgXCJcIiksIGRvYywgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZShlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEpIHtcclxuICAgICAgICB2YXIgbm9kZSxcclxuICAgICAgICAgICAgbm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoc2VsZWN0b3IsIGVsZW0pIDogZWxlbSxcclxuICAgICAgICAgICAgaSA9IDA7XHJcblxyXG4gICAgICAgIGZvciAoOyAobm9kZSA9IG5vZGVzW2ldKSAhPSBudWxsOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGdldEFsbChub2RlKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMobm9kZS5vd25lckRvY3VtZW50LCBub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEdsb2JhbEV2YWwoZ2V0QWxsKG5vZGUsIFwic2NyaXB0XCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgalF1ZXJ5LmV4dGVuZCh7XHJcbiAgICAgICAgaHRtbFByZWZpbHRlcjogZnVuY3Rpb24gKGh0bWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShyeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMpIHtcclxuICAgICAgICAgICAgdmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXHJcbiAgICAgICAgICAgICAgICBjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKHRydWUpLFxyXG4gICAgICAgICAgICAgICAgaW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcclxuICAgICAgICAgICAgaWYgKCFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExKSAmJlxyXG4gICAgICAgICAgICAgICAgIWpRdWVyeS5pc1hNTERvYyhlbGVtKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxyXG4gICAgICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKGNsb25lKTtcclxuICAgICAgICAgICAgICAgIHNyY0VsZW1lbnRzID0gZ2V0QWxsKGVsZW0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXhJbnB1dChzcmNFbGVtZW50c1tpXSwgZGVzdEVsZW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxyXG4gICAgICAgICAgICBpZiAoZGF0YUFuZEV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZXBEYXRhQW5kRXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbChjbG9uZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVDb3B5RXZlbnQoc3JjRWxlbWVudHNbaV0sIGRlc3RFbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG9uZUNvcHlFdmVudChlbGVtLCBjbG9uZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcclxuICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKGNsb25lLCBcInNjcmlwdFwiKTtcclxuICAgICAgICAgICAgaWYgKGRlc3RFbGVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRHbG9iYWxFdmFsKGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoZWxlbSwgXCJzY3JpcHRcIikpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcclxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsZWFuRGF0YTogZnVuY3Rpb24gKGVsZW1zKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhLCBlbGVtLCB0eXBlLFxyXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxyXG4gICAgICAgICAgICAgICAgaSA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgKGVsZW0gPSBlbGVtc1tpXSkgIT09IHVuZGVmaW5lZDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWNjZXB0RGF0YShlbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZGF0YSA9IGVsZW1bZGF0YVByaXYuZXhwYW5kb10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh0eXBlIGluIGRhdGEuZXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWxbdHlwZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZShlbGVtLCB0eXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlRXZlbnQoZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bZGF0YVByaXYuZXhwYW5kb10gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtW2RhdGFVc2VyLmV4cGFuZG9dKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVtkYXRhVXNlci5leHBhbmRvXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlKHRoaXMsIHNlbGVjdG9yLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlKHRoaXMsIHNlbGVjdG9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0ZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkudGV4dCh0aGlzKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbXB0eSgpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFwcGVuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZG9tTWFuaXAodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQodGhpcywgZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwcmVwZW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb21NYW5pcCh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCh0aGlzLCBlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKGVsZW0sIHRhcmdldC5maXJzdENoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYmVmb3JlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb21NYW5pcCh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYWZ0ZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRvbU1hbmlwKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW0sIHRoaXMubmV4dFNpYmxpbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBlbXB0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbSxcclxuICAgICAgICAgICAgICAgIGkgPSAwO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IChlbGVtID0gdGhpc1tpXSkgIT0gbnVsbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoZ2V0QWxsKGVsZW0sIGZhbHNlKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMpIHtcclxuICAgICAgICAgICAgZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcclxuICAgICAgICAgICAgZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuY2xvbmUodGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBodG1sOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpc1swXSB8fCB7fSxcclxuICAgICAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBsID0gdGhpcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmlubmVySFRNTDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCh2YWx1ZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAhd3JhcE1hcFsocnRhZ05hbWUuZXhlYyh2YWx1ZSkgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpXSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzW2ldIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGdldEFsbChlbGVtLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtcHR5KCkuYXBwZW5kKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlcGxhY2VXaXRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpZ25vcmVkID0gW107XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcclxuICAgICAgICAgICAgcmV0dXJuIGRvbU1hbmlwKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pbkFycmF5KHRoaXMsIGlnbm9yZWQpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoZ2V0QWxsKHRoaXMpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoZWxlbSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cclxuICAgICAgICAgICAgfSwgaWdub3JlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgalF1ZXJ5LmVhY2goe1xyXG4gICAgICAgIGFwcGVuZFRvOiBcImFwcGVuZFwiLFxyXG4gICAgICAgIHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXHJcbiAgICAgICAgaW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxyXG4gICAgICAgIGluc2VydEFmdGVyOiBcImFmdGVyXCIsXHJcbiAgICAgICAgcmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXHJcbiAgICB9LCBmdW5jdGlvbiAobmFtZSwgb3JpZ2luYWwpIHtcclxuICAgICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1zLFxyXG4gICAgICAgICAgICAgICAgcmV0ID0gW10sXHJcbiAgICAgICAgICAgICAgICBpbnNlcnQgPSBqUXVlcnkoc2VsZWN0b3IpLFxyXG4gICAgICAgICAgICAgICAgbGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxyXG4gICAgICAgICAgICAgICAgaSA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8PSBsYXN0OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5KGluc2VydFtpXSlbb3JpZ2luYWxdKGVsZW1zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcclxuICAgICAgICAgICAgICAgIC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcclxuICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmV0LCBlbGVtcy5nZXQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhyZXQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIHZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIik7XHJcblxyXG4gICAgdmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uIChlbGVtKSB7XHJcblxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcclxuICAgICAgICAvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcclxuICAgICAgICAvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcclxuICAgICAgICB2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcclxuXHJcbiAgICAgICAgaWYgKCF2aWV3IHx8ICF2aWV3Lm9wZW5lcikge1xyXG4gICAgICAgICAgICB2aWV3ID0gd2luZG93O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoY3NzRXhwYW5kLmpvaW4oXCJ8XCIpLCBcImlcIik7XHJcblxyXG5cclxuXHJcbiAgICAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcclxuICAgICAgICAvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxyXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxyXG4gICAgICAgICAgICBpZiAoIWRpdikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcclxuICAgICAgICAgICAgICAgIFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XHJcbiAgICAgICAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID1cclxuICAgICAgICAgICAgICAgIFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcclxuICAgICAgICAgICAgICAgIFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXHJcbiAgICAgICAgICAgICAgICBcIndpZHRoOjYwJTt0b3A6MSVcIjtcclxuICAgICAgICAgICAgZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcikuYXBwZW5kQ2hpbGQoZGl2KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRpdik7XHJcbiAgICAgICAgICAgIHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcclxuICAgICAgICAgICAgcmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKGRpdlN0eWxlLm1hcmdpbkxlZnQpID09PSAxMjtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xyXG4gICAgICAgICAgICAvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3RcclxuICAgICAgICAgICAgZGl2LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIjtcclxuICAgICAgICAgICAgcGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoZGl2U3R5bGUucmlnaHQpID09PSAzNjtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XHJcbiAgICAgICAgICAgIC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcclxuICAgICAgICAgICAgYm94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoZGl2U3R5bGUud2lkdGgpID09PSAzNjtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgb25seVxyXG4gICAgICAgICAgICAvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXHJcbiAgICAgICAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICAgICAgc2Nyb2xsYm94U2l6ZVZhbCA9IGRpdi5vZmZzZXRXaWR0aCA9PT0gMzYgfHwgXCJhYnNvbHV0ZVwiO1xyXG5cclxuICAgICAgICAgICAgZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICAvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXHJcbiAgICAgICAgICAgIC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcclxuICAgICAgICAgICAgZGl2ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyhtZWFzdXJlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobWVhc3VyZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcclxuICAgICAgICAgICAgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxyXG4gICAgICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxyXG4gICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuICAgICAgICAvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xyXG4gICAgICAgIGlmICghZGl2LnN0eWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcclxuICAgICAgICAvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXHJcbiAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xyXG4gICAgICAgIGRpdi5jbG9uZU5vZGUodHJ1ZSkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xyXG4gICAgICAgIHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XHJcblxyXG4gICAgICAgIGpRdWVyeS5leHRlbmQoc3VwcG9ydCwge1xyXG4gICAgICAgICAgICBib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBjdXJDU1MoZWxlbSwgbmFtZSwgY29tcHV0ZWQpIHtcclxuICAgICAgICB2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxyXG5cclxuICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA1MStcclxuICAgICAgICAgICAgLy8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xyXG4gICAgICAgICAgICAvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXHJcbiAgICAgICAgICAgIC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcclxuXHJcbiAgICAgICAgY29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoZWxlbSk7XHJcblxyXG4gICAgICAgIC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcclxuICAgICAgICAvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcclxuICAgICAgICAvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcclxuICAgICAgICBpZiAoY29tcHV0ZWQpIHtcclxuICAgICAgICAgICAgcmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSB8fCBjb21wdXRlZFtuYW1lXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyhlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXQgPSBqUXVlcnkuc3R5bGUoZWxlbSwgbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcclxuICAgICAgICAgICAgLy8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXHJcbiAgICAgICAgICAgIC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcclxuICAgICAgICAgICAgaWYgKCFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QocmV0KSAmJiByYm94U3R5bGUudGVzdChuYW1lKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIHdpZHRoID0gc3R5bGUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xyXG4gICAgICAgICAgICAgICAgbWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XHJcbiAgICAgICAgICAgICAgICByZXQgPSBjb21wdXRlZC53aWR0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcclxuICAgICAgICAgICAgICAgIHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XHJcbiAgICAgICAgICAgIC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXHJcbiAgICAgICAgICAgIHJldCArIFwiXCIgOlxyXG4gICAgICAgICAgICByZXQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZEdldEhvb2tJZihjb25kaXRpb25GbiwgaG9va0ZuKSB7XHJcblxyXG4gICAgICAgIC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uRm4oKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcclxuICAgICAgICAgICAgICAgICAgICAvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5nZXQgPSBob29rRm4pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICB2YXJcclxuXHJcbiAgICAgICAgLy8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxyXG4gICAgICAgIC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxyXG4gICAgICAgIC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxyXG4gICAgICAgIHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcclxuICAgICAgICByY3VzdG9tUHJvcCA9IC9eLS0vLFxyXG4gICAgICAgIGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxyXG4gICAgICAgIGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcclxuICAgICAgICAgICAgbGV0dGVyU3BhY2luZzogXCIwXCIsXHJcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiNDAwXCJcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjc3NQcmVmaXhlcyA9IFtcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCJdLFxyXG4gICAgICAgIGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlO1xyXG5cclxuICAgIC8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcclxuICAgIGZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKG5hbWUpIHtcclxuXHJcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcclxuICAgICAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xyXG4gICAgICAgIHZhciBjYXBOYW1lID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSxcclxuICAgICAgICAgICAgaSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICBuYW1lID0gY3NzUHJlZml4ZXNbaV0gKyBjYXBOYW1lO1xyXG4gICAgICAgICAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXR1cm4gYSBwcm9wZXJ0eSBtYXBwZWQgYWxvbmcgd2hhdCBqUXVlcnkuY3NzUHJvcHMgc3VnZ2VzdHMgb3IgdG9cclxuICAgIC8vIGEgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5LlxyXG4gICAgZnVuY3Rpb24gZmluYWxQcm9wTmFtZShuYW1lKSB7XHJcbiAgICAgICAgdmFyIHJldCA9IGpRdWVyeS5jc3NQcm9wc1tuYW1lXTtcclxuICAgICAgICBpZiAoIXJldCkge1xyXG4gICAgICAgICAgICByZXQgPSBqUXVlcnkuY3NzUHJvcHNbbmFtZV0gPSB2ZW5kb3JQcm9wTmFtZShuYW1lKSB8fCBuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCkge1xyXG5cclxuICAgICAgICAvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXHJcbiAgICAgICAgLy8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XHJcbiAgICAgICAgdmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWModmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVzID9cclxuXHJcbiAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXHJcbiAgICAgICAgICAgIE1hdGgubWF4KDAsIG1hdGNoZXNbMl0gLSAoc3VidHJhY3QgfHwgMCkpICsgKG1hdGNoZXNbM10gfHwgXCJweFwiKSA6XHJcbiAgICAgICAgICAgIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudChlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwpIHtcclxuICAgICAgICB2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXHJcbiAgICAgICAgICAgIGV4dHJhID0gMCxcclxuICAgICAgICAgICAgZGVsdGEgPSAwO1xyXG5cclxuICAgICAgICAvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XHJcbiAgICAgICAgaWYgKGJveCA9PT0gKGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgNDsgaSArPSAyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cclxuICAgICAgICAgICAgaWYgKGJveCA9PT0gXCJtYXJnaW5cIikge1xyXG4gICAgICAgICAgICAgICAgZGVsdGEgKz0galF1ZXJ5LmNzcyhlbGVtLCBib3ggKyBjc3NFeHBhbmRbaV0sIHRydWUsIHN0eWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcclxuICAgICAgICAgICAgaWYgKCFpc0JvcmRlckJveCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXHJcbiAgICAgICAgICAgICAgICBkZWx0YSArPSBqUXVlcnkuY3NzKGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kW2ldLCB0cnVlLCBzdHlsZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcclxuICAgICAgICAgICAgICAgIGlmIChib3ggIT09IFwicGFkZGluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0galF1ZXJ5LmNzcyhlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kW2ldICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2VcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEgKz0galF1ZXJ5LmNzcyhlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kW2ldICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3JcclxuICAgICAgICAgICAgICAgIC8vIFwicGFkZGluZ1wiIG9yIFwibWFyZ2luXCJcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcclxuICAgICAgICAgICAgICAgIGlmIChib3ggPT09IFwiY29udGVudFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgLT0galF1ZXJ5LmNzcyhlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFtpXSwgdHJ1ZSwgc3R5bGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxyXG4gICAgICAgICAgICAgICAgaWYgKGJveCAhPT0gXCJtYXJnaW5cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhIC09IGpRdWVyeS5jc3MoZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFtpXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcclxuICAgICAgICBpZiAoIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcclxuICAgICAgICAgICAgLy8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxyXG4gICAgICAgICAgICBkZWx0YSArPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoXHJcbiAgICAgICAgICAgICAgICBlbGVtW1wib2Zmc2V0XCIgKyBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKV0gLVxyXG4gICAgICAgICAgICAgICAgY29tcHV0ZWRWYWwgLVxyXG4gICAgICAgICAgICAgICAgZGVsdGEgLVxyXG4gICAgICAgICAgICAgICAgZXh0cmEgLVxyXG4gICAgICAgICAgICAgICAgMC41XHJcbiAgICAgICAgICAgICkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRlbHRhO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoZWxlbSwgZGltZW5zaW9uLCBleHRyYSkge1xyXG5cclxuICAgICAgICAvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXHJcbiAgICAgICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlcyhlbGVtKSxcclxuICAgICAgICAgICAgdmFsID0gY3VyQ1NTKGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzKSxcclxuICAgICAgICAgICAgaXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMpID09PSBcImJvcmRlci1ib3hcIixcclxuICAgICAgICAgICAgdmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94O1xyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcclxuICAgICAgICAvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cclxuICAgICAgICBpZiAocm51bW5vbnB4LnRlc3QodmFsKSkge1xyXG4gICAgICAgICAgICBpZiAoIWV4dHJhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbCA9IFwiYXV0b1wiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcclxuICAgICAgICAvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXHJcbiAgICAgICAgdmFsdWVJc0JvcmRlckJveCA9IHZhbHVlSXNCb3JkZXJCb3ggJiZcclxuICAgICAgICAgICAgKHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbZGltZW5zaW9uXSk7XHJcblxyXG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxyXG4gICAgICAgIC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcclxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcclxuICAgICAgICAvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxyXG4gICAgICAgIGlmICh2YWwgPT09IFwiYXV0b1wiIHx8XHJcbiAgICAgICAgICAgICFwYXJzZUZsb2F0KHZhbCkgJiYgalF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcykgPT09IFwiaW5saW5lXCIpIHtcclxuXHJcbiAgICAgICAgICAgIHZhbCA9IGVsZW1bXCJvZmZzZXRcIiArIGRpbWVuc2lvblswXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKDEpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBwcm92aWRlIGJvcmRlci1ib3ggdmFsdWVzXHJcbiAgICAgICAgICAgIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cclxuICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbCkgfHwgMDtcclxuXHJcbiAgICAgICAgLy8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxyXG4gICAgICAgIHJldHVybiAodmFsICtcclxuICAgICAgICAgICAgYm94TW9kZWxBZGp1c3RtZW50KFxyXG4gICAgICAgICAgICAgICAgZWxlbSxcclxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbixcclxuICAgICAgICAgICAgICAgIGV4dHJhIHx8IChpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZUlzQm9yZGVyQm94LFxyXG4gICAgICAgICAgICAgICAgc3R5bGVzLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXHJcbiAgICAgICAgICAgICAgICB2YWxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICkgKyBcInB4XCI7XHJcbiAgICB9XHJcblxyXG4gICAgalF1ZXJ5LmV4dGVuZCh7XHJcblxyXG4gICAgICAgIC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxyXG4gICAgICAgIC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxyXG4gICAgICAgIGNzc0hvb2tzOiB7XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0sIGNvbXB1dGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gY3VyQ1NTKGVsZW0sIFwib3BhY2l0eVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXHJcbiAgICAgICAgY3NzTnVtYmVyOiB7XHJcbiAgICAgICAgICAgIFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJjb2x1bW5Db3VudFwiOiB0cnVlLFxyXG4gICAgICAgICAgICBcImZpbGxPcGFjaXR5XCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwiZmxleEdyb3dcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJmbGV4U2hyaW5rXCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwiZm9udFdlaWdodFwiOiB0cnVlLFxyXG4gICAgICAgICAgICBcImxpbmVIZWlnaHRcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwib3JkZXJcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJvcnBoYW5zXCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwid2lkb3dzXCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwiekluZGV4XCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwiem9vbVwiOiB0cnVlXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxyXG4gICAgICAgIC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcclxuICAgICAgICBjc3NQcm9wczoge30sXHJcblxyXG4gICAgICAgIC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXHJcbiAgICAgICAgc3R5bGU6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xyXG4gICAgICAgICAgICBpZiAoIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxyXG4gICAgICAgICAgICB2YXIgcmV0LCB0eXBlLCBob29rcyxcclxuICAgICAgICAgICAgICAgIG9yaWdOYW1lID0gY2FtZWxDYXNlKG5hbWUpLFxyXG4gICAgICAgICAgICAgICAgaXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdChuYW1lKSxcclxuICAgICAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3RcclxuICAgICAgICAgICAgLy8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cclxuICAgICAgICAgICAgaWYgKCFpc0N1c3RvbVByb3ApIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBmaW5hbFByb3BOYW1lKG9yaWdOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cclxuICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbbmFtZV0gfHwgalF1ZXJ5LmNzc0hvb2tzW29yaWdOYW1lXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAocmV0ID0gcmNzc051bS5leGVjKHZhbHVlKSkgJiYgcmV0WzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhZGp1c3RDU1MoZWxlbSwgbmFtZSwgcmV0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZXMgYnVnICM5MjM3XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwibnVtYmVyXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gcmV0ICYmIHJldFszXSB8fCAoalF1ZXJ5LmNzc051bWJlcltvcmlnTmFtZV0gPyBcIlwiIDogXCJweFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZihcImJhY2tncm91bmRcIikgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZVtuYW1lXSA9IFwiaW5oZXJpdFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFob29rcyB8fCAhKFwic2V0XCIgaW4gaG9va3MpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlID0gaG9va3Muc2V0KGVsZW0sIHZhbHVlLCBleHRyYSkpICE9PSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VzdG9tUHJvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxyXG4gICAgICAgICAgICAgICAgaWYgKGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcclxuICAgICAgICAgICAgICAgICAgICAocmV0ID0gaG9va3MuZ2V0KGVsZW0sIGZhbHNlLCBleHRyYSkpICE9PSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlW25hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY3NzOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcykge1xyXG4gICAgICAgICAgICB2YXIgdmFsLCBudW0sIGhvb2tzLFxyXG4gICAgICAgICAgICAgICAgb3JpZ05hbWUgPSBjYW1lbENhc2UobmFtZSksXHJcbiAgICAgICAgICAgICAgICBpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxyXG4gICAgICAgICAgICAvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cclxuICAgICAgICAgICAgaWYgKCFpc0N1c3RvbVByb3ApIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBmaW5hbFByb3BOYW1lKG9yaWdOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxyXG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5jc3NIb29rc1tuYW1lXSB8fCBqUXVlcnkuY3NzSG9va3Nbb3JpZ05hbWVdO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcclxuICAgICAgICAgICAgaWYgKGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IGhvb2tzLmdldChlbGVtLCB0cnVlLCBleHRyYSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gY3VyQ1NTKGVsZW0sIG5hbWUsIHN0eWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAodmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xyXG4gICAgICAgICAgICBpZiAoZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEpIHtcclxuICAgICAgICAgICAgICAgIG51bSA9IHBhcnNlRmxvYXQodmFsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZShudW0pID8gbnVtIHx8IDAgOiB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgalF1ZXJ5LmVhY2goW1wiaGVpZ2h0XCIsIFwid2lkdGhcIl0sIGZ1bmN0aW9uIChpLCBkaW1lbnNpb24pIHtcclxuICAgICAgICBqUXVlcnkuY3NzSG9va3NbZGltZW5zaW9uXSA9IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxlbSwgY29tcHV0ZWQsIGV4dHJhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoalF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIikpICYmXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBTYWZhcmkgOCtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dhcChlbGVtLCBjc3NTaG93LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0V2lkdGhPckhlaWdodChlbGVtLCBkaW1lbnNpb24sIGV4dHJhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRXaWR0aE9ySGVpZ2h0KGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoZWxlbSwgdmFsdWUsIGV4dHJhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXMgPSBnZXRTdHlsZXMoZWxlbSksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMpID09PSBcImJvcmRlci1ib3hcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdCA9IGV4dHJhICYmIGJveE1vZGVsQWRqdXN0bWVudChcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNCb3JkZXJCb3gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1xyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQm9yZGVyQm94ICYmIHN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpID09PSBzdHlsZXMucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bXCJvZmZzZXRcIiArIGRpbWVuc2lvblswXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKDEpXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3R5bGVzW2RpbWVuc2lvbl0pIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYm94TW9kZWxBZGp1c3RtZW50KGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcykgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjVcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoc3VidHJhY3QgJiYgKG1hdGNoZXMgPSByY3NzTnVtLmV4ZWModmFsdWUpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChtYXRjaGVzWzNdIHx8IFwicHhcIikgIT09IFwicHhcIikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBlbGVtLnN0eWxlW2RpbWVuc2lvbl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeS5jc3MoZWxlbSwgZGltZW5zaW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoZWxlbSwgdmFsdWUsIHN1YnRyYWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZihzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcclxuICAgICAgICBmdW5jdGlvbiAoZWxlbSwgY29tcHV0ZWQpIHtcclxuICAgICAgICAgICAgaWYgKGNvbXB1dGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBhcnNlRmxvYXQoY3VyQ1NTKGVsZW0sIFwibWFyZ2luTGVmdFwiKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxyXG4gICAgICAgICAgICAgICAgICAgIHN3YXAoZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKSArIFwicHhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xyXG4gICAgalF1ZXJ5LmVhY2goe1xyXG4gICAgICAgIG1hcmdpbjogXCJcIixcclxuICAgICAgICBwYWRkaW5nOiBcIlwiLFxyXG4gICAgICAgIGJvcmRlcjogXCJXaWR0aFwiXHJcbiAgICB9LCBmdW5jdGlvbiAocHJlZml4LCBzdWZmaXgpIHtcclxuICAgICAgICBqUXVlcnkuY3NzSG9va3NbcHJlZml4ICsgc3VmZml4XSA9IHtcclxuICAgICAgICAgICAgZXhwYW5kOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZCA9IHt9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KFwiIFwiKSA6IFt2YWx1ZV07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCA0OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZFtwcmVmaXggKyBjc3NFeHBhbmRbaV0gKyBzdWZmaXhdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNbaV0gfHwgcGFydHNbaSAtIDJdIHx8IHBhcnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmRlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChwcmVmaXggIT09IFwibWFyZ2luXCIpIHtcclxuICAgICAgICAgICAgalF1ZXJ5LmNzc0hvb2tzW3ByZWZpeCArIHN1ZmZpeF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICAgICAgY3NzOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHlsZXMsIGxlbixcclxuICAgICAgICAgICAgICAgICAgICBtYXAgPSB7fSxcclxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IGdldFN0eWxlcyhlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBuYW1lLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBbbmFtZVtpXV0gPSBqUXVlcnkuY3NzKGVsZW0sIG5hbWVbaV0sIGZhbHNlLCBzdHlsZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKGVsZW0sIG5hbWUsIHZhbHVlKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyhlbGVtLCBuYW1lKTtcclxuICAgICAgICAgICAgfSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gVHdlZW4oZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nKTtcclxuICAgIH1cclxuICAgIGpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xyXG5cclxuICAgIFR3ZWVuLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogVHdlZW4sXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICAgICAgICAgIHRoaXMucHJvcCA9IHByb3A7XHJcbiAgICAgICAgICAgIHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kID0gZW5kO1xyXG4gICAgICAgICAgICB0aGlzLnVuaXQgPSB1bml0IHx8IChqUXVlcnkuY3NzTnVtYmVyW3Byb3BdID8gXCJcIiA6IFwicHhcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjdXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzW3RoaXMucHJvcF07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cclxuICAgICAgICAgICAgICAgIGhvb2tzLmdldCh0aGlzKSA6XHJcbiAgICAgICAgICAgICAgICBUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcnVuOiBmdW5jdGlvbiAocGVyY2VudCkge1xyXG4gICAgICAgICAgICB2YXIgZWFzZWQsXHJcbiAgICAgICAgICAgICAgICBob29rcyA9IFR3ZWVuLnByb3BIb29rc1t0aGlzLnByb3BdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbdGhpcy5lYXNpbmddKFxyXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubm93ID0gKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0ZXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zdGVwLmNhbGwodGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChob29rcyAmJiBob29rcy5zZXQpIHtcclxuICAgICAgICAgICAgICAgIGhvb2tzLnNldCh0aGlzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBUd2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XHJcblxyXG4gICAgVHdlZW4ucHJvcEhvb2tzID0ge1xyXG4gICAgICAgIF9kZWZhdWx0OiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKHR3ZWVuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxyXG4gICAgICAgICAgICAgICAgaWYgKHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcclxuICAgICAgICAgICAgICAgICAgICB0d2Vlbi5lbGVtW3R3ZWVuLnByb3BdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVt0d2Vlbi5wcm9wXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxyXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XHJcbiAgICAgICAgICAgICAgICAvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0galF1ZXJ5LmNzcyh0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cclxuICAgICAgICAgICAgICAgIHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0d2Vlbikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxyXG4gICAgICAgICAgICAgICAgLy8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxyXG4gICAgICAgICAgICAgICAgLy8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cclxuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuZnguc3RlcFt0d2Vlbi5wcm9wXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5meC5zdGVwW3R3ZWVuLnByb3BdKHR3ZWVuKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh0d2Vlbi5lbGVtLnN0eWxlW2pRdWVyeS5jc3NQcm9wc1t0d2Vlbi5wcm9wXV0gIT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY3NzSG9va3NbdHdlZW4ucHJvcF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0d2Vlbi5lbGVtW3R3ZWVuLnByb3BdID0gdHdlZW4ubm93O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxyXG4gICAgLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXHJcbiAgICBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodHdlZW4pIHtcclxuICAgICAgICAgICAgaWYgKHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0d2Vlbi5lbGVtW3R3ZWVuLnByb3BdID0gdHdlZW4ubm93O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkuZWFzaW5nID0ge1xyXG4gICAgICAgIGxpbmVhcjogZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzd2luZzogZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDAuNSAtIE1hdGguY29zKHAgKiBNYXRoLlBJKSAvIDI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZGVmYXVsdDogXCJzd2luZ1wiXHJcbiAgICB9O1xyXG5cclxuICAgIGpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xyXG5cclxuICAgIC8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XHJcbiAgICBqUXVlcnkuZnguc3RlcCA9IHt9O1xyXG5cclxuXHJcblxyXG5cclxuICAgIHZhclxyXG4gICAgICAgIGZ4Tm93LCBpblByb2dyZXNzLFxyXG4gICAgICAgIHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxyXG4gICAgICAgIHJydW4gPSAvcXVldWVIb29rcyQvO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlKCkge1xyXG4gICAgICAgIGlmIChpblByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2NoZWR1bGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGpRdWVyeS5meC50aWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xyXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnhOb3cgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIChmeE5vdyA9IERhdGUubm93KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXHJcbiAgICBmdW5jdGlvbiBnZW5GeCh0eXBlLCBpbmNsdWRlV2lkdGgpIHtcclxuICAgICAgICB2YXIgd2hpY2gsXHJcbiAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICBhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XHJcblxyXG4gICAgICAgIC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcclxuICAgICAgICAvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxyXG4gICAgICAgIGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xyXG4gICAgICAgIGZvciAoOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoKSB7XHJcbiAgICAgICAgICAgIHdoaWNoID0gY3NzRXhwYW5kW2ldO1xyXG4gICAgICAgICAgICBhdHRyc1tcIm1hcmdpblwiICsgd2hpY2hdID0gYXR0cnNbXCJwYWRkaW5nXCIgKyB3aGljaF0gPSB0eXBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGluY2x1ZGVXaWR0aCkge1xyXG4gICAgICAgICAgICBhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGF0dHJzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKHZhbHVlLCBwcm9wLCBhbmltYXRpb24pIHtcclxuICAgICAgICB2YXIgdHdlZW4sXHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSAoQW5pbWF0aW9uLnR3ZWVuZXJzW3Byb3BdIHx8IFtdKS5jb25jYXQoQW5pbWF0aW9uLnR3ZWVuZXJzW1wiKlwiXSksXHJcbiAgICAgICAgICAgIGluZGV4ID0gMCxcclxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XHJcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmICgodHdlZW4gPSBjb2xsZWN0aW9uW2luZGV4XS5jYWxsKGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUpKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlcihlbGVtLCBwcm9wcywgb3B0cykge1xyXG4gICAgICAgIHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcclxuICAgICAgICAgICAgaXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcclxuICAgICAgICAgICAgYW5pbSA9IHRoaXMsXHJcbiAgICAgICAgICAgIG9yaWcgPSB7fSxcclxuICAgICAgICAgICAgc3R5bGUgPSBlbGVtLnN0eWxlLFxyXG4gICAgICAgICAgICBoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZShlbGVtKSxcclxuICAgICAgICAgICAgZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoZWxlbSwgXCJmeHNob3dcIik7XHJcblxyXG4gICAgICAgIC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xyXG4gICAgICAgIGlmICghb3B0cy5xdWV1ZSkge1xyXG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyhlbGVtLCBcImZ4XCIpO1xyXG4gICAgICAgICAgICBpZiAoaG9va3MudW5xdWV1ZWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaG9va3MudW5xdWV1ZWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgb2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XHJcbiAgICAgICAgICAgICAgICBob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaG9va3MudW5xdWV1ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkZmlyZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaG9va3MudW5xdWV1ZWQrKztcclxuXHJcbiAgICAgICAgICAgIGFuaW0uYWx3YXlzKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xyXG4gICAgICAgICAgICAgICAgYW5pbS5hbHdheXMoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVucXVldWVkLS07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqUXVlcnkucXVldWUoZWxlbSwgXCJmeFwiKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3MuZW1wdHkuZmlyZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xyXG4gICAgICAgIGZvciAocHJvcCBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzW3Byb3BdO1xyXG4gICAgICAgICAgICBpZiAocmZ4dHlwZXMudGVzdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1twcm9wXTtcclxuICAgICAgICAgICAgICAgIHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gKGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9yaWdbcHJvcF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1twcm9wXSB8fCBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXHJcbiAgICAgICAgcHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KHByb3BzKTtcclxuICAgICAgICBpZiAoIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdChvcmlnKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcclxuICAgICAgICBpZiAoaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xyXG5cclxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxyXG4gICAgICAgICAgICAvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcclxuICAgICAgICAgICAgLy8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXHJcbiAgICAgICAgICAgIC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXHJcbiAgICAgICAgICAgIG9wdHMub3ZlcmZsb3cgPSBbc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZXTtcclxuXHJcbiAgICAgICAgICAgIC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxyXG4gICAgICAgICAgICByZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XHJcbiAgICAgICAgICAgIGlmIChyZXN0b3JlRGlzcGxheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldChlbGVtLCBcImRpc3BsYXlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGlzcGxheSA9IGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIpO1xyXG4gICAgICAgICAgICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN0b3JlRGlzcGxheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcclxuICAgICAgICAgICAgICAgICAgICBzaG93SGlkZShbZWxlbV0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBqUXVlcnkuY3NzKGVsZW0sIFwiZGlzcGxheVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBzaG93SGlkZShbZWxlbV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcclxuICAgICAgICAgICAgaWYgKGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmNzcyhlbGVtLCBcImZsb2F0XCIpID09PSBcIm5vbmVcIikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcFR3ZWVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW0uZG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdG9yZURpc3BsYXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRzLm92ZXJmbG93KSB7XHJcbiAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcclxuICAgICAgICAgICAgYW5pbS5hbHdheXMoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WzBdO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sxXTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbMl07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXHJcbiAgICAgICAgcHJvcFR3ZWVuID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChwcm9wIGluIG9yaWcpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgIGlmICghcHJvcFR3ZWVuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVNob3cpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJoaWRkZW5cIiBpbiBkYXRhU2hvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyhlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxyXG4gICAgICAgICAgICAgICAgaWYgKHRvZ2dsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cclxuICAgICAgICAgICAgICAgIGlmIChoaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBzaG93SGlkZShbZWxlbV0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xyXG5cclxuICAgICAgICAgICAgICAgIGFuaW0uZG9uZShmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dIaWRlKFtlbGVtXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnJlbW92ZShlbGVtLCBcImZ4c2hvd1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHByb3AgaW4gb3JpZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCwgb3JpZ1twcm9wXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxyXG4gICAgICAgICAgICBwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbihoaWRkZW4gPyBkYXRhU2hvd1twcm9wXSA6IDAsIHByb3AsIGFuaW0pO1xyXG4gICAgICAgICAgICBpZiAoIShwcm9wIGluIGRhdGFTaG93KSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YVNob3dbcHJvcF0gPSBwcm9wVHdlZW4uc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wVHdlZW4uc3RhcnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb3BGaWx0ZXIocHJvcHMsIHNwZWNpYWxFYXNpbmcpIHtcclxuICAgICAgICB2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xyXG5cclxuICAgICAgICAvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3NcclxuICAgICAgICBmb3IgKGluZGV4IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbENhc2UoaW5kZXgpO1xyXG4gICAgICAgICAgICBlYXNpbmcgPSBzcGVjaWFsRWFzaW5nW25hbWVdO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzW2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSB2YWx1ZVsxXTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcHNbaW5kZXhdID0gdmFsdWVbMF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1tpbmRleF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAoaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBob29rcy5leHBhbmQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHByb3BzW25hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cclxuICAgICAgICAgICAgICAgIC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcclxuICAgICAgICAgICAgICAgIGZvciAoaW5kZXggaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpbmRleCBpbiBwcm9wcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbaW5kZXhdID0gdmFsdWVbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsRWFzaW5nW2luZGV4XSA9IGVhc2luZztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzcGVjaWFsRWFzaW5nW25hbWVdID0gZWFzaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbihlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCxcclxuICAgICAgICAgICAgc3RvcHBlZCxcclxuICAgICAgICAgICAgaW5kZXggPSAwLFxyXG4gICAgICAgICAgICBsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXHJcbiAgICAgICAgICAgIGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aWNrLmVsZW07XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICB0aWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IE1hdGgubWF4KDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSksXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcclxuICAgICAgICAgICAgICAgICAgICAvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAxIC0gdGVtcCxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVuc1tpbmRleF0ucnVuKHBlcmNlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxyXG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxICYmIGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1haW5pbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIWxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgMSwgMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aChlbGVtLCBbYW5pbWF0aW9uXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2Uoe1xyXG4gICAgICAgICAgICAgICAgZWxlbTogZWxlbSxcclxuICAgICAgICAgICAgICAgIHByb3BzOiBqUXVlcnkuZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzKSxcclxuICAgICAgICAgICAgICAgIG9wdHM6IGpRdWVyeS5leHRlbmQodHJ1ZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmc6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyksXHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcclxuICAgICAgICAgICAgICAgIHR3ZWVuczogW10sXHJcbiAgICAgICAgICAgICAgICBjcmVhdGVUd2VlbjogZnVuY3Rpb24gKHByb3AsIGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbihlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nW3Byb3BdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVucy5wdXNoKHR3ZWVuKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW47XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKGdvdG9FbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAwLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVuc1tpbmRleF0ucnVuKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3RcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZ290b0VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoKGVsZW0sIFthbmltYXRpb24sIDEsIDBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgZ290b0VuZF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdFdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgZ290b0VuZF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xyXG5cclxuICAgICAgICBwcm9wRmlsdGVyKHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nKTtcclxuXHJcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzW2luZGV4XS5jYWxsKGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocmVzdWx0LnN0b3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9xdWV1ZUhvb2tzKGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSkuc3RvcCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdG9wLmJpbmQocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGpRdWVyeS5tYXAocHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24pO1xyXG5cclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihhbmltYXRpb24ub3B0cy5zdGFydCkpIHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbChlbGVtLCBhbmltYXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcclxuICAgICAgICBhbmltYXRpb25cclxuICAgICAgICAgICAgLnByb2dyZXNzKGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzKVxyXG4gICAgICAgICAgICAuZG9uZShhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSlcclxuICAgICAgICAgICAgLmZhaWwoYW5pbWF0aW9uLm9wdHMuZmFpbClcclxuICAgICAgICAgICAgLmFsd2F5cyhhbmltYXRpb24ub3B0cy5hbHdheXMpO1xyXG5cclxuICAgICAgICBqUXVlcnkuZngudGltZXIoXHJcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodGljaywge1xyXG4gICAgICAgICAgICAgICAgZWxlbTogZWxlbSxcclxuICAgICAgICAgICAgICAgIGFuaW06IGFuaW1hdGlvbixcclxuICAgICAgICAgICAgICAgIHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiBhbmltYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgalF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoQW5pbWF0aW9uLCB7XHJcblxyXG4gICAgICAgIHR3ZWVuZXJzOiB7XHJcbiAgICAgICAgICAgIFwiKlwiOiBbZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKHByb3AsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGFkanVzdENTUyh0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWModmFsdWUpLCB0d2Vlbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW47XHJcbiAgICAgICAgICAgIH1dXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdHdlZW5lcjogZnVuY3Rpb24gKHByb3BzLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wcykpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcHJvcHM7XHJcbiAgICAgICAgICAgICAgICBwcm9wcyA9IFtcIipcIl07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wcyA9IHByb3BzLm1hdGNoKHJub3RodG1sd2hpdGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcHJvcCxcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gMCxcclxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgcHJvcCA9IHByb3BzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIEFuaW1hdGlvbi50d2VlbmVyc1twcm9wXSA9IEFuaW1hdGlvbi50d2VlbmVyc1twcm9wXSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIEFuaW1hdGlvbi50d2VlbmVyc1twcm9wXS51bnNoaWZ0KGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHByZWZpbHRlcnM6IFtkZWZhdWx0UHJlZmlsdGVyXSxcclxuXHJcbiAgICAgICAgcHJlZmlsdGVyOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHByZXBlbmQpIHtcclxuICAgICAgICAgICAgaWYgKHByZXBlbmQpIHtcclxuICAgICAgICAgICAgICAgIEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiAoc3BlZWQsIGVhc2luZywgZm4pIHtcclxuICAgICAgICB2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCh7fSwgc3BlZWQpIDoge1xyXG4gICAgICAgICAgICBjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxyXG4gICAgICAgICAgICAgICAgaXNGdW5jdGlvbihzcGVlZCkgJiYgc3BlZWQsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBzcGVlZCxcclxuICAgICAgICAgICAgZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKGVhc2luZykgJiYgZWFzaW5nXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXHJcbiAgICAgICAgaWYgKGpRdWVyeS5meC5vZmYpIHtcclxuICAgICAgICAgICAgb3B0LmR1cmF0aW9uID0gMDtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbb3B0LmR1cmF0aW9uXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxyXG4gICAgICAgIGlmIChvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgb3B0LnF1ZXVlID0gXCJmeFwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUXVldWVpbmdcclxuICAgICAgICBvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xyXG5cclxuICAgICAgICBvcHQuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdC5vbGQpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHQub2xkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvcHQucXVldWUpIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKHRoaXMsIG9wdC5xdWV1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gb3B0O1xyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICBmYWRlVG86IGZ1bmN0aW9uIChzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaXNIaWRkZW5XaXRoaW5UcmVlKS5jc3MoXCJvcGFjaXR5XCIsIDApLnNob3coKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxyXG4gICAgICAgICAgICAgICAgLmVuZCgpLmFuaW1hdGUoeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhbmltYXRlOiBmdW5jdGlvbiAocHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QocHJvcCksXHJcbiAgICAgICAgICAgICAgICBvcHRhbGwgPSBqUXVlcnkuc3BlZWQoc3BlZWQsIGVhc2luZywgY2FsbGJhY2spLFxyXG4gICAgICAgICAgICAgICAgZG9BbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW0gPSBBbmltYXRpb24odGhpcywgalF1ZXJ5LmV4dGVuZCh7fSwgcHJvcCksIG9wdGFsbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbXB0eSB8fCBkYXRhUHJpdi5nZXQodGhpcywgXCJmaW5pc2hcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbS5zdG9wKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGRvQW5pbWF0aW9uKSA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlKG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQpIHtcclxuICAgICAgICAgICAgdmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uIChob29rcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBob29rcy5zdG9wO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGhvb2tzLnN0b3A7XHJcbiAgICAgICAgICAgICAgICBzdG9wKGdvdG9FbmQpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICBnb3RvRW5kID0gY2xlYXJRdWV1ZTtcclxuICAgICAgICAgICAgICAgIGNsZWFyUXVldWUgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZSh0eXBlIHx8IFwiZnhcIiwgW10pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZXF1ZXVlID0gdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycyxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVByaXYuZ2V0KHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2luZGV4XSAmJiBkYXRhW2luZGV4XS5zdG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BRdWV1ZShkYXRhW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGluZGV4IGluIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaW5kZXhdICYmIGRhdGFbaW5kZXhdLnN0b3AgJiYgcnJ1bi50ZXN0KGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFF1ZXVlKGRhdGFbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXJzW2luZGV4XS5lbGVtID09PSB0aGlzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlID09IG51bGwgfHwgdGltZXJzW2luZGV4XS5xdWV1ZSA9PT0gdHlwZSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyc1tpbmRleF0uYW5pbS5zdG9wKGdvdG9FbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXF1ZXVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxyXG4gICAgICAgICAgICAgICAgLy8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxyXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxyXG4gICAgICAgICAgICAgICAgaWYgKGRlcXVldWUgfHwgIWdvdG9FbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCB0eXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhUHJpdi5nZXQodGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBkYXRhW3R5cGUgKyBcInF1ZXVlXCJdLFxyXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0gZGF0YVt0eXBlICsgXCJxdWV1ZUhvb2tzXCJdLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcclxuICAgICAgICAgICAgICAgIGRhdGEuZmluaXNoID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3RcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5xdWV1ZSh0aGlzLCB0eXBlLCBbXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGhvb2tzICYmIGhvb2tzLnN0b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBob29rcy5zdG9wLmNhbGwodGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cclxuICAgICAgICAgICAgICAgIGZvciAoaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcnNbaW5kZXhdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzW2luZGV4XS5xdWV1ZSA9PT0gdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnNbaW5kZXhdLmFuaW0uc3RvcCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXHJcbiAgICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocXVldWVbaW5kZXhdICYmIHF1ZXVlW2luZGV4XS5maW5pc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbaW5kZXhdLmZpbmlzaC5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGEuZmluaXNoO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZWFjaChbXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiXSwgZnVuY3Rpb24gKGksIG5hbWUpIHtcclxuICAgICAgICB2YXIgY3NzRm4gPSBqUXVlcnkuZm5bbmFtZV07XHJcbiAgICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xyXG4gICAgICAgICAgICAgICAgY3NzRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGUoZ2VuRngobmFtZSwgdHJ1ZSksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xyXG4gICAgalF1ZXJ5LmVhY2goe1xyXG4gICAgICAgIHNsaWRlRG93bjogZ2VuRngoXCJzaG93XCIpLFxyXG4gICAgICAgIHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcclxuICAgICAgICBzbGlkZVRvZ2dsZTogZ2VuRngoXCJ0b2dnbGVcIiksXHJcbiAgICAgICAgZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXHJcbiAgICAgICAgZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxyXG4gICAgICAgIGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XHJcbiAgICB9LCBmdW5jdGlvbiAobmFtZSwgcHJvcHMpIHtcclxuICAgICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbiAoc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZShwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkudGltZXJzID0gW107XHJcbiAgICBqUXVlcnkuZngudGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGltZXIsXHJcbiAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICB0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xyXG5cclxuICAgICAgICBmeE5vdyA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRpbWVyID0gdGltZXJzW2ldO1xyXG5cclxuICAgICAgICAgICAgLy8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxyXG4gICAgICAgICAgICBpZiAoIXRpbWVyKCkgJiYgdGltZXJzW2ldID09PSB0aW1lcikge1xyXG4gICAgICAgICAgICAgICAgdGltZXJzLnNwbGljZShpLS0sIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRpbWVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgalF1ZXJ5LmZ4LnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnhOb3cgPSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xyXG4gICAgICAgIGpRdWVyeS50aW1lcnMucHVzaCh0aW1lcik7XHJcbiAgICAgICAgalF1ZXJ5LmZ4LnN0YXJ0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xyXG4gICAgalF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChpblByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluUHJvZ3Jlc3MgPSB0cnVlO1xyXG4gICAgICAgIHNjaGVkdWxlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGluUHJvZ3Jlc3MgPSBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkuZnguc3BlZWRzID0ge1xyXG4gICAgICAgIHNsb3c6IDYwMCxcclxuICAgICAgICBmYXN0OiAyMDAsXHJcblxyXG4gICAgICAgIC8vIERlZmF1bHQgc3BlZWRcclxuICAgICAgICBfZGVmYXVsdDogNDAwXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXHJcbiAgICAvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xyXG4gICAgalF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24gKHRpbWUsIHR5cGUpIHtcclxuICAgICAgICB0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1t0aW1lXSB8fCB0aW1lIDogdGltZTtcclxuICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKHR5cGUsIGZ1bmN0aW9uIChuZXh0LCBob29rcykge1xyXG4gICAgICAgICAgICB2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KG5leHQsIHRpbWUpO1xyXG4gICAgICAgICAgICBob29rcy5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLFxyXG4gICAgICAgICAgICBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpLFxyXG4gICAgICAgICAgICBvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSk7XHJcblxyXG4gICAgICAgIGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XHJcblxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxyXG4gICAgICAgIC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxyXG4gICAgICAgIHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcclxuICAgICAgICAvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxyXG4gICAgICAgIHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XHJcblxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxyXG4gICAgICAgIC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXHJcbiAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcbiAgICAgICAgaW5wdXQudmFsdWUgPSBcInRcIjtcclxuICAgICAgICBpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xyXG4gICAgICAgIHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIHZhciBib29sSG9vayxcclxuICAgICAgICBhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICBhdHRyOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZW1vdmVBdHRyOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKHRoaXMsIG5hbWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZXh0ZW5kKHtcclxuICAgICAgICBhdHRyOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHJldCwgaG9va3MsXHJcbiAgICAgICAgICAgICAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XHJcblxyXG4gICAgICAgICAgICAvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXHJcbiAgICAgICAgICAgIGlmIChuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnByb3AoZWxlbSwgbmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXHJcbiAgICAgICAgICAgIC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcclxuICAgICAgICAgICAgaWYgKG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoZWxlbSkpIHtcclxuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1tuYW1lLnRvTG93ZXJDYXNlKCldIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdChuYW1lKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKGVsZW0sIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChyZXQgPSBob29rcy5zZXQoZWxlbSwgdmFsdWUsIG5hbWUpKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSArIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KGVsZW0sIG5hbWUpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0ID0galF1ZXJ5LmZpbmQuYXR0cihlbGVtLCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhdHRySG9va3M6IHtcclxuICAgICAgICAgICAgdHlwZToge1xyXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoZWxlbSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lKGVsZW0sIFwiaW5wdXRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGVsZW0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKFwidHlwZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0udmFsdWUgPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSxcclxuICAgICAgICAgICAgICAgIGkgPSAwLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxyXG4gICAgICAgICAgICAgICAgYXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2gocm5vdGh0bWx3aGl0ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgobmFtZSA9IGF0dHJOYW1lc1tpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xyXG4gICAgYm9vbEhvb2sgPSB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZWxlbSwgdmFsdWUsIG5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2VcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKGVsZW0sIG5hbWUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUobmFtZSwgbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkuZWFjaChqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXFx3Ky9nKSwgZnVuY3Rpb24gKGksIG5hbWUpIHtcclxuICAgICAgICB2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVtuYW1lXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xyXG5cclxuICAgICAgICBhdHRySGFuZGxlW25hbWVdID0gZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XHJcbiAgICAgICAgICAgIHZhciByZXQsIGhhbmRsZSxcclxuICAgICAgICAgICAgICAgIGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWlzWE1MKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxyXG4gICAgICAgICAgICAgICAgaGFuZGxlID0gYXR0ckhhbmRsZVtsb3dlcmNhc2VOYW1lXTtcclxuICAgICAgICAgICAgICAgIGF0dHJIYW5kbGVbbG93ZXJjYXNlTmFtZV0gPSByZXQ7XHJcbiAgICAgICAgICAgICAgICByZXQgPSBnZXR0ZXIoZWxlbSwgbmFtZSwgaXNYTUwpICE9IG51bGwgP1xyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VyY2FzZU5hbWUgOlxyXG4gICAgICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgICAgICAgICBhdHRySGFuZGxlW2xvd2VyY2FzZU5hbWVdID0gaGFuZGxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuXHJcblxyXG5cclxuICAgIHZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcclxuICAgICAgICByY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xyXG5cclxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgICAgIHByb3A6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbW92ZVByb3A6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbalF1ZXJ5LnByb3BGaXhbbmFtZV0gfHwgbmFtZV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGpRdWVyeS5leHRlbmQoe1xyXG4gICAgICAgIHByb3A6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgcmV0LCBob29rcyxcclxuICAgICAgICAgICAgICAgIG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcclxuXHJcbiAgICAgICAgICAgIC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcclxuICAgICAgICAgICAgaWYgKG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKGVsZW0pKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5wcm9wRml4W25hbWVdIHx8IG5hbWU7XHJcbiAgICAgICAgICAgICAgICBob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChyZXQgPSBob29rcy5zZXQoZWxlbSwgdmFsdWUsIG5hbWUpKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGVsZW1bbmFtZV0gPSB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoZWxlbSwgbmFtZSkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZWxlbVtuYW1lXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwcm9wSG9va3M6IHtcclxuICAgICAgICAgICAgdGFiSW5kZXg6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0cihlbGVtLCBcInRhYmluZGV4XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFiaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRhYmluZGV4LCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJmb2N1c2FibGUudGVzdChlbGVtLm5vZGVOYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByY2xpY2thYmxlLnRlc3QoZWxlbS5ub2RlTmFtZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5ocmVmXHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcHJvcEZpeDoge1xyXG4gICAgICAgICAgICBcImZvclwiOiBcImh0bWxGb3JcIixcclxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XHJcbiAgICAvLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcclxuICAgIC8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcclxuICAgIC8vIG9uIHRoZSBvcHRpb25cclxuICAgIC8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXHJcbiAgICAvLyB3aGVuIGluIGFuIG9wdGdyb3VwXHJcbiAgICAvLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcclxuICAgIC8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxyXG4gICAgaWYgKCFzdXBwb3J0Lm9wdFNlbGVjdGVkKSB7XHJcbiAgICAgICAgalF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxlbSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoZWxlbSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5zZWxlY3RlZEluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGpRdWVyeS5lYWNoKFtcclxuICAgICAgICBcInRhYkluZGV4XCIsXHJcbiAgICAgICAgXCJyZWFkT25seVwiLFxyXG4gICAgICAgIFwibWF4TGVuZ3RoXCIsXHJcbiAgICAgICAgXCJjZWxsU3BhY2luZ1wiLFxyXG4gICAgICAgIFwiY2VsbFBhZGRpbmdcIixcclxuICAgICAgICBcInJvd1NwYW5cIixcclxuICAgICAgICBcImNvbFNwYW5cIixcclxuICAgICAgICBcInVzZU1hcFwiLFxyXG4gICAgICAgIFwiZnJhbWVCb3JkZXJcIixcclxuICAgICAgICBcImNvbnRlbnRFZGl0YWJsZVwiXHJcbiAgICBdLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgalF1ZXJ5LnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXSA9IHRoaXM7XHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuXHJcbiAgICAvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXHJcbiAgICAvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2VcclxuICAgIGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UodmFsdWUpIHtcclxuICAgICAgICB2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW107XHJcbiAgICAgICAgcmV0dXJuIHRva2Vucy5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q2xhc3MoZWxlbSkge1xyXG4gICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkodmFsdWUpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgaSA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGopIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykuYWRkQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBqLCBnZXRDbGFzcyh0aGlzKSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSh2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY2xhc3Nlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IHRoaXNbaSsrXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJWYWx1ZSA9IGdldENsYXNzKGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZShjdXJWYWx1ZSkgKyBcIiBcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW2orK10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLmluZGV4T2YoXCIgXCIgKyBjbGF6eiArIFwiIFwiKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgKz0gY2xhenogKyBcIiBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoY3VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clZhbHVlICE9PSBmaW5hbFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGZpbmFsVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcclxuICAgICAgICAgICAgICAgIGkgPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnJlbW92ZUNsYXNzKHZhbHVlLmNhbGwodGhpcywgaiwgZ2V0Q2xhc3ModGhpcykpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoXCJjbGFzc1wiLCBcIlwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjbGFzc2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gdGhpc1tpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1clZhbHVlID0gZ2V0Q2xhc3MoZWxlbSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKGN1clZhbHVlKSArIFwiIFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjbGF6eiA9IGNsYXNzZXNbaisrXSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VyLmluZGV4T2YoXCIgXCIgKyBjbGF6eiArIFwiIFwiKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLnJlcGxhY2UoXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKGN1cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBmaW5hbFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGVWYWwpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKHZhbHVlKSA6IHRoaXMucmVtb3ZlQ2xhc3ModmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykudG9nZ2xlQ2xhc3MoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmNhbGwodGhpcywgaSwgZ2V0Q2xhc3ModGhpcyksIHN0YXRlVmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVWYWxcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFZhbHVlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IGpRdWVyeSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkodmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbaSsrXSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNDbGFzcyhjbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZENsYXNzKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcyh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnNldCh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXRBdHRyaWJ1dGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuZ2V0KHRoaXMsIFwiX19jbGFzc05hbWVfX1wiKSB8fCBcIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUsIGVsZW0sXHJcbiAgICAgICAgICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcclxuICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gdGhpc1tpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICAoXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKGdldENsYXNzKGVsZW0pKSArIFwiIFwiKS5pbmRleE9mKGNsYXNzTmFtZSkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG4gICAgdmFyIHJyZXR1cm4gPSAvXFxyL2c7XHJcblxyXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICAgICAgdmFsOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcclxuICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWzBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzW2VsZW0udHlwZV0gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnZhbEhvb2tzW2VsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChob29rcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcImdldFwiIGluIGhvb2tzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZXQgPSBob29rcy5nZXQoZWxlbSwgXCJ2YWx1ZVwiKSkgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gZWxlbS52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQucmVwbGFjZShycmV0dXJuLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWw7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlSXNGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbHVlLmNhbGwodGhpcywgaSwgalF1ZXJ5KHRoaXMpLnZhbCgpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gXCJcIjtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gXCJcIjtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGpRdWVyeS5tYXAodmFsLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzW3RoaXMudHlwZV0gfHwgalF1ZXJ5LnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcclxuICAgICAgICAgICAgICAgIGlmICghaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCBob29rcy5zZXQodGhpcywgdmFsLCBcInZhbHVlXCIpID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZXh0ZW5kKHtcclxuICAgICAgICB2YWxIb29rczoge1xyXG4gICAgICAgICAgICBvcHRpb246IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoZWxlbSwgXCJ2YWx1ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsICE9IG51bGwgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpcEFuZENvbGxhcHNlKGpRdWVyeS50ZXh0KGVsZW0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2VsZWN0OiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlLCBvcHRpb24sIGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBvbmUgPyBpbmRleCA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4KSAmJlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFvcHRpb24uZGlzYWJsZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbm9kZU5hbWUob3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIikpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBqUXVlcnkob3B0aW9uKS52YWwoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25TZXQsIG9wdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSh2YWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBvcHRpb25zLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmluQXJyYXkoalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQob3B0aW9uKSwgdmFsdWVzKSA+IC0xXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvblNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXHJcbiAgICBqUXVlcnkuZWFjaChbXCJyYWRpb1wiLCBcImNoZWNrYm94XCJdLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgalF1ZXJ5LnZhbEhvb2tzW3RoaXNdID0ge1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheShqUXVlcnkoZWxlbSkudmFsKCksIHZhbHVlKSA+IC0xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFzdXBwb3J0LmNoZWNrT24pIHtcclxuICAgICAgICAgICAgalF1ZXJ5LnZhbEhvb2tzW3RoaXNdLmdldCA9IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG4gICAgLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxyXG5cclxuXHJcbiAgICBzdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcclxuXHJcblxyXG4gICAgdmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxyXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgIGpRdWVyeS5leHRlbmQoalF1ZXJ5LmV2ZW50LCB7XHJcblxyXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcclxuICAgICAgICAgICAgICAgIGV2ZW50UGF0aCA9IFtlbGVtIHx8IGRvY3VtZW50XSxcclxuICAgICAgICAgICAgICAgIHR5cGUgPSBoYXNPd24uY2FsbChldmVudCwgXCJ0eXBlXCIpID8gZXZlbnQudHlwZSA6IGV2ZW50LFxyXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKGV2ZW50LCBcIm5hbWVzcGFjZVwiKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdChcIi5cIikgOiBbXTtcclxuXHJcbiAgICAgICAgICAgIGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xyXG4gICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xyXG4gICAgICAgICAgICBpZiAocmZvY3VzTW9ycGgudGVzdCh0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGUuaW5kZXhPZihcIi5cIikgPiAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcclxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KFwiLlwiKTtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzLnNvcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvbnR5cGUgPSB0eXBlLmluZGV4T2YoXCI6XCIpIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRbalF1ZXJ5LmV4cGFuZG9dID9cclxuICAgICAgICAgICAgICAgIGV2ZW50IDpcclxuICAgICAgICAgICAgICAgIG5ldyBqUXVlcnkuRXZlbnQodHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcclxuICAgICAgICAgICAgZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XHJcbiAgICAgICAgICAgIGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbihcIi5cIik7XHJcbiAgICAgICAgICAgIGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xyXG4gICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiKSA6XHJcbiAgICAgICAgICAgICAgICBudWxsO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXHJcbiAgICAgICAgICAgIGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKCFldmVudC50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGVsZW07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3RcclxuICAgICAgICAgICAgZGF0YSA9IGRhdGEgPT0gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICBbZXZlbnRdIDpcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5tYWtlQXJyYXkoZGF0YSwgW2V2ZW50XSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXHJcbiAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTtcclxuICAgICAgICAgICAgaWYgKCFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseShlbGVtLCBkYXRhKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXHJcbiAgICAgICAgICAgIC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXHJcbiAgICAgICAgICAgIGlmICghb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyhlbGVtKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZm9jdXNNb3JwaC50ZXN0KGJ1YmJsZVR5cGUgKyB0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICg7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudFBhdGgucHVzaChjdXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IGN1cjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcclxuICAgICAgICAgICAgICAgIGlmICh0bXAgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXRoLnB1c2godG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKChjdXIgPSBldmVudFBhdGhbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gY3VyO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IGkgPiAxID9cclxuICAgICAgICAgICAgICAgICAgICBidWJibGVUeXBlIDpcclxuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8galF1ZXJ5IGhhbmRsZXJcclxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IChkYXRhUHJpdi5nZXQoY3VyLCBcImV2ZW50c1wiKSB8fCB7fSlbZXZlbnQudHlwZV0gJiZcclxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5nZXQoY3VyLCBcImhhbmRsZVwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuYXBwbHkoY3VyLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOYXRpdmUgaGFuZGxlclxyXG4gICAgICAgICAgICAgICAgaGFuZGxlID0gb250eXBlICYmIGN1cltvbnR5cGVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YShjdXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KGN1ciwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXZlbnQudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XHJcbiAgICAgICAgICAgIGlmICghb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgoIXNwZWNpYWwuX2RlZmF1bHQgfHxcclxuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KGV2ZW50UGF0aC5wb3AoKSwgZGF0YSkgPT09IGZhbHNlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdERhdGEoZWxlbSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9udHlwZSAmJiBpc0Z1bmN0aW9uKGVsZW1bdHlwZV0pICYmICFpc1dpbmRvdyhlbGVtKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBlbGVtW29udHlwZV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtW29udHlwZV0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVt0eXBlXSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVtvbnR5cGVdID0gdG1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucmVzdWx0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxyXG4gICAgICAgIC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXHJcbiAgICAgICAgc2ltdWxhdGU6IGZ1bmN0aW9uICh0eXBlLCBlbGVtLCBldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IGpRdWVyeS5leHRlbmQoXHJcbiAgICAgICAgICAgICAgICBuZXcgalF1ZXJ5LkV2ZW50KCksXHJcbiAgICAgICAgICAgICAgICBldmVudCxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU2ltdWxhdGVkOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihlLCBudWxsLCBlbGVtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIodHlwZSwgZGF0YSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtID0gdGhpc1swXTtcclxuICAgICAgICAgICAgaWYgKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlcih0eXBlLCBkYXRhLCBlbGVtLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcclxuICAgIC8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcclxuICAgIC8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XHJcbiAgICAvL1xyXG4gICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXHJcbiAgICAvLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcclxuICAgIC8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxyXG4gICAgLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcclxuICAgIGlmICghc3VwcG9ydC5mb2N1c2luKSB7XHJcbiAgICAgICAgalF1ZXJ5LmVhY2goeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiAob3JpZywgZml4KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxyXG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KGV2ZW50KSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFtmaXhdID0ge1xyXG4gICAgICAgICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKGRvYywgZml4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRhY2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihvcmlnLCBoYW5kbGVyLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuYWNjZXNzKGRvYywgZml4LCAoYXR0YWNoZXMgfHwgMCkgKyAxKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoZG9jLCBmaXgpIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRhY2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihvcmlnLCBoYW5kbGVyLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYucmVtb3ZlKGRvYywgZml4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuYWNjZXNzKGRvYywgZml4LCBhdHRhY2hlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xyXG5cclxuICAgIHZhciBub25jZSA9IERhdGUubm93KCk7XHJcblxyXG4gICAgdmFyIHJxdWVyeSA9ICgvXFw/Lyk7XHJcblxyXG5cclxuXHJcbiAgICAvLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXHJcbiAgICBqUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHZhciB4bWw7XHJcbiAgICAgICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcclxuICAgICAgICAvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB4bWwgPSAobmV3IHdpbmRvdy5ET01QYXJzZXIoKSkucGFyc2VGcm9tU3RyaW5nKGRhdGEsIFwidGV4dC94bWxcIik7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB4bWwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXJzZXJlcnJvclwiKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgalF1ZXJ5LmVycm9yKFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB4bWw7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICB2YXJcclxuICAgICAgICByYnJhY2tldCA9IC9cXFtcXF0kLyxcclxuICAgICAgICByQ1JMRiA9IC9cXHI/XFxuL2csXHJcbiAgICAgICAgcnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxyXG4gICAgICAgIHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcclxuXHJcbiAgICBmdW5jdGlvbiBidWlsZFBhcmFtcyhwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCkge1xyXG4gICAgICAgIHZhciBuYW1lO1xyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cclxuICAgICAgICAgICAgalF1ZXJ5LmVhY2gob2JqLCBmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QocHJlZml4KSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKHByZWZpeCwgdik7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXHJcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCArIFwiW1wiICsgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiKSArIFwiXVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFkaXRpb25hbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIXRyYWRpdGlvbmFsICYmIHRvVHlwZShvYmopID09PSBcIm9iamVjdFwiKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXHJcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbbmFtZV0sIHRyYWRpdGlvbmFsLCBhZGQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXHJcbiAgICAgICAgICAgIGFkZChwcmVmaXgsIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXHJcbiAgICAvLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcclxuICAgIGpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uIChhLCB0cmFkaXRpb25hbCkge1xyXG4gICAgICAgIHZhciBwcmVmaXgsXHJcbiAgICAgICAgICAgIHMgPSBbXSxcclxuICAgICAgICAgICAgYWRkID0gZnVuY3Rpb24gKGtleSwgdmFsdWVPckZ1bmN0aW9uKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaXNGdW5jdGlvbih2YWx1ZU9yRnVuY3Rpb24pID9cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZU9yRnVuY3Rpb24oKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVPckZ1bmN0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgIHNbcy5sZW5ndGhdID0gZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyBcIj1cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpIHx8IChhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoYSkpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcclxuICAgICAgICAgICAgalF1ZXJ5LmVhY2goYSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgYWRkKHRoaXMubmFtZSwgdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcclxuICAgICAgICAgICAgLy8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXHJcbiAgICAgICAgICAgIGZvciAocHJlZml4IGluIGEpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCwgYVtwcmVmaXhdLCB0cmFkaXRpb25hbCwgYWRkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxyXG4gICAgICAgIHJldHVybiBzLmpvaW4oXCImXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCh0aGlzLCBcImVsZW1lbnRzXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheShlbGVtZW50cykgOiB0aGlzO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSh0aGlzKS5pcyhcIjpkaXNhYmxlZFwiKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByc3VibWl0dGFibGUudGVzdCh0aGlzLm5vZGVOYW1lKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QodHlwZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCh0eXBlKSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaSwgZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBqUXVlcnkodGhpcykudmFsKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5tYXAodmFsLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZShyQ1JMRiwgXCJcXHJcXG5cIikgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZShyQ1JMRiwgXCJcXHJcXG5cIikgfTtcclxuICAgICAgICAgICAgICAgIH0pLmdldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICB2YXJcclxuICAgICAgICByMjAgPSAvJTIwL2csXHJcbiAgICAgICAgcmhhc2ggPSAvIy4qJC8sXHJcbiAgICAgICAgcmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcclxuICAgICAgICByaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXHJcblxyXG4gICAgICAgIC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxyXG4gICAgICAgIHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXHJcbiAgICAgICAgcm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXHJcbiAgICAgICAgcnByb3RvY29sID0gL15cXC9cXC8vLFxyXG5cclxuICAgICAgICAvKiBQcmVmaWx0ZXJzXHJcbiAgICAgICAgICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcclxuICAgICAgICAgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxyXG4gICAgICAgICAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcclxuICAgICAgICAgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXHJcbiAgICAgICAgICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxyXG4gICAgICAgICAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcclxuICAgICAgICAgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByZWZpbHRlcnMgPSB7fSxcclxuXHJcbiAgICAgICAgLyogVHJhbnNwb3J0cyBiaW5kaW5nc1xyXG4gICAgICAgICAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcclxuICAgICAgICAgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXHJcbiAgICAgICAgICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdHJhbnNwb3J0cyA9IHt9LFxyXG5cclxuICAgICAgICAvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cclxuICAgICAgICBhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoXCIqXCIpLFxyXG5cclxuICAgICAgICAvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cclxuICAgICAgICBvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuICAgIG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcclxuXHJcbiAgICAvLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XHJcbiAgICBmdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoc3RydWN0dXJlKSB7XHJcblxyXG4gICAgICAgIC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYykge1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgICBkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGFUeXBlLFxyXG4gICAgICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGZ1bmMpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChkYXRhVHlwZSA9IGRhdGFUeXBlc1tpKytdKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVHlwZVswXSA9PT0gXCIrXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSgxKSB8fCBcIipcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHN0cnVjdHVyZVtkYXRhVHlwZV0gPSBzdHJ1Y3R1cmVbZGF0YVR5cGVdIHx8IFtdKS51bnNoaWZ0KGZ1bmMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGFwcGVuZFxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdHJ1Y3R1cmVbZGF0YVR5cGVdID0gc3RydWN0dXJlW2RhdGFUeXBlXSB8fCBbXSkucHVzaChmdW5jKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xyXG4gICAgZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSKSB7XHJcblxyXG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSB7fSxcclxuICAgICAgICAgICAgc2Vla2luZ1RyYW5zcG9ydCA9IChzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbnNwZWN0KGRhdGFUeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZDtcclxuICAgICAgICAgICAgaW5zcGVjdGVkW2RhdGFUeXBlXSA9IHRydWU7XHJcbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKHN0cnVjdHVyZVtkYXRhVHlwZV0gfHwgW10sIGZ1bmN0aW9uIChfLCBwcmVmaWx0ZXJPckZhY3RvcnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFtkYXRhVHlwZU9yVHJhbnNwb3J0XSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KGRhdGFUeXBlT3JUcmFuc3BvcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3BlY3QoZGF0YVR5cGVPclRyYW5zcG9ydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWVraW5nVHJhbnNwb3J0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEoc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpbnNwZWN0KG9wdGlvbnMuZGF0YVR5cGVzWzBdKSB8fCAhaW5zcGVjdGVkW1wiKlwiXSAmJiBpbnNwZWN0KFwiKlwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcclxuICAgIC8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXHJcbiAgICAvLyBGaXhlcyAjOTg4N1xyXG4gICAgZnVuY3Rpb24gYWpheEV4dGVuZCh0YXJnZXQsIHNyYykge1xyXG4gICAgICAgIHZhciBrZXksIGRlZXAsXHJcbiAgICAgICAgICAgIGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgZm9yIChrZXkgaW4gc3JjKSB7XHJcbiAgICAgICAgICAgIGlmIChzcmNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAoZmxhdE9wdGlvbnNba2V5XSA/IHRhcmdldCA6IChkZWVwIHx8IChkZWVwID0ge30pKSlba2V5XSA9IHNyY1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWVwKSB7XHJcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgdGFyZ2V0LCBkZWVwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxyXG4gICAgICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcclxuICAgICAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKHMsIGpxWEhSLCByZXNwb25zZXMpIHtcclxuXHJcbiAgICAgICAgdmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxyXG4gICAgICAgICAgICBjb250ZW50cyA9IHMuY29udGVudHMsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xyXG4gICAgICAgIHdoaWxlIChkYXRhVHlwZXNbMF0gPT09IFwiKlwiKSB7XHJcbiAgICAgICAgICAgIGRhdGFUeXBlcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpZiAoY3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcclxuICAgICAgICBpZiAoY3QpIHtcclxuICAgICAgICAgICAgZm9yICh0eXBlIGluIGNvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudHNbdHlwZV0gJiYgY29udGVudHNbdHlwZV0udGVzdChjdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZXMudW5zaGlmdCh0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXHJcbiAgICAgICAgaWYgKGRhdGFUeXBlc1swXSBpbiByZXNwb25zZXMpIHtcclxuICAgICAgICAgICAgZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1swXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xyXG4gICAgICAgICAgICBmb3IgKHR5cGUgaW4gcmVzcG9uc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGFUeXBlc1swXSB8fCBzLmNvbnZlcnRlcnNbdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWzBdXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdERhdGFUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REYXRhVHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxyXG4gICAgICAgICAgICBmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxyXG4gICAgICAgIC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXHJcbiAgICAgICAgLy8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxyXG4gICAgICAgIGlmIChmaW5hbERhdGFUeXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgIGRhdGFUeXBlcy51bnNoaWZ0KGZpbmFsRGF0YVR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZXNbZmluYWxEYXRhVHlwZV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcclxuICAgICAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhamF4Q29udmVydChzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2Vzcykge1xyXG4gICAgICAgIHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxyXG4gICAgICAgICAgICBjb252ZXJ0ZXJzID0ge30sXHJcblxyXG4gICAgICAgICAgICAvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXHJcbiAgICAgICAgICAgIGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xyXG4gICAgICAgIGlmIChkYXRhVHlwZXNbMV0pIHtcclxuICAgICAgICAgICAgZm9yIChjb252IGluIHMuY29udmVydGVycykge1xyXG4gICAgICAgICAgICAgICAgY29udmVydGVyc1tjb252LnRvTG93ZXJDYXNlKCldID0gcy5jb252ZXJ0ZXJzW2NvbnZdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChzLnJlc3BvbnNlRmllbGRzW2N1cnJlbnRdKSB7XHJcbiAgICAgICAgICAgICAgICBqcVhIUltzLnJlc3BvbnNlRmllbGRzW2N1cnJlbnRdXSA9IHJlc3BvbnNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxyXG4gICAgICAgICAgICBpZiAoIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIocmVzcG9uc2UsIHMuZGF0YVR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcmV2ID0gY3VycmVudDtcclxuICAgICAgICAgICAgY3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gXCIqXCIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHByZXY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnYgPSBjb252ZXJ0ZXJzW3ByZXYgKyBcIiBcIiArIGN1cnJlbnRdIHx8IGNvbnZlcnRlcnNbXCIqIFwiICsgY3VycmVudF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb252KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29udjIgaW4gY29udmVydGVycykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gY29udjIuc3BsaXQoXCIgXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtcFsxXSA9PT0gY3VycmVudCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ID0gY29udmVydGVyc1twcmV2ICsgXCIgXCIgKyB0bXBbMF1dIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRlcnNbXCIqIFwiICsgdG1wWzBdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbY29udjJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb252ZXJ0ZXJzW2NvbnYyXSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRtcFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlcy51bnNoaWZ0KHRtcFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udiAhPT0gdHJ1ZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udiAmJiBzLnRocm93cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBjb252KHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBjb252KHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XHJcbiAgICB9XHJcblxyXG4gICAgalF1ZXJ5LmV4dGVuZCh7XHJcblxyXG4gICAgICAgIC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xyXG4gICAgICAgIGFjdGl2ZTogMCxcclxuXHJcbiAgICAgICAgLy8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxyXG4gICAgICAgIGxhc3RNb2RpZmllZDoge30sXHJcbiAgICAgICAgZXRhZzoge30sXHJcblxyXG4gICAgICAgIGFqYXhTZXR0aW5nczoge1xyXG4gICAgICAgICAgICB1cmw6IGxvY2F0aW9uLmhyZWYsXHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QobG9jYXRpb24ucHJvdG9jb2wpLFxyXG4gICAgICAgICAgICBnbG9iYWw6IHRydWUsXHJcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICB0aW1lb3V0OiAwLFxyXG4gICAgICAgICAgICBkYXRhOiBudWxsLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogbnVsbCxcclxuICAgICAgICAgICAgdXNlcm5hbWU6IG51bGwsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiBudWxsLFxyXG4gICAgICAgICAgICBjYWNoZTogbnVsbCxcclxuICAgICAgICAgICAgdGhyb3dzOiBmYWxzZSxcclxuICAgICAgICAgICAgdHJhZGl0aW9uYWw6IGZhbHNlLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIGFjY2VwdHM6IHtcclxuICAgICAgICAgICAgICAgIFwiKlwiOiBhbGxUeXBlcyxcclxuICAgICAgICAgICAgICAgIHRleHQ6IFwidGV4dC9wbGFpblwiLFxyXG4gICAgICAgICAgICAgICAgaHRtbDogXCJ0ZXh0L2h0bWxcIixcclxuICAgICAgICAgICAgICAgIHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXHJcbiAgICAgICAgICAgICAgICBqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBjb250ZW50czoge1xyXG4gICAgICAgICAgICAgICAgeG1sOiAvXFxieG1sXFxiLyxcclxuICAgICAgICAgICAgICAgIGh0bWw6IC9cXGJodG1sLyxcclxuICAgICAgICAgICAgICAgIGpzb246IC9cXGJqc29uXFxiL1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgcmVzcG9uc2VGaWVsZHM6IHtcclxuICAgICAgICAgICAgICAgIHhtbDogXCJyZXNwb25zZVhNTFwiLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogXCJyZXNwb25zZVRleHRcIixcclxuICAgICAgICAgICAgICAgIGpzb246IFwicmVzcG9uc2VKU09OXCJcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIERhdGEgY29udmVydGVyc1xyXG4gICAgICAgICAgICAvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXHJcbiAgICAgICAgICAgIGNvbnZlcnRlcnM6IHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcclxuICAgICAgICAgICAgICAgIFwiKiB0ZXh0XCI6IFN0cmluZyxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcclxuICAgICAgICAgICAgICAgIFwidGV4dCBodG1sXCI6IHRydWUsXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0ZXh0IGFzIHhtbFxyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XHJcbiAgICAgICAgICAgIC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcclxuICAgICAgICAgICAgLy8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcclxuICAgICAgICAgICAgLy8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXHJcbiAgICAgICAgICAgIGZsYXRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICB1cmw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxyXG4gICAgICAgIC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cclxuICAgICAgICAvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxyXG4gICAgICAgIGFqYXhTZXR1cDogZnVuY3Rpb24gKHRhcmdldCwgc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzID9cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgYWpheEV4dGVuZChhamF4RXh0ZW5kKHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyksIHNldHRpbmdzKSA6XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgYWpheEV4dGVuZChqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyhwcmVmaWx0ZXJzKSxcclxuICAgICAgICBhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHModHJhbnNwb3J0cyksXHJcblxyXG4gICAgICAgIC8vIE1haW4gbWV0aG9kXHJcbiAgICAgICAgYWpheDogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgdmFyIHRyYW5zcG9ydCxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXHJcbiAgICAgICAgICAgICAgICBjYWNoZVVSTCxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXNwb25zZSBoZWFkZXJzXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdGltZW91dCBoYW5kbGVcclxuICAgICAgICAgICAgICAgIHRpbWVvdXRUaW1lcixcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcmwgY2xlYW51cCB2YXJcclxuICAgICAgICAgICAgICAgIHVybEFuY2hvcixcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQsXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXHJcbiAgICAgICAgICAgICAgICBmaXJlR2xvYmFscyxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMb29wIHZhcmlhYmxlXHJcbiAgICAgICAgICAgICAgICBpLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxyXG4gICAgICAgICAgICAgICAgdW5jYWNoZWQsXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgcyA9IGpRdWVyeS5hamF4U2V0dXAoe30sIG9wdGlvbnMpLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGxiYWNrcyBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcclxuICAgICAgICAgICAgICAgICAgICAoY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkpID9cclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoY2FsbGJhY2tDb250ZXh0KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERlZmVycmVkc1xyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcclxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzID0ge30sXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICBzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGYWtlIHhoclxyXG4gICAgICAgICAgICAgICAganFYSFIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZHlTdGF0ZTogMCxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgICAgIGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZUhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmhlYWRlcnMuZXhlYyhyZXNwb25zZUhlYWRlcnNTdHJpbmcpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNbbWF0Y2hbMV0udG9Mb3dlckNhc2UoKV0gPSBtYXRjaFsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmF3IHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZXMgdGhlIGhlYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzW25hbWUudG9Mb3dlckNhc2UoKV0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzTmFtZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5taW1lVHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSLmFsd2F5cyhtYXBbanFYSFIuc3RhdHVzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29kZSBpbiBtYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZVtjb2RlXSA9IFtzdGF0dXNDb2RlW2NvZGVdLCBtYXBbY29kZV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDYW5jZWwgdGhlIHJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKHN0YXR1c1RleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5hYm9ydChmaW5hbFRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoMCwgZmluYWxUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEF0dGFjaCBkZWZlcnJlZHNcclxuICAgICAgICAgICAgZGVmZXJyZWQucHJvbWlzZShqcVhIUik7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcclxuICAgICAgICAgICAgLy8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcclxuICAgICAgICAgICAgLy8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIHMudXJsID0gKCh1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZikgKyBcIlwiKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UocnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIik7XHJcblxyXG4gICAgICAgICAgICAvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcclxuICAgICAgICAgICAgcy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3RcclxuICAgICAgICAgICAgcy5kYXRhVHlwZXMgPSAocy5kYXRhVHlwZSB8fCBcIipcIikudG9Mb3dlckNhc2UoKS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXCJcIl07XHJcblxyXG4gICAgICAgICAgICAvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cclxuICAgICAgICAgICAgaWYgKHMuY3Jvc3NEb21haW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxyXG4gICAgICAgICAgICAgICAgLy8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcclxuICAgICAgICAgICAgICAgIC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgdXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcclxuICAgICAgICAgICAgICAgICAgICBzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXHJcbiAgICAgICAgICAgICAgICAgICAgcy5jcm9zc0RvbWFpbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xyXG4gICAgICAgICAgICBpZiAocy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgcy5kYXRhID0galF1ZXJ5LnBhcmFtKHMuZGF0YSwgcy50cmFkaXRpb25hbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGx5IHByZWZpbHRlcnNcclxuICAgICAgICAgICAgaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMocHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcclxuICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xyXG4gICAgICAgICAgICAvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxyXG4gICAgICAgICAgICBmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcclxuXHJcbiAgICAgICAgICAgIC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcclxuICAgICAgICAgICAgaWYgKGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RhcnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxyXG4gICAgICAgICAgICBzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XHJcbiAgICAgICAgICAgIHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3Qocy50eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxyXG4gICAgICAgICAgICAvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxyXG4gICAgICAgICAgICBjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2Uocmhhc2gsIFwiXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcclxuICAgICAgICAgICAgaWYgKCFzLmhhc0NvbnRlbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcclxuICAgICAgICAgICAgICAgIHVuY2FjaGVkID0gcy51cmwuc2xpY2UoY2FjaGVVUkwubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXHJcbiAgICAgICAgICAgICAgICBpZiAocy5kYXRhICYmIChzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVVUkwgKz0gKHJxdWVyeS50ZXN0KGNhY2hlVVJMKSA/IFwiJlwiIDogXCI/XCIpICsgcy5kYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHMuZGF0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBpZiAocy5jYWNoZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UocmFudGlDYWNoZSwgXCIkMVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB1bmNhY2hlZCA9IChycXVlcnkudGVzdChjYWNoZVVSTCkgPyBcIiZcIiA6IFwiP1wiKSArIFwiXz1cIiArIChub25jZSsrKSArIHVuY2FjaGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcclxuICAgICAgICAgICAgICAgIHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxyXG4gICAgICAgICAgICAgICAgKHMuY29udGVudFR5cGUgfHwgXCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcy5kYXRhID0gcy5kYXRhLnJlcGxhY2UocjIwLCBcIitcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXHJcbiAgICAgICAgICAgIGlmIChzLmlmTW9kaWZpZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkubGFzdE1vZGlmaWVkW2NhY2hlVVJMXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkW2NhY2hlVVJMXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmV0YWdbY2FjaGVVUkxdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbY2FjaGVVUkxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XHJcbiAgICAgICAgICAgIGlmIChzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcclxuICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihcclxuICAgICAgICAgICAgICAgIFwiQWNjZXB0XCIsXHJcbiAgICAgICAgICAgICAgICBzLmRhdGFUeXBlc1swXSAmJiBzLmFjY2VwdHNbcy5kYXRhVHlwZXNbMF1dID9cclxuICAgICAgICAgICAgICAgICAgICBzLmFjY2VwdHNbcy5kYXRhVHlwZXNbMF1dICtcclxuICAgICAgICAgICAgICAgICAgICAocy5kYXRhVHlwZXNbMF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgcy5hY2NlcHRzW1wiKlwiXVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXHJcbiAgICAgICAgICAgIGZvciAoaSBpbiBzLmhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoaSwgcy5oZWFkZXJzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxyXG4gICAgICAgICAgICBpZiAocy5iZWZvcmVTZW5kICYmXHJcbiAgICAgICAgICAgICAgICAocy5iZWZvcmVTZW5kLmNhbGwoY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcykgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgIHJldHVybiBqcVhIUi5hYm9ydCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cclxuICAgICAgICAgICAgc3RyQWJvcnQgPSBcImFib3J0XCI7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcclxuICAgICAgICAgICAgY29tcGxldGVEZWZlcnJlZC5hZGQocy5jb21wbGV0ZSk7XHJcbiAgICAgICAgICAgIGpxWEhSLmRvbmUocy5zdWNjZXNzKTtcclxuICAgICAgICAgICAganFYSFIuZmFpbChzLmVycm9yKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0cmFuc3BvcnRcclxuICAgICAgICAgICAgdHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHModHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XHJcbiAgICAgICAgICAgIGlmICghdHJhbnNwb3J0KSB7XHJcbiAgICAgICAgICAgICAgICBkb25lKC0xLCBcIk5vIFRyYW5zcG9ydFwiKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlbmQgZ2xvYmFsIGV2ZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyZUdsb2JhbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlcihcImFqYXhTZW5kXCIsIFtqcVhIUiwgc10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRpbWVvdXRcclxuICAgICAgICAgICAgICAgIGlmIChzLmFzeW5jICYmIHMudGltZW91dCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSLmFib3J0KFwidGltZW91dFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBzLnRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNlbmQocmVxdWVzdEhlYWRlcnMsIGRvbmUpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgtMSwgZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBkb25lKHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcclxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29tcGxldGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRUaW1lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dFRpbWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcclxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2V0IHJlYWR5U3RhdGVcclxuICAgICAgICAgICAgICAgIGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcclxuICAgICAgICAgICAgICAgIGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldCByZXNwb25zZSBkYXRhXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKHMsIGpxWEhSLCByZXNwb25zZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYWpheENvbnZlcnQocywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdWNjZXNzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuaWZNb2RpZmllZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkubGFzdE1vZGlmaWVkW2NhY2hlVVJMXSA9IG1vZGlmaWVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJldGFnXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldGFnW2NhY2hlVVJMXSA9IG1vZGlmaWVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgbW9kaWZpZWRcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gMzA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1N1Y2Nlc3MgPSAhZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gc3RhdHVzVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzIHx8ICFzdGF0dXNUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcImVycm9yXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICBqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XHJcbiAgICAgICAgICAgICAgICBqcVhIUi5zdGF0dXNUZXh0ID0gKG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCkgKyBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MvRXJyb3JcclxuICAgICAgICAgICAgICAgIGlmIChpc1N1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aChjYWxsYmFja0NvbnRleHQsIFtzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUl0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKGNhbGxiYWNrQ29udGV4dCwgW2pxWEhSLCBzdGF0dXNUZXh0LCBlcnJvcl0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXHJcbiAgICAgICAgICAgICAgICBqcVhIUi5zdGF0dXNDb2RlKHN0YXR1c0NvZGUpO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyZUdsb2JhbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlcihpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbanFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvcl0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlXHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKGNhbGxiYWNrQ29udGV4dCwgW2pxWEhSLCBzdGF0dXNUZXh0XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZpcmVHbG9iYWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoXCJhamF4Q29tcGxldGVcIiwgW2pxWEhSLCBzXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKC0talF1ZXJ5LmFjdGl2ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBqcVhIUjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRKU09OOiBmdW5jdGlvbiAodXJsLCBkYXRhLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdldCh1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0U2NyaXB0OiBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdldCh1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGpRdWVyeS5lYWNoKFtcImdldFwiLCBcInBvc3RcIl0sIGZ1bmN0aW9uIChpLCBtZXRob2QpIHtcclxuICAgICAgICBqUXVlcnlbbWV0aG9kXSA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihkYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hamF4KGpRdWVyeS5leHRlbmQoe1xyXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBtZXRob2QsXHJcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBjYWxsYmFja1xyXG4gICAgICAgICAgICB9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCh1cmwpICYmIHVybCkpO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgalF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgIHJldHVybiBqUXVlcnkuYWpheCh7XHJcbiAgICAgICAgICAgIHVybDogdXJsLFxyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcInNjcmlwdFwiLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IGZhbHNlLFxyXG4gICAgICAgICAgICBnbG9iYWw6IGZhbHNlLFxyXG4gICAgICAgICAgICBcInRocm93c1wiOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICB3cmFwQWxsOiBmdW5jdGlvbiAoaHRtbCkge1xyXG4gICAgICAgICAgICB2YXIgd3JhcDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihodG1sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgPSBodG1sLmNhbGwodGhpc1swXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcclxuICAgICAgICAgICAgICAgIHdyYXAgPSBqUXVlcnkoaHRtbCwgdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpc1swXS5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcC5pbnNlcnRCZWZvcmUodGhpc1swXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgd3JhcC5tYXAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbTtcclxuICAgICAgICAgICAgICAgIH0pLmFwcGVuZCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgd3JhcElubmVyOiBmdW5jdGlvbiAoaHRtbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihodG1sKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKS53cmFwSW5uZXIoaHRtbC5jYWxsKHRoaXMsIGkpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0galF1ZXJ5KHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cy53cmFwQWxsKGh0bWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBlbmQoaHRtbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHdyYXA6IGZ1bmN0aW9uIChodG1sKSB7XHJcbiAgICAgICAgICAgIHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oaHRtbCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykud3JhcEFsbChodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCh0aGlzLCBpKSA6IGh0bWwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB1bndyYXA6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudChzZWxlY3Rvcikubm90KFwiYm9keVwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIGpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICByZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZShlbGVtKTtcclxuICAgIH07XHJcbiAgICBqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgIHJldHVybiAhIShlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xyXG4gICAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgICBqUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcclxuXHJcbiAgICAgICAgLy8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcclxuICAgICAgICAwOiAyMDAsXHJcblxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XHJcbiAgICAgICAgLy8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XHJcbiAgICAgICAgMTIyMzogMjA0XHJcbiAgICB9LFxyXG4gICAgICAgIHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XHJcblxyXG4gICAgc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkKTtcclxuICAgIHN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xyXG5cclxuICAgIGpRdWVyeS5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xyXG5cclxuICAgICAgICAvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XHJcbiAgICAgICAgaWYgKHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uIChoZWFkZXJzLCBjb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIgPSBvcHRpb25zLnhocigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB4aHIub3BlbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5hc3luYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51c2VybmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXNzd29yZFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy54aHJGaWVsZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIG9wdGlvbnMueGhyRmllbGRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHJbaV0gPSBvcHRpb25zLnhockZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKG9wdGlvbnMubWltZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cclxuICAgICAgICAgICAgICAgICAgICAvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhlYWRlcnNcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gaGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCBoZWFkZXJzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFib3J0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImVycm9yXCIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoMCwgXCJlcnJvclwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1c1RleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoclN1Y2Nlc3NTdGF0dXNbeGhyLnN0YXR1c10gfHwgeGhyLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXNUZXh0LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIpICE9PSBcInRleHRcIiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExpc3RlbiB0byBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICB4aHIub25sb2FkID0gY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soXCJlcnJvclwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgOSBvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcclxuICAgICAgICAgICAgICAgICAgICAvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayhcImFib3J0XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG4gICAgLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcclxuICAgIGpRdWVyeS5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgaWYgKHMuY3Jvc3NEb21haW4pIHtcclxuICAgICAgICAgICAgcy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxyXG4gICAgalF1ZXJ5LmFqYXhTZXR1cCh7XHJcbiAgICAgICAgYWNjZXB0czoge1xyXG4gICAgICAgICAgICBzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXHJcbiAgICAgICAgICAgICAgICBcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb250ZW50czoge1xyXG4gICAgICAgICAgICBzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udmVydGVyczoge1xyXG4gICAgICAgICAgICBcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZ2xvYmFsRXZhbCh0ZXh0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxyXG4gICAgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIoXCJzY3JpcHRcIiwgZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICBpZiAocy5jYWNoZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHMuY2FjaGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHMuY3Jvc3NEb21haW4pIHtcclxuICAgICAgICAgICAgcy50eXBlID0gXCJHRVRcIjtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcclxuICAgIGpRdWVyeS5hamF4VHJhbnNwb3J0KFwic2NyaXB0XCIsIGZ1bmN0aW9uIChzKSB7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcclxuICAgICAgICBpZiAocy5jcm9zc0RvbWFpbikge1xyXG4gICAgICAgICAgICB2YXIgc2NyaXB0LCBjYWxsYmFjaztcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uIChfLCBjb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IGpRdWVyeShcIjxzY3JpcHQ+XCIpLnByb3Aoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogcy51cmxcclxuICAgICAgICAgICAgICAgICAgICB9KS5vbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJsb2FkIGVycm9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0WzBdKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgb2xkQ2FsbGJhY2tzID0gW10sXHJcbiAgICAgICAgcmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcclxuXHJcbiAgICAvLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXHJcbiAgICBqUXVlcnkuYWpheFNldHVwKHtcclxuICAgICAgICBqc29ucDogXCJjYWxsYmFja1wiLFxyXG4gICAgICAgIGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8IChqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKG5vbmNlKyspKTtcclxuICAgICAgICAgICAgdGhpc1tjYWxsYmFja10gPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXHJcbiAgICBqUXVlcnkuYWpheFByZWZpbHRlcihcImpzb24ganNvbnBcIiwgZnVuY3Rpb24gKHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSKSB7XHJcblxyXG4gICAgICAgIHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcclxuICAgICAgICAgICAganNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAocmpzb25wLnRlc3Qocy51cmwpID9cclxuICAgICAgICAgICAgICAgIFwidXJsXCIgOlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxyXG4gICAgICAgICAgICAgICAgKHMuY29udGVudFR5cGUgfHwgXCJcIilcclxuICAgICAgICAgICAgICAgICAgICAuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgcmpzb25wLnRlc3Qocy5kYXRhKSAmJiBcImRhdGFcIlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XHJcbiAgICAgICAgaWYgKGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWzBdID09PSBcImpzb25wXCIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcclxuICAgICAgICAgICAgY2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbihzLmpzb25wQ2FsbGJhY2spID9cclxuICAgICAgICAgICAgICAgIHMuanNvbnBDYWxsYmFjaygpIDpcclxuICAgICAgICAgICAgICAgIHMuanNvbnBDYWxsYmFjaztcclxuXHJcbiAgICAgICAgICAgIC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcclxuICAgICAgICAgICAgaWYgKGpzb25Qcm9wKSB7XHJcbiAgICAgICAgICAgICAgICBzW2pzb25Qcm9wXSA9IHNbanNvblByb3BdLnJlcGxhY2Uocmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHMuanNvbnAgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBzLnVybCArPSAocnF1ZXJ5LnRlc3Qocy51cmwpID8gXCImXCIgOiBcIj9cIikgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cclxuICAgICAgICAgICAgcy5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVycm9yKGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWzBdO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gRm9yY2UganNvbiBkYXRhVHlwZVxyXG4gICAgICAgICAgICBzLmRhdGFUeXBlc1swXSA9IFwianNvblwiO1xyXG5cclxuICAgICAgICAgICAgLy8gSW5zdGFsbCBjYWxsYmFja1xyXG4gICAgICAgICAgICBvdmVyd3JpdHRlbiA9IHdpbmRvd1tjYWxsYmFja05hbWVdO1xyXG4gICAgICAgICAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXHJcbiAgICAgICAgICAgIGpxWEhSLmFsd2F5cyhmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSh3aW5kb3cpLnJlbW92ZVByb3AoY2FsbGJhY2tOYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBvdmVyd3JpdHRlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTYXZlIGJhY2sgYXMgZnJlZVxyXG4gICAgICAgICAgICAgICAgaWYgKHNbY2FsbGJhY2tOYW1lXSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcclxuICAgICAgICAgICAgICAgICAgICBzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2VcclxuICAgICAgICAgICAgICAgICAgICBvbGRDYWxsYmFja3MucHVzaChjYWxsYmFja05hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24ob3ZlcndyaXR0ZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcndyaXR0ZW4ocmVzcG9uc2VDb250YWluZXJbMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gRGVsZWdhdGUgdG8gc2NyaXB0XHJcbiAgICAgICAgICAgIHJldHVybiBcInNjcmlwdFwiO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcblxyXG5cclxuICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcclxuICAgIC8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcclxuICAgIC8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxyXG4gICAgLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxyXG4gICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xyXG4gICAgc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpLmJvZHk7XHJcbiAgICAgICAgYm9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XHJcbiAgICAgICAgcmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcclxuICAgIC8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcclxuICAgIC8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XHJcbiAgICAvLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXHJcbiAgICBqUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24gKGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICBrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XHJcblxyXG4gICAgICAgIGlmICghY29udGV4dCkge1xyXG5cclxuICAgICAgICAgICAgLy8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgICAgIC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgICAgIGlmIChzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgIC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXHJcbiAgICAgICAgICAgICAgICAvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxyXG4gICAgICAgICAgICAgICAgYmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudChcImJhc2VcIik7XHJcbiAgICAgICAgICAgICAgICBiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5oZWFkLmFwcGVuZENoaWxkKGJhc2UpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGRvY3VtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoZGF0YSk7XHJcbiAgICAgICAgc2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcclxuXHJcbiAgICAgICAgLy8gU2luZ2xlIHRhZ1xyXG4gICAgICAgIGlmIChwYXJzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtjb250ZXh0LmNyZWF0ZUVsZW1lbnQocGFyc2VkWzFdKV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXJzZWQgPSBidWlsZEZyYWdtZW50KFtkYXRhXSwgY29udGV4dCwgc2NyaXB0cyk7XHJcblxyXG4gICAgICAgIGlmIChzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGpRdWVyeShzY3JpcHRzKS5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoW10sIHBhcnNlZC5jaGlsZE5vZGVzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxyXG4gICAgICovXHJcbiAgICBqUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uICh1cmwsIHBhcmFtcywgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxyXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgb2ZmID0gdXJsLmluZGV4T2YoXCIgXCIpO1xyXG5cclxuICAgICAgICBpZiAob2ZmID4gLTEpIHtcclxuICAgICAgICAgICAgc2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKHVybC5zbGljZShvZmYpKTtcclxuICAgICAgICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIG9mZik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBpdCdzIGEgZnVuY3Rpb25cclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihwYXJhbXMpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xyXG4gICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcclxuICAgICAgICAgICAgcGFyYW1zID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgdHlwZSA9IFwiUE9TVFwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3RcclxuICAgICAgICBpZiAoc2VsZi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGpRdWVyeS5hamF4KHtcclxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2VcclxuICAgICAgICAgICAgICAgIC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSB8fCBcIkdFVFwiLFxyXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwiaHRtbFwiLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogcGFyYW1zXHJcbiAgICAgICAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKHJlc3BvbnNlVGV4dCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhcmd1bWVudHM7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5odG1sKHNlbGVjdG9yID9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KFwiPGRpdj5cIikuYXBwZW5kKGpRdWVyeS5wYXJzZUhUTUwocmVzcG9uc2VUZXh0KSkuZmluZChzZWxlY3RvcikgOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXHJcbiAgICAgICAgICAgICAgICAvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXHJcbiAgICAgICAgICAgIH0pLmFsd2F5cyhjYWxsYmFjayAmJiBmdW5jdGlvbiAoanFYSFIsIHN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCByZXNwb25zZSB8fCBbanFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSXSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG5cclxuXHJcblxyXG4gICAgLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcclxuICAgIGpRdWVyeS5lYWNoKFtcclxuICAgICAgICBcImFqYXhTdGFydFwiLFxyXG4gICAgICAgIFwiYWpheFN0b3BcIixcclxuICAgICAgICBcImFqYXhDb21wbGV0ZVwiLFxyXG4gICAgICAgIFwiYWpheEVycm9yXCIsXHJcbiAgICAgICAgXCJhamF4U3VjY2Vzc1wiLFxyXG4gICAgICAgIFwiYWpheFNlbmRcIlxyXG4gICAgXSwgZnVuY3Rpb24gKGksIHR5cGUpIHtcclxuICAgICAgICBqUXVlcnkuZm5bdHlwZV0gPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24odHlwZSwgZm4pO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuXHJcbiAgICBqUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xyXG4gICAgICAgIH0pLmxlbmd0aDtcclxuICAgIH07XHJcblxyXG5cclxuXHJcblxyXG4gICAgalF1ZXJ5Lm9mZnNldCA9IHtcclxuICAgICAgICBzZXRPZmZzZXQ6IGZ1bmN0aW9uIChlbGVtLCBvcHRpb25zLCBpKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGpRdWVyeS5jc3MoZWxlbSwgXCJwb3NpdGlvblwiKSxcclxuICAgICAgICAgICAgICAgIGN1ckVsZW0gPSBqUXVlcnkoZWxlbSksXHJcbiAgICAgICAgICAgICAgICBwcm9wcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxyXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IFwic3RhdGljXCIpIHtcclxuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XHJcbiAgICAgICAgICAgIGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoZWxlbSwgXCJ0b3BcIik7XHJcbiAgICAgICAgICAgIGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKGVsZW0sIFwibGVmdFwiKTtcclxuICAgICAgICAgICAgY2FsY3VsYXRlUG9zaXRpb24gPSAocG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSAmJlxyXG4gICAgICAgICAgICAgICAgKGN1ckNTU1RvcCArIGN1ckNTU0xlZnQpLmluZGV4T2YoXCJhdXRvXCIpID4gLTE7XHJcblxyXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxyXG4gICAgICAgICAgICAvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcclxuICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZVBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcclxuICAgICAgICAgICAgICAgIGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1clRvcCA9IHBhcnNlRmxvYXQoY3VyQ1NTVG9wKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgY3VyTGVmdCA9IHBhcnNlRmxvYXQoY3VyQ1NTTGVmdCkgfHwgMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCh7fSwgY3VyT2Zmc2V0KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRvcCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy50b3AgPSAob3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wKSArIGN1clRvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLmxlZnQgPSAob3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQpICsgY3VyTGVmdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFwidXNpbmdcIiBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVzaW5nLmNhbGwoZWxlbSwgcHJvcHMpO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1ckVsZW0uY3NzKHByb3BzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxyXG4gICAgICAgIG9mZnNldDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMgOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkub2Zmc2V0LnNldE9mZnNldCh0aGlzLCBvcHRpb25zLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlY3QsIHdpbixcclxuICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWzBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcclxuICAgICAgICAgICAgLy8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxyXG4gICAgICAgICAgICAvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3JcclxuICAgICAgICAgICAgaWYgKCFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxyXG4gICAgICAgICAgICByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgd2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XHJcbiAgICAgICAgLy8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXHJcbiAgICAgICAgcG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxyXG4gICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbMF0sXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xyXG5cclxuICAgICAgICAgICAgLy8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcclxuICAgICAgICAgICAgaWYgKGpRdWVyeS5jc3MoZWxlbSwgXCJwb3NpdGlvblwiKSA9PT0gXCJmaXhlZFwiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxyXG4gICAgICAgICAgICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzZXRQYXJlbnQgJiZcclxuICAgICAgICAgICAgICAgICAgICAob2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIikgPT09IFwic3RhdGljXCIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0galF1ZXJ5KG9mZnNldFBhcmVudCkub2Zmc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKG9mZnNldFBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUpLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XHJcbiAgICAgICAgLy8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxyXG4gICAgICAgIC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xyXG4gICAgICAgIC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcclxuICAgICAgICAvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcclxuICAgICAgICAvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXHJcbiAgICAgICAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiKSA9PT0gXCJzdGF0aWNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xyXG4gICAgalF1ZXJ5LmVhY2goeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uIChtZXRob2QsIHByb3ApIHtcclxuICAgICAgICB2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xyXG5cclxuICAgICAgICBqUXVlcnkuZm5bbWV0aG9kXSA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAoZWxlbSwgbWV0aG9kLCB2YWwpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3NcclxuICAgICAgICAgICAgICAgIHZhciB3aW47XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3coZWxlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW4gPSBlbGVtO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtLm5vZGVUeXBlID09PSA5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luID0gZWxlbS5kZWZhdWx0VmlldztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luID8gd2luW3Byb3BdIDogZWxlbVttZXRob2RdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh3aW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW4uc2Nyb2xsVG8oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtW21ldGhvZF0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxyXG4gICAgLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cclxuICAgIC8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxyXG4gICAgLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcclxuICAgIC8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XHJcbiAgICAvLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxyXG4gICAgalF1ZXJ5LmVhY2goW1widG9wXCIsIFwibGVmdFwiXSwgZnVuY3Rpb24gKGksIHByb3ApIHtcclxuICAgICAgICBqUXVlcnkuY3NzSG9va3NbcHJvcF0gPSBhZGRHZXRIb29rSWYoc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZWxlbSwgY29tcHV0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wdXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gY3VyQ1NTKGVsZW0sIHByb3ApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm51bW5vbnB4LnRlc3QoY29tcHV0ZWQpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KGVsZW0pLnBvc2l0aW9uKClbcHJvcF0gKyBcInB4XCIgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXHJcbiAgICBqUXVlcnkuZWFjaCh7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiAobmFtZSwgdHlwZSkge1xyXG4gICAgICAgIGpRdWVyeS5lYWNoKHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmZuW2Z1bmNOYW1lXSA9IGZ1bmN0aW9uIChtYXJnaW4sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8IChtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgZnVuY3Rpb24gKGVsZW0sIHR5cGUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2M7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3coZWxlbSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoXCJvdXRlclwiKSA9PT0gMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVtcImlubmVyXCIgKyBuYW1lXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbXCJjbGllbnRcIiArIG5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSA5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmJvZHlbXCJzY3JvbGxcIiArIG5hbWVdLCBkb2NbXCJzY3JvbGxcIiArIG5hbWVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uYm9keVtcIm9mZnNldFwiICsgbmFtZV0sIGRvY1tcIm9mZnNldFwiICsgbmFtZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jW1wiY2xpZW50XCIgKyBuYW1lXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3MoZWxlbSwgdHlwZSwgZXh0cmEpIDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBqUXVlcnkuZWFjaCgoXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXHJcbiAgICAgICAgXCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXHJcbiAgICAgICAgXCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIpLnNwbGl0KFwiIFwiKSxcclxuICAgICAgICBmdW5jdGlvbiAoaSwgbmFtZSkge1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcclxuICAgICAgICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub24obmFtZSwgbnVsbCwgZGF0YSwgZm4pIDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIobmFtZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICAgICAgaG92ZXI6IGZ1bmN0aW9uIChmbk92ZXIsIGZuT3V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdXNlZW50ZXIoZm5PdmVyKS5tb3VzZWxlYXZlKGZuT3V0IHx8IGZuT3Zlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uICh0eXBlcywgZGF0YSwgZm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24odHlwZXMsIG51bGwsIGRhdGEsIGZuKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVuYmluZDogZnVuY3Rpb24gKHR5cGVzLCBmbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vZmYodHlwZXMsIG51bGwsIGZuKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkZWxlZ2F0ZTogZnVuY3Rpb24gKHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24odHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bmRlbGVnYXRlOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHR5cGVzLCBmbikge1xyXG5cclxuICAgICAgICAgICAgLy8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxyXG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihzZWxlY3RvciwgXCIqKlwiKSA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZih0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XHJcbiAgICAvLyBhcmd1bWVudHMuXHJcbiAgICAvLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXHJcbiAgICAvLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cclxuICAgIGpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uIChmbiwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciB0bXAsIGFyZ3MsIHByb3h5O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdG1wID0gZm5bY29udGV4dF07XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSBmbjtcclxuICAgICAgICAgICAgZm4gPSB0bXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xyXG4gICAgICAgIC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXHJcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZuKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2ltdWxhdGVkIGJpbmRcclxuICAgICAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgIHByb3h5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcclxuICAgICAgICBwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb3h5O1xyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24gKGhvbGQpIHtcclxuICAgICAgICBpZiAoaG9sZCkge1xyXG4gICAgICAgICAgICBqUXVlcnkucmVhZHlXYWl0Kys7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgalF1ZXJ5LnJlYWR5KHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBqUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XHJcbiAgICBqUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcclxuICAgIGpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xyXG4gICAgalF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xyXG4gICAgalF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XHJcbiAgICBqUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xyXG4gICAgalF1ZXJ5LnR5cGUgPSB0b1R5cGU7XHJcblxyXG4gICAgalF1ZXJ5Lm5vdyA9IERhdGUubm93O1xyXG5cclxuICAgIGpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiAob2JqKSB7XHJcblxyXG4gICAgICAgIC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXHJcbiAgICAgICAgLy8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxyXG4gICAgICAgIC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXHJcbiAgICAgICAgdmFyIHR5cGUgPSBqUXVlcnkudHlwZShvYmopO1xyXG4gICAgICAgIHJldHVybiAodHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiKSAmJlxyXG5cclxuICAgICAgICAgICAgLy8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXHJcbiAgICAgICAgICAgIC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcclxuICAgICAgICAgICAgLy8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXHJcbiAgICAgICAgICAgICFpc05hTihvYmogLSBwYXJzZUZsb2F0KG9iaikpO1xyXG4gICAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgICAvLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcclxuICAgIC8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcclxuICAgIC8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxyXG4gICAgLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxyXG4gICAgLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXHJcbiAgICAvLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcclxuICAgIC8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cclxuXHJcbiAgICAvLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxyXG4gICAgLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxyXG4gICAgLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cclxuXHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXJcclxuXHJcbiAgICAgICAgLy8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXHJcbiAgICAgICAgX2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXHJcblxyXG4gICAgICAgIC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXHJcbiAgICAgICAgXyQgPSB3aW5kb3cuJDtcclxuXHJcbiAgICBqUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uIChkZWVwKSB7XHJcbiAgICAgICAgaWYgKHdpbmRvdy4kID09PSBqUXVlcnkpIHtcclxuICAgICAgICAgICAgd2luZG93LiQgPSBfJDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSkge1xyXG4gICAgICAgICAgICB3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBqUXVlcnk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXHJcbiAgICAvLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXHJcbiAgICAvLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXHJcbiAgICBpZiAoIW5vR2xvYmFsKSB7XHJcbiAgICAgICAgd2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIHJldHVybiBqUXVlcnk7XHJcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9qcy9qcXVlcnkuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiIifQ==