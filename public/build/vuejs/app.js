/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./assets/js/vuejs/vue.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/js/vuejs/vue.js":
/*!********************************!*\
  !*** ./assets/js/vuejs/vue.js ***!
  \********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, setImmediate) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Vue.js v2.5.16
 * (c) 2014-2018 Evan You
 * Released under the MIT License.
 */
(function (global, factory) {
  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.Vue = factory();
})(this, function () {
  'use strict';

  /*  */

  var emptyObject = Object.freeze({});

  // these helpers produces better vm code in JS engines due to their
  // explicitness and function inlining
  function isUndef(v) {
    return v === undefined || v === null;
  }

  function isDef(v) {
    return v !== undefined && v !== null;
  }

  function isTrue(v) {
    return v === true;
  }

  function isFalse(v) {
    return v === false;
  }

  /**
   * Check if value is primitive
   */
  function isPrimitive(value) {
    return typeof value === 'string' || typeof value === 'number' ||
    // $flow-disable-line
    (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol' || typeof value === 'boolean';
  }

  /**
   * Quick object check - this is primarily used to tell
   * Objects from primitive values when we know the value
   * is a JSON-compliant type.
   */
  function isObject(obj) {
    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
  }

  /**
   * Get the raw type string of a value e.g. [object Object]
   */
  var _toString = Object.prototype.toString;

  function toRawType(value) {
    return _toString.call(value).slice(8, -1);
  }

  /**
   * Strict object type check. Only returns true
   * for plain JavaScript objects.
   */
  function isPlainObject(obj) {
    return _toString.call(obj) === '[object Object]';
  }

  function isRegExp(v) {
    return _toString.call(v) === '[object RegExp]';
  }

  /**
   * Check if val is a valid array index.
   */
  function isValidArrayIndex(val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val);
  }

  /**
   * Convert a value to a string that is actually rendered.
   */
  function toString(val) {
    return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
  }

  /**
   * Convert a input value to a number for persistence.
   * If the conversion fails, return original string.
   */
  function toNumber(val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n;
  }

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   */
  function makeMap(str, expectsLowerCase) {
    var map = Object.create(null);
    var list = str.split(',');
    for (var i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? function (val) {
      return map[val.toLowerCase()];
    } : function (val) {
      return map[val];
    };
  }

  /**
   * Check if a tag is a built-in tag.
   */
  var isBuiltInTag = makeMap('slot,component', true);

  /**
   * Check if a attribute is a reserved attribute.
   */
  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

  /**
   * Remove an item from an array
   */
  function remove(arr, item) {
    if (arr.length) {
      var index = arr.indexOf(item);
      if (index > -1) {
        return arr.splice(index, 1);
      }
    }
  }

  /**
   * Check whether the object has the property.
   */
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
  }

  /**
   * Create a cached version of a pure function.
   */
  function cached(fn) {
    var cache = Object.create(null);
    return function cachedFn(str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  }

  /**
   * Camelize a hyphen-delimited string.
   */
  var camelizeRE = /-(\w)/g;
  var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) {
      return c ? c.toUpperCase() : '';
    });
  });

  /**
   * Capitalize a string.
   */
  var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });

  /**
   * Hyphenate a camelCase string.
   */
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '-$1').toLowerCase();
  });

  /**
   * Simple bind polyfill for environments that do not support it... e.g.
   * PhantomJS 1.x. Technically we don't need this anymore since native bind is
   * now more performant in most browsers, but removing it would be breaking for
   * code that was able to run in PhantomJS 1.x, so this must be kept for
   * backwards compatibility.
   */

  /* istanbul ignore next */
  function polyfillBind(fn, ctx) {
    function boundFn(a) {
      var l = arguments.length;
      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
    }

    boundFn._length = fn.length;
    return boundFn;
  }

  function nativeBind(fn, ctx) {
    return fn.bind(ctx);
  }

  var bind = Function.prototype.bind ? nativeBind : polyfillBind;

  /**
   * Convert an Array-like object to a real Array.
   */
  function toArray(list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
      ret[i] = list[i + start];
    }
    return ret;
  }

  /**
   * Mix properties into target object.
   */
  function extend(to, _from) {
    for (var key in _from) {
      to[key] = _from[key];
    }
    return to;
  }

  /**
   * Merge an Array of Objects into a single Object.
   */
  function toObject(arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
      if (arr[i]) {
        extend(res, arr[i]);
      }
    }
    return res;
  }

  /**
   * Perform no operation.
   * Stubbing args to make Flow happy without leaving useless transpiled code
   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
   */
  function noop(a, b, c) {}

  /**
   * Always return false.
   */
  var no = function no(a, b, c) {
    return false;
  };

  /**
   * Return same value
   */
  var identity = function identity(_) {
    return _;
  };

  /**
   * Generate a static keys string from compiler modules.
   */
  function genStaticKeys(modules) {
    return modules.reduce(function (keys, m) {
      return keys.concat(m.staticKeys || []);
    }, []).join(',');
  }

  /**
   * Check if two values are loosely equal - that is,
   * if they are plain objects, do they have the same shape?
   */
  function looseEqual(a, b) {
    if (a === b) {
      return true;
    }
    var isObjectA = isObject(a);
    var isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
      try {
        var isArrayA = Array.isArray(a);
        var isArrayB = Array.isArray(b);
        if (isArrayA && isArrayB) {
          return a.length === b.length && a.every(function (e, i) {
            return looseEqual(e, b[i]);
          });
        } else if (!isArrayA && !isArrayB) {
          var keysA = Object.keys(a);
          var keysB = Object.keys(b);
          return keysA.length === keysB.length && keysA.every(function (key) {
            return looseEqual(a[key], b[key]);
          });
        } else {
          /* istanbul ignore next */
          return false;
        }
      } catch (e) {
        /* istanbul ignore next */
        return false;
      }
    } else if (!isObjectA && !isObjectB) {
      return String(a) === String(b);
    } else {
      return false;
    }
  }

  function looseIndexOf(arr, val) {
    for (var i = 0; i < arr.length; i++) {
      if (looseEqual(arr[i], val)) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Ensure a function is called only once.
   */
  function once(fn) {
    var called = false;
    return function () {
      if (!called) {
        called = true;
        fn.apply(this, arguments);
      }
    };
  }

  var SSR_ATTR = 'data-server-rendered';

  var ASSET_TYPES = ['component', 'directive', 'filter'];

  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];

  /*  */

  var config = {
    /**
     * Option merge strategies (used in core/util/options)
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),

    /**
     * Whether to suppress warnings.
     */
    silent: false,

    /**
     * Show production mode tip message on boot?
     */
    productionTip: "development" !== 'production',

    /**
     * Whether to enable devtools
     */
    devtools: "development" !== 'production',

    /**
     * Whether to record perf
     */
    performance: false,

    /**
     * Error handler for watcher errors
     */
    errorHandler: null,

    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,

    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],

    /**
     * Custom user key aliases for v-on
     */
    // $flow-disable-line
    keyCodes: Object.create(null),

    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,

    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,

    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,

    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop,

    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity,

    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,

    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
  };

  /*  */

  /**
   * Check if a string starts with $ or _
   */
  function isReserved(str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5F;
  }

  /**
   * Define a property.
   */
  function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    });
  }

  /**
   * Parse simple path.
   */
  var bailRE = /[^\w.$]/;
  function parsePath(path) {
    if (bailRE.test(path)) {
      return;
    }
    var segments = path.split('.');
    return function (obj) {
      for (var i = 0; i < segments.length; i++) {
        if (!obj) {
          return;
        }
        obj = obj[segments[i]];
      }
      return obj;
    };
  }

  /*  */

  // can we use __proto__?
  var hasProto = '__proto__' in {};

  // Browser environment sniffing
  var inBrowser = typeof window !== 'undefined';
  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
  var UA = inBrowser && window.navigator.userAgent.toLowerCase();
  var isIE = UA && /msie|trident/.test(UA);
  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
  var isEdge = UA && UA.indexOf('edge/') > 0;
  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
  var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

  // Firefox has a "watch" function on Object.prototype...
  var nativeWatch = {}.watch;

  var supportsPassive = false;
  if (inBrowser) {
    try {
      var opts = {};
      Object.defineProperty(opts, 'passive', {
        get: function get() {
          /* istanbul ignore next */
          supportsPassive = true;
        }
      }); // https://github.com/facebook/flow/issues/285
      window.addEventListener('test-passive', null, opts);
    } catch (e) {}
  }

  // this needs to be lazy-evaled because vue may be required before
  // vue-server-renderer can set VUE_ENV
  var _isServer;
  var isServerRendering = function isServerRendering() {
    if (_isServer === undefined) {
      /* istanbul ignore if */
      if (!inBrowser && !inWeex && typeof global !== 'undefined') {
        // detect presence of vue-server-renderer and avoid
        // Webpack shimming the process
        _isServer = global['process'].env.VUE_ENV === 'server';
      } else {
        _isServer = false;
      }
    }
    return _isServer;
  };

  // detect devtools
  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

  /* istanbul ignore next */
  function isNative(Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
  }

  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

  var _Set;
  /* istanbul ignore if */ // $flow-disable-line
  if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
  } else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = function () {
      function Set() {
        this.set = Object.create(null);
      }
      Set.prototype.has = function has(key) {
        return this.set[key] === true;
      };
      Set.prototype.add = function add(key) {
        this.set[key] = true;
      };
      Set.prototype.clear = function clear() {
        this.set = Object.create(null);
      };

      return Set;
    }();
  }

  /*  */

  var warn = noop;
  var tip = noop;
  var generateComponentTrace = noop; // work around flow check
  var formatComponentName = noop;

  {
    var hasConsole = typeof console !== 'undefined';
    var classifyRE = /(?:^|[-_])(\w)/g;
    var classify = function classify(str) {
      return str.replace(classifyRE, function (c) {
        return c.toUpperCase();
      }).replace(/[-_]/g, '');
    };

    warn = function warn(msg, vm) {
      var trace = vm ? generateComponentTrace(vm) : '';

      if (config.warnHandler) {
        config.warnHandler.call(null, msg, vm, trace);
      } else if (hasConsole && !config.silent) {
        console.error("[Vue warn]: " + msg + trace);
      }
    };

    tip = function tip(msg, vm) {
      if (hasConsole && !config.silent) {
        console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
      }
    };

    formatComponentName = function formatComponentName(vm, includeFile) {
      if (vm.$root === vm) {
        return '<Root>';
      }
      var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
      var name = options.name || options._componentTag;
      var file = options.__file;
      if (!name && file) {
        var match = file.match(/([^/\\]+)\.vue$/);
        name = match && match[1];
      }

      return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
    };

    var repeat = function repeat(str, n) {
      var res = '';
      while (n) {
        if (n % 2 === 1) {
          res += str;
        }
        if (n > 1) {
          str += str;
        }
        n >>= 1;
      }
      return res;
    };

    generateComponentTrace = function generateComponentTrace(vm) {
      if (vm._isVue && vm.$parent) {
        var tree = [];
        var currentRecursiveSequence = 0;
        while (vm) {
          if (tree.length > 0) {
            var last = tree[tree.length - 1];
            if (last.constructor === vm.constructor) {
              currentRecursiveSequence++;
              vm = vm.$parent;
              continue;
            } else if (currentRecursiveSequence > 0) {
              tree[tree.length - 1] = [last, currentRecursiveSequence];
              currentRecursiveSequence = 0;
            }
          }
          tree.push(vm);
          vm = vm.$parent;
        }
        return '\n\nfound in\n\n' + tree.map(function (vm, i) {
          return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
        }).join('\n');
      } else {
        return "\n\n(found in " + formatComponentName(vm) + ")";
      }
    };
  }

  /*  */

  var uid = 0;

  /**
   * A dep is an observable that can have multiple
   * directives subscribing to it.
   */
  var Dep = function Dep() {
    this.id = uid++;
    this.subs = [];
  };

  Dep.prototype.addSub = function addSub(sub) {
    this.subs.push(sub);
  };

  Dep.prototype.removeSub = function removeSub(sub) {
    remove(this.subs, sub);
  };

  Dep.prototype.depend = function depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };

  Dep.prototype.notify = function notify() {
    // stabilize the subscriber list first
    var subs = this.subs.slice();
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };

  // the current target watcher being evaluated.
  // this is globally unique because there could be only one
  // watcher being evaluated at any time.
  Dep.target = null;
  var targetStack = [];

  function pushTarget(_target) {
    if (Dep.target) {
      targetStack.push(Dep.target);
    }
    Dep.target = _target;
  }

  function popTarget() {
    Dep.target = targetStack.pop();
  }

  /*  */

  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
    this.tag = tag;
    this.data = data;
    this.children = children;
    this.text = text;
    this.elm = elm;
    this.ns = undefined;
    this.context = context;
    this.fnContext = undefined;
    this.fnOptions = undefined;
    this.fnScopeId = undefined;
    this.key = data && data.key;
    this.componentOptions = componentOptions;
    this.componentInstance = undefined;
    this.parent = undefined;
    this.raw = false;
    this.isStatic = false;
    this.isRootInsert = true;
    this.isComment = false;
    this.isCloned = false;
    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = undefined;
    this.isAsyncPlaceholder = false;
  };

  var prototypeAccessors = { child: { configurable: true } };

  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next */
  prototypeAccessors.child.get = function () {
    return this.componentInstance;
  };

  Object.defineProperties(VNode.prototype, prototypeAccessors);

  var createEmptyVNode = function createEmptyVNode(text) {
    if (text === void 0) text = '';

    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node;
  };

  function createTextVNode(val) {
    return new VNode(undefined, undefined, undefined, String(val));
  }

  // optimized shallow clone
  // used for static nodes and slot nodes because they may be reused across
  // multiple renders, cloning them avoids errors when DOM manipulations rely
  // on their elm reference.
  function cloneVNode(vnode) {
    var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.isCloned = true;
    return cloned;
  }

  /*
   * not type checking this file because flow doesn't play well with
   * dynamically accessing methods on Array prototype
   */

  var arrayProto = Array.prototype;
  var arrayMethods = Object.create(arrayProto);

  var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];

  /**
   * Intercept mutating methods and emit events
   */
  methodsToPatch.forEach(function (method) {
    // cache original method
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator() {
      var args = [],
          len = arguments.length;
      while (len--) {
        args[len] = arguments[len];
      }var result = original.apply(this, args);
      var ob = this.__ob__;
      var inserted;
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args;
          break;
        case 'splice':
          inserted = args.slice(2);
          break;
      }
      if (inserted) {
        ob.observeArray(inserted);
      }
      // notify change
      ob.dep.notify();
      return result;
    });
  });

  /*  */

  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

  /**
   * In some cases we may want to disable observation inside a component's
   * update computation.
   */
  var shouldObserve = true;

  function toggleObserving(value) {
    shouldObserve = value;
  }

  /**
   * Observer class that is attached to each observed
   * object. Once attached, the observer converts the target
   * object's property keys into getter/setters that
   * collect dependencies and dispatch updates.
   */
  var Observer = function Observer(value) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, '__ob__', this);
    if (Array.isArray(value)) {
      var augment = hasProto ? protoAugment : copyAugment;
      augment(value, arrayMethods, arrayKeys);
      this.observeArray(value);
    } else {
      this.walk(value);
    }
  };

  /**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  Observer.prototype.walk = function walk(obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i]);
    }
  };

  /**
   * Observe a list of Array items.
   */
  Observer.prototype.observeArray = function observeArray(items) {
    for (var i = 0, l = items.length; i < l; i++) {
      observe(items[i]);
    }
  };

  // helpers

  /**
   * Augment an target Object or Array by intercepting
   * the prototype chain using __proto__
   */
  function protoAugment(target, src, keys) {
    /* eslint-disable no-proto */
    target.__proto__ = src;
    /* eslint-enable no-proto */
  }

  /**
   * Augment an target Object or Array by defining
   * hidden properties.
   */
  /* istanbul ignore next */
  function copyAugment(target, src, keys) {
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      def(target, key, src[key]);
    }
  }

  /**
   * Attempt to create an observer instance for a value,
   * returns the new observer if successfully observed,
   * or the existing observer if the value already has one.
   */
  function observe(value, asRootData) {
    if (!isObject(value) || value instanceof VNode) {
      return;
    }
    var ob;
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
      ob = value.__ob__;
    } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
      ob = new Observer(value);
    }
    if (asRootData && ob) {
      ob.vmCount++;
    }
    return ob;
  }

  /**
   * Define a reactive property on an Object.
   */
  function defineReactive(obj, key, val, customSetter, shallow) {
    var dep = new Dep();

    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
      return;
    }

    // cater for pre-defined getter/setters
    var getter = property && property.get;
    if (!getter && arguments.length === 2) {
      val = obj[key];
    }
    var setter = property && property.set;

    var childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: function reactiveGetter() {
        var value = getter ? getter.call(obj) : val;
        if (Dep.target) {
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
            if (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }
        return value;
      },
      set: function reactiveSetter(newVal) {
        var value = getter ? getter.call(obj) : val;
        /* eslint-disable no-self-compare */
        if (newVal === value || newVal !== newVal && value !== value) {
          return;
        }
        /* eslint-enable no-self-compare */
        if ("development" !== 'production' && customSetter) {
          customSetter();
        }
        if (setter) {
          setter.call(obj, newVal);
        } else {
          val = newVal;
        }
        childOb = !shallow && observe(newVal);
        dep.notify();
      }
    });
  }

  /**
   * Set a property on an object. Adds the new property and
   * triggers change notification if the property doesn't
   * already exist.
   */
  function set(target, key, val) {
    if ("development" !== 'production' && (isUndef(target) || isPrimitive(target))) {
      warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val;
    }
    if (key in target && !(key in Object.prototype)) {
      target[key] = val;
      return val;
    }
    var ob = target.__ob__;
    if (target._isVue || ob && ob.vmCount) {
      "development" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
      return val;
    }
    if (!ob) {
      target[key] = val;
      return val;
    }
    defineReactive(ob.value, key, val);
    ob.dep.notify();
    return val;
  }

  /**
   * Delete a property and trigger change if necessary.
   */
  function del(target, key) {
    if ("development" !== 'production' && (isUndef(target) || isPrimitive(target))) {
      warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.splice(key, 1);
      return;
    }
    var ob = target.__ob__;
    if (target._isVue || ob && ob.vmCount) {
      "development" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
      return;
    }
    if (!hasOwn(target, key)) {
      return;
    }
    delete target[key];
    if (!ob) {
      return;
    }
    ob.dep.notify();
  }

  /**
   * Collect dependencies on array elements when the array is touched, since
   * we cannot intercept array element access like property getters.
   */
  function dependArray(value) {
    for (var e = void 0, i = 0, l = value.length; i < l; i++) {
      e = value[i];
      e && e.__ob__ && e.__ob__.dep.depend();
      if (Array.isArray(e)) {
        dependArray(e);
      }
    }
  }

  /*  */

  /**
   * Option overwriting strategies are functions that handle
   * how to merge a parent option value and a child option
   * value into the final value.
   */
  var strats = config.optionMergeStrategies;

  /**
   * Options with restrictions
   */
  {
    strats.el = strats.propsData = function (parent, child, vm, key) {
      if (!vm) {
        warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
      }
      return defaultStrat(parent, child);
    };
  }

  /**
   * Helper that recursively merges two data objects together.
   */
  function mergeData(to, from) {
    if (!from) {
      return to;
    }
    var key, toVal, fromVal;
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      key = keys[i];
      toVal = to[key];
      fromVal = from[key];
      if (!hasOwn(to, key)) {
        set(to, key, fromVal);
      } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
        mergeData(toVal, fromVal);
      }
    }
    return to;
  }

  /**
   * Data
   */
  function mergeDataOrFn(parentVal, childVal, vm) {
    if (!vm) {
      // in a Vue.extend merge, both should be functions
      if (!childVal) {
        return parentVal;
      }
      if (!parentVal) {
        return childVal;
      }
      // when parentVal & childVal are both present,
      // we need to return a function that returns the
      // merged result of both functions... no need to
      // check if parentVal is a function here because
      // it has to be a function to pass previous merges.
      return function mergedDataFn() {
        return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
      };
    } else {
      return function mergedInstanceDataFn() {
        // instance merge
        var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;
        if (instanceData) {
          return mergeData(instanceData, defaultData);
        } else {
          return defaultData;
        }
      };
    }
  }

  strats.data = function (parentVal, childVal, vm) {
    if (!vm) {
      if (childVal && typeof childVal !== 'function') {
        "development" !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);

        return parentVal;
      }
      return mergeDataOrFn(parentVal, childVal);
    }

    return mergeDataOrFn(parentVal, childVal, vm);
  };

  /**
   * Hooks and props are merged as arrays.
   */
  function mergeHook(parentVal, childVal) {
    return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  }

  LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeHook;
  });

  /**
   * Assets
   *
   * When a vm is present (instance creation), we need to do
   * a three-way merge between constructor options, instance
   * options and parent options.
   */
  function mergeAssets(parentVal, childVal, vm, key) {
    var res = Object.create(parentVal || null);
    if (childVal) {
      "development" !== 'production' && assertObjectType(key, childVal, vm);
      return extend(res, childVal);
    } else {
      return res;
    }
  }

  ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
  });

  /**
   * Watchers.
   *
   * Watchers hashes should not overwrite one
   * another, so we merge them as arrays.
   */
  strats.watch = function (parentVal, childVal, vm, key) {
    // work around Firefox's Object.prototype.watch...
    if (parentVal === nativeWatch) {
      parentVal = undefined;
    }
    if (childVal === nativeWatch) {
      childVal = undefined;
    }
    /* istanbul ignore if */
    if (!childVal) {
      return Object.create(parentVal || null);
    }
    {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) {
      return childVal;
    }
    var ret = {};
    extend(ret, parentVal);
    for (var key$1 in childVal) {
      var parent = ret[key$1];
      var child = childVal[key$1];
      if (parent && !Array.isArray(parent)) {
        parent = [parent];
      }
      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
    }
    return ret;
  };

  /**
   * Other object hashes.
   */
  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
    if (childVal && "development" !== 'production') {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) {
      return childVal;
    }
    var ret = Object.create(null);
    extend(ret, parentVal);
    if (childVal) {
      extend(ret, childVal);
    }
    return ret;
  };
  strats.provide = mergeDataOrFn;

  /**
   * Default strategy.
   */
  var defaultStrat = function defaultStrat(parentVal, childVal) {
    return childVal === undefined ? parentVal : childVal;
  };

  /**
   * Validate component names
   */
  function checkComponents(options) {
    for (var key in options.components) {
      validateComponentName(key);
    }
  }

  function validateComponentName(name) {
    if (!/^[a-zA-Z][\w-]*$/.test(name)) {
      warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
    }
    if (isBuiltInTag(name) || config.isReservedTag(name)) {
      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
    }
  }

  /**
   * Ensure all props option syntax are normalized into the
   * Object-based format.
   */
  function normalizeProps(options, vm) {
    var props = options.props;
    if (!props) {
      return;
    }
    var res = {};
    var i, val, name;
    if (Array.isArray(props)) {
      i = props.length;
      while (i--) {
        val = props[i];
        if (typeof val === 'string') {
          name = camelize(val);
          res[name] = { type: null };
        } else {
          warn('props must be strings when using array syntax.');
        }
      }
    } else if (isPlainObject(props)) {
      for (var key in props) {
        val = props[key];
        name = camelize(key);
        res[name] = isPlainObject(val) ? val : { type: val };
      }
    } else {
      warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
    }
    options.props = res;
  }

  /**
   * Normalize all injections into Object-based format
   */
  function normalizeInject(options, vm) {
    var inject = options.inject;
    if (!inject) {
      return;
    }
    var normalized = options.inject = {};
    if (Array.isArray(inject)) {
      for (var i = 0; i < inject.length; i++) {
        normalized[inject[i]] = { from: inject[i] };
      }
    } else if (isPlainObject(inject)) {
      for (var key in inject) {
        var val = inject[key];
        normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
      }
    } else {
      warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
    }
  }

  /**
   * Normalize raw function directives into object format.
   */
  function normalizeDirectives(options) {
    var dirs = options.directives;
    if (dirs) {
      for (var key in dirs) {
        var def = dirs[key];
        if (typeof def === 'function') {
          dirs[key] = { bind: def, update: def };
        }
      }
    }
  }

  function assertObjectType(name, value, vm) {
    if (!isPlainObject(value)) {
      warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
    }
  }

  /**
   * Merge two option objects into a new one.
   * Core utility used in both instantiation and inheritance.
   */
  function mergeOptions(parent, child, vm) {
    {
      checkComponents(child);
    }

    if (typeof child === 'function') {
      child = child.options;
    }

    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives(child);
    var extendsFrom = child.extends;
    if (extendsFrom) {
      parent = mergeOptions(parent, extendsFrom, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
    var options = {};
    var key;
    for (key in parent) {
      mergeField(key);
    }
    for (key in child) {
      if (!hasOwn(parent, key)) {
        mergeField(key);
      }
    }
    function mergeField(key) {
      var strat = strats[key] || defaultStrat;
      options[key] = strat(parent[key], child[key], vm, key);
    }
    return options;
  }

  /**
   * Resolve an asset.
   * This function is used because child instances need access
   * to assets defined in its ancestor chain.
   */
  function resolveAsset(options, type, id, warnMissing) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
      return;
    }
    var assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id)) {
      return assets[id];
    }
    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId)) {
      return assets[camelizedId];
    }
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId)) {
      return assets[PascalCaseId];
    }
    // fallback to prototype chain
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if ("development" !== 'production' && warnMissing && !res) {
      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
    }
    return res;
  }

  /*  */

  function validateProp(key, propOptions, propsData, vm) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    // boolean casting
    var booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
      if (absent && !hasOwn(prop, 'default')) {
        value = false;
      } else if (value === '' || value === hyphenate(key)) {
        // only cast empty string / same name to boolean if
        // boolean has higher priority
        var stringIndex = getTypeIndex(String, prop.type);
        if (stringIndex < 0 || booleanIndex < stringIndex) {
          value = true;
        }
      }
    }
    // check default value
    if (value === undefined) {
      value = getPropDefaultValue(vm, prop, key);
      // since the default value is a fresh copy,
      // make sure to observe it.
      var prevShouldObserve = shouldObserve;
      toggleObserving(true);
      observe(value);
      toggleObserving(prevShouldObserve);
    }
    {
      assertProp(prop, key, value, vm, absent);
    }
    return value;
  }

  /**
   * Get the default value of a prop.
   */
  function getPropDefaultValue(vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
      return undefined;
    }
    var def = prop.default;
    // warn against non-factory defaults for Object & Array
    if ("development" !== 'production' && isObject(def)) {
      warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
    }
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
      return vm._props[key];
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
  }

  /**
   * Assert whether a prop is valid.
   */
  function assertProp(prop, name, value, vm, absent) {
    if (prop.required && absent) {
      warn('Missing required prop: "' + name + '"', vm);
      return;
    }
    if (value == null && !prop.required) {
      return;
    }
    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];
    if (type) {
      if (!Array.isArray(type)) {
        type = [type];
      }
      for (var i = 0; i < type.length && !valid; i++) {
        var assertedType = assertType(value, type[i]);
        expectedTypes.push(assertedType.expectedType || '');
        valid = assertedType.valid;
      }
    }
    if (!valid) {
      warn("Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ') + ", got " + toRawType(value) + ".", vm);
      return;
    }
    var validator = prop.validator;
    if (validator) {
      if (!validator(value)) {
        warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
      }
    }
  }

  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

  function assertType(value, type) {
    var valid;
    var expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
      var t = typeof value === 'undefined' ? 'undefined' : _typeof(value);
      valid = t === expectedType.toLowerCase();
      // for primitive wrapper objects
      if (!valid && t === 'object') {
        valid = value instanceof type;
      }
    } else if (expectedType === 'Object') {
      valid = isPlainObject(value);
    } else if (expectedType === 'Array') {
      valid = Array.isArray(value);
    } else {
      valid = value instanceof type;
    }
    return {
      valid: valid,
      expectedType: expectedType
    };
  }

  /**
   * Use function string name to check built-in types,
   * because a simple equality check will fail when running
   * across different vms / iframes.
   */
  function getType(fn) {
    var match = fn && fn.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : '';
  }

  function isSameType(a, b) {
    return getType(a) === getType(b);
  }

  function getTypeIndex(type, expectedTypes) {
    if (!Array.isArray(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1;
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
      if (isSameType(expectedTypes[i], type)) {
        return i;
      }
    }
    return -1;
  }

  /*  */

  function handleError(err, vm, info) {
    if (vm) {
      var cur = vm;
      while (cur = cur.$parent) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) {
                return;
              }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  }

  function globalHandleError(err, vm, info) {
    if (config.errorHandler) {
      try {
        return config.errorHandler.call(null, err, vm, info);
      } catch (e) {
        logError(e, null, 'config.errorHandler');
      }
    }
    logError(err, vm, info);
  }

  function logError(err, vm, info) {
    {
      warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
    }
    /* istanbul ignore else */
    if ((inBrowser || inWeex) && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err;
    }
  }

  /*  */
  /* globals MessageChannel */

  var callbacks = [];
  var pending = false;

  function flushCallbacks() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // Here we have async deferring wrappers using both microtasks and (macro) tasks.
  // In < 2.4 we used microtasks everywhere, but there are some scenarios where
  // microtasks have too high a priority and fire in between supposedly
  // sequential events (e.g. #4521, #6690) or even between bubbling of the same
  // event (#6566). However, using (macro) tasks everywhere also has subtle problems
  // when state is changed right before repaint (e.g. #6813, out-in transitions).
  // Here we use microtask by default, but expose a way to force (macro) task when
  // needed (e.g. in event handlers attached by v-on).
  var microTimerFunc;
  var macroTimerFunc;
  var useMacroTask = false;

  // Determine (macro) task defer implementation.
  // Technically setImmediate should be the ideal choice, but it's only available
  // in IE. The only polyfill that consistently queues the callback after all DOM
  // events triggered in the same loop is by using MessageChannel.
  /* istanbul ignore if */
  if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    macroTimerFunc = function macroTimerFunc() {
      setImmediate(flushCallbacks);
    };
  } else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]')) {
    var channel = new MessageChannel();
    var port = channel.port2;
    channel.port1.onmessage = flushCallbacks;
    macroTimerFunc = function macroTimerFunc() {
      port.postMessage(1);
    };
  } else {
    /* istanbul ignore next */
    macroTimerFunc = function macroTimerFunc() {
      setTimeout(flushCallbacks, 0);
    };
  }

  // Determine microtask defer implementation.
  /* istanbul ignore next, $flow-disable-line */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    microTimerFunc = function microTimerFunc() {
      p.then(flushCallbacks);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) {
        setTimeout(noop);
      }
    };
  } else {
    // fallback to macro
    microTimerFunc = macroTimerFunc;
  }

  /**
   * Wrap a function so that if any code inside triggers state change,
   * the changes are queued using a (macro) task instead of a microtask.
   */
  function withMacroTask(fn) {
    return fn._withTask || (fn._withTask = function () {
      useMacroTask = true;
      var res = fn.apply(null, arguments);
      useMacroTask = false;
      return res;
    });
  }

  function nextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      if (useMacroTask) {
        macroTimerFunc();
      } else {
        microTimerFunc();
      }
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      });
    }
  }

  /*  */

  var mark;
  var measure;

  {
    var perf = inBrowser && window.performance;
    /* istanbul ignore if */
    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
      mark = function mark(tag) {
        return perf.mark(tag);
      };
      measure = function measure(name, startTag, endTag) {
        perf.measure(name, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
        perf.clearMeasures(name);
      };
    }
  }

  /* not type checking this file because flow doesn't play well with Proxy */

  var initProxy;

  {
    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
    );

    var warnNonPresent = function warnNonPresent(target, key) {
      warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
    };

    var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

    if (hasProxy) {
      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
      config.keyCodes = new Proxy(config.keyCodes, {
        set: function set(target, key, value) {
          if (isBuiltInModifier(key)) {
            warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
            return false;
          } else {
            target[key] = value;
            return true;
          }
        }
      });
    }

    var hasHandler = {
      has: function has(target, key) {
        var has = key in target;
        var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
        if (!has && !isAllowed) {
          warnNonPresent(target, key);
        }
        return has || !isAllowed;
      }
    };

    var getHandler = {
      get: function get(target, key) {
        if (typeof key === 'string' && !(key in target)) {
          warnNonPresent(target, key);
        }
        return target[key];
      }
    };

    initProxy = function initProxy(vm) {
      if (hasProxy) {
        // determine which proxy handler to use
        var options = vm.$options;
        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
        vm._renderProxy = new Proxy(vm, handlers);
      } else {
        vm._renderProxy = vm;
      }
    };
  }

  /*  */

  var seenObjects = new _Set();

  /**
   * Recursively traverse an object to evoke all converted
   * getters, so that every nested property inside the object
   * is collected as a "deep" dependency.
   */
  function traverse(val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
  }

  function _traverse(val, seen) {
    var i, keys;
    var isA = Array.isArray(val);
    if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
      return;
    }
    if (val.__ob__) {
      var depId = val.__ob__.dep.id;
      if (seen.has(depId)) {
        return;
      }
      seen.add(depId);
    }
    if (isA) {
      i = val.length;
      while (i--) {
        _traverse(val[i], seen);
      }
    } else {
      keys = Object.keys(val);
      i = keys.length;
      while (i--) {
        _traverse(val[keys[i]], seen);
      }
    }
  }

  /*  */

  var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once$$1 ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
      name: name,
      once: once$$1,
      capture: capture,
      passive: passive
    };
  });

  function createFnInvoker(fns) {
    function invoker() {
      var arguments$1 = arguments;

      var fns = invoker.fns;
      if (Array.isArray(fns)) {
        var cloned = fns.slice();
        for (var i = 0; i < cloned.length; i++) {
          cloned[i].apply(null, arguments$1);
        }
      } else {
        // return handler return value for single handlers
        return fns.apply(null, arguments);
      }
    }
    invoker.fns = fns;
    return invoker;
  }

  function updateListeners(on, oldOn, add, remove$$1, vm) {
    var name, def, cur, old, event;
    for (name in on) {
      def = cur = on[name];
      old = oldOn[name];
      event = normalizeEvent(name);
      /* istanbul ignore if */
      if (isUndef(cur)) {
        "development" !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
      } else if (isUndef(old)) {
        if (isUndef(cur.fns)) {
          cur = on[name] = createFnInvoker(cur);
        }
        add(event.name, cur, event.once, event.capture, event.passive, event.params);
      } else if (cur !== old) {
        old.fns = cur;
        on[name] = old;
      }
    }
    for (name in oldOn) {
      if (isUndef(on[name])) {
        event = normalizeEvent(name);
        remove$$1(event.name, oldOn[name], event.capture);
      }
    }
  }

  /*  */

  function mergeVNodeHook(def, hookKey, hook) {
    if (def instanceof VNode) {
      def = def.data.hook || (def.data.hook = {});
    }
    var invoker;
    var oldHook = def[hookKey];

    function wrappedHook() {
      hook.apply(this, arguments);
      // important: remove merged hook to ensure it's called only once
      // and prevent memory leak
      remove(invoker.fns, wrappedHook);
    }

    if (isUndef(oldHook)) {
      // no existing hook
      invoker = createFnInvoker([wrappedHook]);
    } else {
      /* istanbul ignore if */
      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
        // already a merged invoker
        invoker = oldHook;
        invoker.fns.push(wrappedHook);
      } else {
        // existing plain hook
        invoker = createFnInvoker([oldHook, wrappedHook]);
      }
    }

    invoker.merged = true;
    def[hookKey] = invoker;
  }

  /*  */

  function extractPropsFromVNodeData(data, Ctor, tag) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
      return;
    }
    var res = {};
    var attrs = data.attrs;
    var props = data.props;
    if (isDef(attrs) || isDef(props)) {
      for (var key in propOptions) {
        var altKey = hyphenate(key);
        {
          var keyInLowerCase = key.toLowerCase();
          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
            tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
          }
        }
        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
      }
    }
    return res;
  }

  function checkProp(res, hash, key, altKey, preserve) {
    if (isDef(hash)) {
      if (hasOwn(hash, key)) {
        res[key] = hash[key];
        if (!preserve) {
          delete hash[key];
        }
        return true;
      } else if (hasOwn(hash, altKey)) {
        res[key] = hash[altKey];
        if (!preserve) {
          delete hash[altKey];
        }
        return true;
      }
    }
    return false;
  }

  /*  */

  // The template compiler attempts to minimize the need for normalization by
  // statically analyzing the template at compile time.
  //
  // For plain HTML markup, normalization can be completely skipped because the
  // generated render function is guaranteed to return Array<VNode>. There are
  // two cases where extra normalization is needed:

  // 1. When the children contains components - because a functional component
  // may return an Array instead of a single root. In this case, just a simple
  // normalization is needed - if any child is an Array, we flatten the whole
  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
  // because functional components already normalize their own children.
  function simpleNormalizeChildren(children) {
    for (var i = 0; i < children.length; i++) {
      if (Array.isArray(children[i])) {
        return Array.prototype.concat.apply([], children);
      }
    }
    return children;
  }

  // 2. When the children contains constructs that always generated nested Arrays,
  // e.g. <template>, <slot>, v-for, or when the children is provided by user
  // with hand-written render functions / JSX. In such cases a full normalization
  // is needed to cater to all possible types of children values.
  function normalizeChildren(children) {
    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
  }

  function isTextNode(node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment);
  }

  function normalizeArrayChildren(children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
      c = children[i];
      if (isUndef(c) || typeof c === 'boolean') {
        continue;
      }
      lastIndex = res.length - 1;
      last = res[lastIndex];
      //  nested
      if (Array.isArray(c)) {
        if (c.length > 0) {
          c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i);
          // merge adjacent text nodes
          if (isTextNode(c[0]) && isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + c[0].text);
            c.shift();
          }
          res.push.apply(res, c);
        }
      } else if (isPrimitive(c)) {
        if (isTextNode(last)) {
          // merge adjacent text nodes
          // this is necessary for SSR hydration because text nodes are
          // essentially merged when rendered to HTML strings
          res[lastIndex] = createTextVNode(last.text + c);
        } else if (c !== '') {
          // convert primitive to vnode
          res.push(createTextVNode(c));
        }
      } else {
        if (isTextNode(c) && isTextNode(last)) {
          // merge adjacent text nodes
          res[lastIndex] = createTextVNode(last.text + c.text);
        } else {
          // default key for nested array children (likely generated by v-for)
          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
            c.key = "__vlist" + nestedIndex + "_" + i + "__";
          }
          res.push(c);
        }
      }
    }
    return res;
  }

  /*  */

  function ensureCtor(comp, base) {
    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
      comp = comp.default;
    }
    return isObject(comp) ? base.extend(comp) : comp;
  }

  function createAsyncPlaceholder(factory, data, context, children, tag) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
    return node;
  }

  function resolveAsyncComponent(factory, baseCtor, context) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
      return factory.errorComp;
    }

    if (isDef(factory.resolved)) {
      return factory.resolved;
    }

    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
      return factory.loadingComp;
    }

    if (isDef(factory.contexts)) {
      // already pending
      factory.contexts.push(context);
    } else {
      var contexts = factory.contexts = [context];
      var sync = true;

      var forceRender = function forceRender() {
        for (var i = 0, l = contexts.length; i < l; i++) {
          contexts[i].$forceUpdate();
        }
      };

      var resolve = once(function (res) {
        // cache resolved
        factory.resolved = ensureCtor(res, baseCtor);
        // invoke callbacks only if this is not a synchronous resolve
        // (async resolves are shimmed as synchronous during SSR)
        if (!sync) {
          forceRender();
        }
      });

      var reject = once(function (reason) {
        "development" !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
        if (isDef(factory.errorComp)) {
          factory.error = true;
          forceRender();
        }
      });

      var res = factory(resolve, reject);

      if (isObject(res)) {
        if (typeof res.then === 'function') {
          // () => Promise
          if (isUndef(factory.resolved)) {
            res.then(resolve, reject);
          }
        } else if (isDef(res.component) && typeof res.component.then === 'function') {
          res.component.then(resolve, reject);

          if (isDef(res.error)) {
            factory.errorComp = ensureCtor(res.error, baseCtor);
          }

          if (isDef(res.loading)) {
            factory.loadingComp = ensureCtor(res.loading, baseCtor);
            if (res.delay === 0) {
              factory.loading = true;
            } else {
              setTimeout(function () {
                if (isUndef(factory.resolved) && isUndef(factory.error)) {
                  factory.loading = true;
                  forceRender();
                }
              }, res.delay || 200);
            }
          }

          if (isDef(res.timeout)) {
            setTimeout(function () {
              if (isUndef(factory.resolved)) {
                reject("timeout (" + res.timeout + "ms)");
              }
            }, res.timeout);
          }
        }
      }

      sync = false;
      // return in case resolved synchronously
      return factory.loading ? factory.loadingComp : factory.resolved;
    }
  }

  /*  */

  function isAsyncPlaceholder(node) {
    return node.isComment && node.asyncFactory;
  }

  /*  */

  function getFirstComponentChild(children) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var c = children[i];
        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
          return c;
        }
      }
    }
  }

  /*  */

  /*  */

  function initEvents(vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    var listeners = vm.$options._parentListeners;
    if (listeners) {
      updateComponentListeners(vm, listeners);
    }
  }

  var target;

  function add(event, fn, once) {
    if (once) {
      target.$once(event, fn);
    } else {
      target.$on(event, fn);
    }
  }

  function remove$1(event, fn) {
    target.$off(event, fn);
  }

  function updateComponentListeners(vm, listeners, oldListeners) {
    target = vm;
    updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
    target = undefined;
  }

  function eventsMixin(Vue) {
    var hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
      var this$1 = this;

      var vm = this;
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          this$1.$on(event[i], fn);
        }
      } else {
        (vm._events[event] || (vm._events[event] = [])).push(fn);
        // optimize hook:event cost by using a boolean flag marked at registration
        // instead of a hash lookup
        if (hookRE.test(event)) {
          vm._hasHookEvent = true;
        }
      }
      return vm;
    };

    Vue.prototype.$once = function (event, fn) {
      var vm = this;
      function on() {
        vm.$off(event, on);
        fn.apply(vm, arguments);
      }
      on.fn = fn;
      vm.$on(event, on);
      return vm;
    };

    Vue.prototype.$off = function (event, fn) {
      var this$1 = this;

      var vm = this;
      // all
      if (!arguments.length) {
        vm._events = Object.create(null);
        return vm;
      }
      // array of events
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          this$1.$off(event[i], fn);
        }
        return vm;
      }
      // specific event
      var cbs = vm._events[event];
      if (!cbs) {
        return vm;
      }
      if (!fn) {
        vm._events[event] = null;
        return vm;
      }
      if (fn) {
        // specific handler
        var cb;
        var i$1 = cbs.length;
        while (i$1--) {
          cb = cbs[i$1];
          if (cb === fn || cb.fn === fn) {
            cbs.splice(i$1, 1);
            break;
          }
        }
      }
      return vm;
    };

    Vue.prototype.$emit = function (event) {
      var vm = this;
      {
        var lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
          tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
        }
      }
      var cbs = vm._events[event];
      if (cbs) {
        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
        var args = toArray(arguments, 1);
        for (var i = 0, l = cbs.length; i < l; i++) {
          try {
            cbs[i].apply(vm, args);
          } catch (e) {
            handleError(e, vm, "event handler for \"" + event + "\"");
          }
        }
      }
      return vm;
    };
  }

  /*  */

  /**
   * Runtime helper for resolving raw children VNodes into a slot object.
   */
  function resolveSlots(children, context) {
    var slots = {};
    if (!children) {
      return slots;
    }
    for (var i = 0, l = children.length; i < l; i++) {
      var child = children[i];
      var data = child.data;
      // remove slot attribute if the node is resolved as a Vue slot node
      if (data && data.attrs && data.attrs.slot) {
        delete data.attrs.slot;
      }
      // named slots should only be respected if the vnode was rendered in the
      // same context.
      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
        var name = data.slot;
        var slot = slots[name] || (slots[name] = []);
        if (child.tag === 'template') {
          slot.push.apply(slot, child.children || []);
        } else {
          slot.push(child);
        }
      } else {
        (slots.default || (slots.default = [])).push(child);
      }
    }
    // ignore slots that contains only whitespace
    for (var name$1 in slots) {
      if (slots[name$1].every(isWhitespace)) {
        delete slots[name$1];
      }
    }
    return slots;
  }

  function isWhitespace(node) {
    return node.isComment && !node.asyncFactory || node.text === ' ';
  }

  function resolveScopedSlots(fns, // see flow/vnode
  res) {
    res = res || {};
    for (var i = 0; i < fns.length; i++) {
      if (Array.isArray(fns[i])) {
        resolveScopedSlots(fns[i], res);
      } else {
        res[fns[i].key] = fns[i].fn;
      }
    }
    return res;
  }

  /*  */

  var activeInstance = null;
  var isUpdatingChildComponent = false;

  function initLifecycle(vm) {
    var options = vm.$options;

    // locate first non-abstract parent
    var parent = options.parent;
    if (parent && !options.abstract) {
      while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
      }
      parent.$children.push(vm);
    }

    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;

    vm.$children = [];
    vm.$refs = {};

    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
  }

  function lifecycleMixin(Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
      var vm = this;
      if (vm._isMounted) {
        callHook(vm, 'beforeUpdate');
      }
      var prevEl = vm.$el;
      var prevVnode = vm._vnode;
      var prevActiveInstance = activeInstance;
      activeInstance = vm;
      vm._vnode = vnode;
      // Vue.prototype.__patch__ is injected in entry points
      // based on the rendering backend used.
      if (!prevVnode) {
        // initial render
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
        , vm.$options._parentElm, vm.$options._refElm);
        // no need for the ref nodes after initial patch
        // this prevents keeping a detached DOM tree in memory (#5851)
        vm.$options._parentElm = vm.$options._refElm = null;
      } else {
        // updates
        vm.$el = vm.__patch__(prevVnode, vnode);
      }
      activeInstance = prevActiveInstance;
      // update __vue__ reference
      if (prevEl) {
        prevEl.__vue__ = null;
      }
      if (vm.$el) {
        vm.$el.__vue__ = vm;
      }
      // if parent is an HOC, update its $el as well
      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
        vm.$parent.$el = vm.$el;
      }
      // updated hook is called by the scheduler to ensure that children are
      // updated in a parent's updated hook.
    };

    Vue.prototype.$forceUpdate = function () {
      var vm = this;
      if (vm._watcher) {
        vm._watcher.update();
      }
    };

    Vue.prototype.$destroy = function () {
      var vm = this;
      if (vm._isBeingDestroyed) {
        return;
      }
      callHook(vm, 'beforeDestroy');
      vm._isBeingDestroyed = true;
      // remove self from parent
      var parent = vm.$parent;
      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
        remove(parent.$children, vm);
      }
      // teardown watchers
      if (vm._watcher) {
        vm._watcher.teardown();
      }
      var i = vm._watchers.length;
      while (i--) {
        vm._watchers[i].teardown();
      }
      // remove reference from data ob
      // frozen object may not have observer.
      if (vm._data.__ob__) {
        vm._data.__ob__.vmCount--;
      }
      // call the last hook...
      vm._isDestroyed = true;
      // invoke destroy hooks on current rendered tree
      vm.__patch__(vm._vnode, null);
      // fire destroyed hook
      callHook(vm, 'destroyed');
      // turn off all instance listeners.
      vm.$off();
      // remove __vue__ reference
      if (vm.$el) {
        vm.$el.__vue__ = null;
      }
      // release circular reference (#6759)
      if (vm.$vnode) {
        vm.$vnode.parent = null;
      }
    };
  }

  function mountComponent(vm, el, hydrating) {
    vm.$el = el;
    if (!vm.$options.render) {
      vm.$options.render = createEmptyVNode;
      {
        /* istanbul ignore if */
        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
        } else {
          warn('Failed to mount component: template or render function not defined.', vm);
        }
      }
    }
    callHook(vm, 'beforeMount');

    var updateComponent;
    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      updateComponent = function updateComponent() {
        var name = vm._name;
        var id = vm._uid;
        var startTag = "vue-perf-start:" + id;
        var endTag = "vue-perf-end:" + id;

        mark(startTag);
        var vnode = vm._render();
        mark(endTag);
        measure("vue " + name + " render", startTag, endTag);

        mark(startTag);
        vm._update(vnode, hydrating);
        mark(endTag);
        measure("vue " + name + " patch", startTag, endTag);
      };
    } else {
      updateComponent = function updateComponent() {
        vm._update(vm._render(), hydrating);
      };
    }

    // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined
    new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);
    hydrating = false;

    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
      vm._isMounted = true;
      callHook(vm, 'mounted');
    }
    return vm;
  }

  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
    {
      isUpdatingChildComponent = true;
    }

    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren
    var hasChildren = !!(renderChildren || // has new static slots
    vm.$options._renderChildren || // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
    );

    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render

    if (vm._vnode) {
      // update child tree's parent
      vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;

    // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    vm.$attrs = parentVnode.data.attrs || emptyObject;
    vm.$listeners = listeners || emptyObject;

    // update props
    if (propsData && vm.$options.props) {
      toggleObserving(false);
      var props = vm._props;
      var propKeys = vm.$options._propKeys || [];
      for (var i = 0; i < propKeys.length; i++) {
        var key = propKeys[i];
        var propOptions = vm.$options.props; // wtf flow?
        props[key] = validateProp(key, propOptions, propsData, vm);
      }
      toggleObserving(true);
      // keep a copy of raw propsData
      vm.$options.propsData = propsData;
    }

    // update listeners
    listeners = listeners || emptyObject;
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);

    // resolve slots + force update if has children
    if (hasChildren) {
      vm.$slots = resolveSlots(renderChildren, parentVnode.context);
      vm.$forceUpdate();
    }

    {
      isUpdatingChildComponent = false;
    }
  }

  function isInInactiveTree(vm) {
    while (vm && (vm = vm.$parent)) {
      if (vm._inactive) {
        return true;
      }
    }
    return false;
  }

  function activateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = false;
      if (isInInactiveTree(vm)) {
        return;
      }
    } else if (vm._directInactive) {
      return;
    }
    if (vm._inactive || vm._inactive === null) {
      vm._inactive = false;
      for (var i = 0; i < vm.$children.length; i++) {
        activateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'activated');
    }
  }

  function deactivateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = true;
      if (isInInactiveTree(vm)) {
        return;
      }
    }
    if (!vm._inactive) {
      vm._inactive = true;
      for (var i = 0; i < vm.$children.length; i++) {
        deactivateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'deactivated');
    }
  }

  function callHook(vm, hook) {
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    var handlers = vm.$options[hook];
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        try {
          handlers[i].call(vm);
        } catch (e) {
          handleError(e, vm, hook + " hook");
        }
      }
    }
    if (vm._hasHookEvent) {
      vm.$emit('hook:' + hook);
    }
    popTarget();
  }

  /*  */

  var MAX_UPDATE_COUNT = 100;

  var queue = [];
  var activatedChildren = [];
  var has = {};
  var circular = {};
  var waiting = false;
  var flushing = false;
  var index = 0;

  /**
   * Reset the scheduler's state.
   */
  function resetSchedulerState() {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    {
      circular = {};
    }
    waiting = flushing = false;
  }

  /**
   * Flush both queues and run the watchers.
   */
  function flushSchedulerQueue() {
    flushing = true;
    var watcher, id;

    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(function (a, b) {
      return a.id - b.id;
    });

    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index = 0; index < queue.length; index++) {
      watcher = queue[index];
      id = watcher.id;
      has[id] = null;
      watcher.run();
      // in dev build, check and stop circular updates.
      if ("development" !== 'production' && has[id] != null) {
        circular[id] = (circular[id] || 0) + 1;
        if (circular[id] > MAX_UPDATE_COUNT) {
          warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
          break;
        }
      }
    }

    // keep copies of post queues before resetting state
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();

    resetSchedulerState();

    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);

    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
      devtools.emit('flush');
    }
  }

  function callUpdatedHooks(queue) {
    var i = queue.length;
    while (i--) {
      var watcher = queue[i];
      var vm = watcher.vm;
      if (vm._watcher === watcher && vm._isMounted) {
        callHook(vm, 'updated');
      }
    }
  }

  /**
   * Queue a kept-alive component that was activated during patch.
   * The queue will be processed after the entire tree has been patched.
   */
  function queueActivatedComponent(vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
  }

  function callActivatedHooks(queue) {
    for (var i = 0; i < queue.length; i++) {
      queue[i]._inactive = true;
      activateChildComponent(queue[i], true /* true */);
    }
  }

  /**
   * Push a watcher into the watcher queue.
   * Jobs with duplicate IDs will be skipped unless it's
   * pushed when the queue is being flushed.
   */
  function queueWatcher(watcher) {
    var id = watcher.id;
    if (has[id] == null) {
      has[id] = true;
      if (!flushing) {
        queue.push(watcher);
      } else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        var i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
          i--;
        }
        queue.splice(i + 1, 0, watcher);
      }
      // queue the flush
      if (!waiting) {
        waiting = true;
        nextTick(flushSchedulerQueue);
      }
    }
  }

  /*  */

  var uid$1 = 0;

  /**
   * A watcher parses an expression, collects dependencies,
   * and fires callback when the expression value changes.
   * This is used for both the $watch() api and directives.
   */
  var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
    this.vm = vm;
    if (isRenderWatcher) {
      vm._watcher = this;
    }
    vm._watchers.push(this);
    // options
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$1; // uid for batching
    this.active = true;
    this.dirty = this.lazy; // for lazy watchers
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = expOrFn.toString();
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = function () {};
        "development" !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
      }
    }
    this.value = this.lazy ? undefined : this.get();
  };

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  Watcher.prototype.get = function get() {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      if (this.user) {
        handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
      } else {
        throw e;
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value);
      }
      popTarget();
      this.cleanupDeps();
    }
    return value;
  };

  /**
   * Add a dependency to this directive.
   */
  Watcher.prototype.addDep = function addDep(dep) {
    var id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  };

  /**
   * Clean up for dependency collection.
   */
  Watcher.prototype.cleanupDeps = function cleanupDeps() {
    var this$1 = this;

    var i = this.deps.length;
    while (i--) {
      var dep = this$1.deps[i];
      if (!this$1.newDepIds.has(dep.id)) {
        dep.removeSub(this$1);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  Watcher.prototype.update = function update() {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  Watcher.prototype.run = function run() {
    if (this.active) {
      var value = this.get();
      if (value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) || this.deep) {
        // set new value
        var oldValue = this.value;
        this.value = value;
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue);
          } catch (e) {
            handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
          }
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
  Watcher.prototype.evaluate = function evaluate() {
    this.value = this.get();
    this.dirty = false;
  };

  /**
   * Depend on all deps collected by this watcher.
   */
  Watcher.prototype.depend = function depend() {
    var this$1 = this;

    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].depend();
    }
  };

  /**
   * Remove self from all dependencies' subscriber list.
   */
  Watcher.prototype.teardown = function teardown() {
    var this$1 = this;

    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this);
      }
      var i = this.deps.length;
      while (i--) {
        this$1.deps[i].removeSub(this$1);
      }
      this.active = false;
    }
  };

  /*  */

  var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
  };

  function proxy(target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
      return this[sourceKey][key];
    };
    sharedPropertyDefinition.set = function proxySetter(val) {
      this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function initState(vm) {
    vm._watchers = [];
    var opts = vm.$options;
    if (opts.props) {
      initProps(vm, opts.props);
    }
    if (opts.methods) {
      initMethods(vm, opts.methods);
    }
    if (opts.data) {
      initData(vm);
    } else {
      observe(vm._data = {}, true /* asRootData */);
    }
    if (opts.computed) {
      initComputed(vm, opts.computed);
    }
    if (opts.watch && opts.watch !== nativeWatch) {
      initWatch(vm, opts.watch);
    }
  }

  function initProps(vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = vm._props = {};
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    var keys = vm.$options._propKeys = [];
    var isRoot = !vm.$parent;
    // root instance props should be converted
    if (!isRoot) {
      toggleObserving(false);
    }
    var loop = function loop(key) {
      keys.push(key);
      var value = validateProp(key, propsOptions, propsData, vm);
      /* istanbul ignore else */
      {
        var hyphenatedKey = hyphenate(key);
        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
          warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
        }
        defineReactive(props, key, value, function () {
          if (vm.$parent && !isUpdatingChildComponent) {
            warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
          }
        });
      }
      // static props are already proxied on the component's prototype
      // during Vue.extend(). We only need to proxy props defined at
      // instantiation here.
      if (!(key in vm)) {
        proxy(vm, "_props", key);
      }
    };

    for (var key in propsOptions) {
      loop(key);
    }toggleObserving(true);
  }

  function initData(vm) {
    var data = vm.$options.data;
    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
    if (!isPlainObject(data)) {
      data = {};
      "development" !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
    }
    // proxy data on instance
    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
      var key = keys[i];
      {
        if (methods && hasOwn(methods, key)) {
          warn("Method \"" + key + "\" has already been defined as a data property.", vm);
        }
      }
      if (props && hasOwn(props, key)) {
        "development" !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
      } else if (!isReserved(key)) {
        proxy(vm, "_data", key);
      }
    }
    // observe data
    observe(data, true /* asRootData */);
  }

  function getData(data, vm) {
    // #7573 disable dep collection when invoking data getters
    pushTarget();
    try {
      return data.call(vm, vm);
    } catch (e) {
      handleError(e, vm, "data()");
      return {};
    } finally {
      popTarget();
    }
  }

  var computedWatcherOptions = { lazy: true };

  function initComputed(vm, computed) {
    // $flow-disable-line
    var watchers = vm._computedWatchers = Object.create(null);
    // computed properties are just getters during SSR
    var isSSR = isServerRendering();

    for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === 'function' ? userDef : userDef.get;
      if ("development" !== 'production' && getter == null) {
        warn("Getter is missing for computed property \"" + key + "\".", vm);
      }

      if (!isSSR) {
        // create internal watcher for the computed property.
        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
      }

      // component-defined computed properties are already defined on the
      // component prototype. We only need to define computed properties defined
      // at instantiation here.
      if (!(key in vm)) {
        defineComputed(vm, key, userDef);
      } else {
        if (key in vm.$data) {
          warn("The computed property \"" + key + "\" is already defined in data.", vm);
        } else if (vm.$options.props && key in vm.$options.props) {
          warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
        }
      }
    }
  }

  function defineComputed(target, key, userDef) {
    var shouldCache = !isServerRendering();
    if (typeof userDef === 'function') {
      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;
      sharedPropertyDefinition.set = noop;
    } else {
      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
      sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
    }
    if ("development" !== 'production' && sharedPropertyDefinition.set === noop) {
      sharedPropertyDefinition.set = function () {
        warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
      };
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function createComputedGetter(key) {
    return function computedGetter() {
      var watcher = this._computedWatchers && this._computedWatchers[key];
      if (watcher) {
        if (watcher.dirty) {
          watcher.evaluate();
        }
        if (Dep.target) {
          watcher.depend();
        }
        return watcher.value;
      }
    };
  }

  function initMethods(vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
      {
        if (methods[key] == null) {
          warn("Method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
        }
        if (props && hasOwn(props, key)) {
          warn("Method \"" + key + "\" has already been defined as a prop.", vm);
        }
        if (key in vm && isReserved(key)) {
          warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
        }
      }
      vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    }
  }

  function initWatch(vm, watch) {
    for (var key in watch) {
      var handler = watch[key];
      if (Array.isArray(handler)) {
        for (var i = 0; i < handler.length; i++) {
          createWatcher(vm, key, handler[i]);
        }
      } else {
        createWatcher(vm, key, handler);
      }
    }
  }

  function createWatcher(vm, expOrFn, handler, options) {
    if (isPlainObject(handler)) {
      options = handler;
      handler = handler.handler;
    }
    if (typeof handler === 'string') {
      handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options);
  }

  function stateMixin(Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    var dataDef = {};
    dataDef.get = function () {
      return this._data;
    };
    var propsDef = {};
    propsDef.get = function () {
      return this._props;
    };
    {
      dataDef.set = function (newData) {
        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
      };
      propsDef.set = function () {
        warn("$props is readonly.", this);
      };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);

    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;

    Vue.prototype.$watch = function (expOrFn, cb, options) {
      var vm = this;
      if (isPlainObject(cb)) {
        return createWatcher(vm, expOrFn, cb, options);
      }
      options = options || {};
      options.user = true;
      var watcher = new Watcher(vm, expOrFn, cb, options);
      if (options.immediate) {
        cb.call(vm, watcher.value);
      }
      return function unwatchFn() {
        watcher.teardown();
      };
    };
  }

  /*  */

  function initProvide(vm) {
    var provide = vm.$options.provide;
    if (provide) {
      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
    }
  }

  function initInjections(vm) {
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
      toggleObserving(false);
      Object.keys(result).forEach(function (key) {
        /* istanbul ignore else */
        {
          defineReactive(vm, key, result[key], function () {
            warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
          });
        }
      });
      toggleObserving(true);
    }
  }

  function resolveInject(inject, vm) {
    if (inject) {
      // inject is :any because flow is not smart enough to figure out cached
      var result = Object.create(null);
      var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {
        /* istanbul ignore next */
        return Object.getOwnPropertyDescriptor(inject, key).enumerable;
      }) : Object.keys(inject);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var provideKey = inject[key].from;
        var source = vm;
        while (source) {
          if (source._provided && hasOwn(source._provided, provideKey)) {
            result[key] = source._provided[provideKey];
            break;
          }
          source = source.$parent;
        }
        if (!source) {
          if ('default' in inject[key]) {
            var provideDefault = inject[key].default;
            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
          } else {
            warn("Injection \"" + key + "\" not found", vm);
          }
        }
      }
      return result;
    }
  }

  /*  */

  /**
   * Runtime helper for rendering v-for lists.
   */
  function renderList(val, render) {
    var ret, i, l, keys, key;
    if (Array.isArray(val) || typeof val === 'string') {
      ret = new Array(val.length);
      for (i = 0, l = val.length; i < l; i++) {
        ret[i] = render(val[i], i);
      }
    } else if (typeof val === 'number') {
      ret = new Array(val);
      for (i = 0; i < val; i++) {
        ret[i] = render(i + 1, i);
      }
    } else if (isObject(val)) {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
    if (isDef(ret)) {
      ret._isVList = true;
    }
    return ret;
  }

  /*  */

  /**
   * Runtime helper for rendering <slot>
   */
  function renderSlot(name, fallback, props, bindObject) {
    var scopedSlotFn = this.$scopedSlots[name];
    var nodes;
    if (scopedSlotFn) {
      // scoped slot
      props = props || {};
      if (bindObject) {
        if ("development" !== 'production' && !isObject(bindObject)) {
          warn('slot v-bind without argument expects an Object', this);
        }
        props = extend(extend({}, bindObject), props);
      }
      nodes = scopedSlotFn(props) || fallback;
    } else {
      var slotNodes = this.$slots[name];
      // warn duplicate slot usage
      if (slotNodes) {
        if ("development" !== 'production' && slotNodes._rendered) {
          warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
        }
        slotNodes._rendered = true;
      }
      nodes = slotNodes || fallback;
    }

    var target = props && props.slot;
    if (target) {
      return this.$createElement('template', { slot: target }, nodes);
    } else {
      return nodes;
    }
  }

  /*  */

  /**
   * Runtime helper for resolving filters
   */
  function resolveFilter(id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity;
  }

  /*  */

  function isKeyNotMatch(expect, actual) {
    if (Array.isArray(expect)) {
      return expect.indexOf(actual) === -1;
    } else {
      return expect !== actual;
    }
  }

  /**
   * Runtime helper for checking keyCodes from config.
   * exposed as Vue.prototype._k
   * passing in eventKeyName as last argument separately for backwards compat
   */
  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
      return isKeyNotMatch(builtInKeyName, eventKeyName);
    } else if (mappedKeyCode) {
      return isKeyNotMatch(mappedKeyCode, eventKeyCode);
    } else if (eventKeyName) {
      return hyphenate(eventKeyName) !== key;
    }
  }

  /*  */

  /**
   * Runtime helper for merging v-bind="object" into a VNode's data.
   */
  function bindObjectProps(data, tag, value, asProp, isSync) {
    if (value) {
      if (!isObject(value)) {
        "development" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
      } else {
        if (Array.isArray(value)) {
          value = toObject(value);
        }
        var hash;
        var loop = function loop(key) {
          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
            hash = data;
          } else {
            var type = data.attrs && data.attrs.type;
            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
          }
          if (!(key in hash)) {
            hash[key] = value[key];

            if (isSync) {
              var on = data.on || (data.on = {});
              on["update:" + key] = function ($event) {
                value[key] = $event;
              };
            }
          }
        };

        for (var key in value) {
          loop(key);
        }
      }
    }
    return data;
  }

  /*  */

  /**
   * Runtime helper for rendering static trees.
   */
  function renderStatic(index, isInFor) {
    var cached = this._staticTrees || (this._staticTrees = []);
    var tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.
    if (tree && !isInFor) {
      return tree;
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
    );
    markStatic(tree, "__static__" + index, false);
    return tree;
  }

  /**
   * Runtime helper for v-once.
   * Effectively it means marking the node as static with a unique key.
   */
  function markOnce(tree, index, key) {
    markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
    return tree;
  }

  function markStatic(tree, key, isOnce) {
    if (Array.isArray(tree)) {
      for (var i = 0; i < tree.length; i++) {
        if (tree[i] && typeof tree[i] !== 'string') {
          markStaticNode(tree[i], key + "_" + i, isOnce);
        }
      }
    } else {
      markStaticNode(tree, key, isOnce);
    }
  }

  function markStaticNode(node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
  }

  /*  */

  function bindObjectListeners(data, value) {
    if (value) {
      if (!isPlainObject(value)) {
        "development" !== 'production' && warn('v-on without argument expects an Object value', this);
      } else {
        var on = data.on = data.on ? extend({}, data.on) : {};
        for (var key in value) {
          var existing = on[key];
          var ours = value[key];
          on[key] = existing ? [].concat(existing, ours) : ours;
        }
      }
    }
    return data;
  }

  /*  */

  function installRenderHelpers(target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
  }

  /*  */

  function FunctionalRenderContext(data, props, children, parent, Ctor) {
    var options = Ctor.options;
    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    var contextVm;
    if (hasOwn(parent, '_uid')) {
      contextVm = Object.create(parent);
      // $flow-disable-line
      contextVm._original = parent;
    } else {
      // the context vm passed in is a functional context as well.
      // in this case we want to make sure we are able to get a hold to the
      // real context instance.
      contextVm = parent;
      // $flow-disable-line
      parent = parent._original;
    }
    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;

    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = function () {
      return resolveSlots(children, parent);
    };

    // support for compiled functional template
    if (isCompiled) {
      // exposing $options for renderStatic()
      this.$options = options;
      // pre-resolve slots for renderSlot()
      this.$slots = this.slots();
      this.$scopedSlots = data.scopedSlots || emptyObject;
    }

    if (options._scopeId) {
      this._c = function (a, b, c, d) {
        var vnode = createElement(contextVm, a, b, c, d, needNormalization);
        if (vnode && !Array.isArray(vnode)) {
          vnode.fnScopeId = options._scopeId;
          vnode.fnContext = parent;
        }
        return vnode;
      };
    } else {
      this._c = function (a, b, c, d) {
        return createElement(contextVm, a, b, c, d, needNormalization);
      };
    }
  }

  installRenderHelpers(FunctionalRenderContext.prototype);

  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
    var options = Ctor.options;
    var props = {};
    var propOptions = options.props;
    if (isDef(propOptions)) {
      for (var key in propOptions) {
        props[key] = validateProp(key, propOptions, propsData || emptyObject);
      }
    } else {
      if (isDef(data.attrs)) {
        mergeProps(props, data.attrs);
      }
      if (isDef(data.props)) {
        mergeProps(props, data.props);
      }
    }

    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);

    var vnode = options.render.call(null, renderContext._c, renderContext);

    if (vnode instanceof VNode) {
      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options);
    } else if (Array.isArray(vnode)) {
      var vnodes = normalizeChildren(vnode) || [];
      var res = new Array(vnodes.length);
      for (var i = 0; i < vnodes.length; i++) {
        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);
      }
      return res;
    }
  }

  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options) {
    // #7817 clone node before setting fnContext, otherwise if the node is reused
    // (e.g. it was from a cached normal slot) the fnContext causes named slots
    // that should not be matched to match.
    var clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    if (data.slot) {
      (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone;
  }

  function mergeProps(to, from) {
    for (var key in from) {
      to[camelize(key)] = from[key];
    }
  }

  /*  */

  // Register the component hook to weex native render engine.
  // The hook will be triggered by native, not javascript.


  // Updates the state of the component to weex native render engine.

  /*  */

  // https://github.com/Hanks10100/weex-native-directive/tree/master/component

  // listening on native callback

  /*  */

  /*  */

  // inline hooks to be invoked on component VNodes during patch
  var componentVNodeHooks = {
    init: function init(vnode, hydrating, parentElm, refElm) {
      if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
        // kept-alive components, treat as a patch
        var mountedNode = vnode; // work around flow
        componentVNodeHooks.prepatch(mountedNode, mountedNode);
      } else {
        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
        child.$mount(hydrating ? vnode.elm : undefined, hydrating);
      }
    },

    prepatch: function prepatch(oldVnode, vnode) {
      var options = vnode.componentOptions;
      var child = vnode.componentInstance = oldVnode.componentInstance;
      updateChildComponent(child, options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
      );
    },

    insert: function insert(vnode) {
      var context = vnode.context;
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isMounted) {
        componentInstance._isMounted = true;
        callHook(componentInstance, 'mounted');
      }
      if (vnode.data.keepAlive) {
        if (context._isMounted) {
          // vue-router#1212
          // During updates, a kept-alive component's child components may
          // change, so directly walking the tree here may call activated hooks
          // on incorrect children. Instead we push them into a queue which will
          // be processed after the whole patch process ended.
          queueActivatedComponent(componentInstance);
        } else {
          activateChildComponent(componentInstance, true /* direct */);
        }
      }
    },

    destroy: function destroy(vnode) {
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isDestroyed) {
        if (!vnode.data.keepAlive) {
          componentInstance.$destroy();
        } else {
          deactivateChildComponent(componentInstance, true /* direct */);
        }
      }
    }
  };

  var hooksToMerge = Object.keys(componentVNodeHooks);

  function createComponent(Ctor, data, context, children, tag) {
    if (isUndef(Ctor)) {
      return;
    }

    var baseCtor = context.$options._base;

    // plain options object: turn it into a constructor
    if (isObject(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    }

    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
      {
        warn("Invalid Component definition: " + String(Ctor), context);
      }
      return;
    }

    // async component
    var asyncFactory;
    if (isUndef(Ctor.cid)) {
      asyncFactory = Ctor;
      Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
      if (Ctor === undefined) {
        // return a placeholder node for async component, which is rendered
        // as a comment node but preserves all the raw information for the node.
        // the information will be used for async server-rendering and hydration.
        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
      }
    }

    data = data || {};

    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);

    // transform component v-model data into props & events
    if (isDef(data.model)) {
      transformModel(Ctor.options, data);
    }

    // extract props
    var propsData = extractPropsFromVNodeData(data, Ctor, tag);

    // functional component
    if (isTrue(Ctor.options.functional)) {
      return createFunctionalComponent(Ctor, propsData, data, context, children);
    }

    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    var listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;

    if (isTrue(Ctor.options.abstract)) {
      // abstract components do not keep anything
      // other than props & listeners & slot

      // work around flow
      var slot = data.slot;
      data = {};
      if (slot) {
        data.slot = slot;
      }
    }

    // install component management hooks onto the placeholder node
    installComponentHooks(data);

    // return a placeholder vnode
    var name = Ctor.options.name || tag;
    var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);

    // Weex specific: invoke recycle-list optimized @render function for
    // extracting cell-slot template.
    // https://github.com/Hanks10100/weex-native-directive/tree/master/component
    /* istanbul ignore if */
    return vnode;
  }

  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm, refElm) {
    var options = {
      _isComponent: true,
      parent: parent,
      _parentVnode: vnode,
      _parentElm: parentElm || null,
      _refElm: refElm || null
    };
    // check inline-template render functions
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
      options.render = inlineTemplate.render;
      options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options);
  }

  function installComponentHooks(data) {
    var hooks = data.hook || (data.hook = {});
    for (var i = 0; i < hooksToMerge.length; i++) {
      var key = hooksToMerge[i];
      hooks[key] = componentVNodeHooks[key];
    }
  }

  // transform component v-model info (value and callback) into
  // prop and event handler respectively.
  function transformModel(options, data) {
    var prop = options.model && options.model.prop || 'value';
    var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    if (isDef(on[event])) {
      on[event] = [data.model.callback].concat(on[event]);
    } else {
      on[event] = data.model.callback;
    }
  }

  /*  */

  var SIMPLE_NORMALIZE = 1;
  var ALWAYS_NORMALIZE = 2;

  // wrapper function for providing a more flexible interface
  // without getting yelled at by flow
  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
    if (Array.isArray(data) || isPrimitive(data)) {
      normalizationType = children;
      children = data;
      data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
      normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType);
  }

  function _createElement(context, tag, data, children, normalizationType) {
    if (isDef(data) && isDef(data.__ob__)) {
      "development" !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
      return createEmptyVNode();
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
      tag = data.is;
    }
    if (!tag) {
      // in case of component :is set to falsy value
      return createEmptyVNode();
    }
    // warn against non-primitive key
    if ("development" !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
      {
        warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
      }
    }
    // support single function children as default scoped slot
    if (Array.isArray(children) && typeof children[0] === 'function') {
      data = data || {};
      data.scopedSlots = { default: children[0] };
      children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
      children = normalizeChildren(children);
    } else if (normalizationType === SIMPLE_NORMALIZE) {
      children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    if (typeof tag === 'string') {
      var Ctor;
      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
      if (config.isReservedTag(tag)) {
        // platform built-in elements
        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
      } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
        // component
        vnode = createComponent(Ctor, data, context, children, tag);
      } else {
        // unknown or unlisted namespaced elements
        // check at runtime because it may get assigned a namespace when its
        // parent normalizes children
        vnode = new VNode(tag, data, children, undefined, undefined, context);
      }
    } else {
      // direct component options / constructor
      vnode = createComponent(tag, data, context, children);
    }
    if (Array.isArray(vnode)) {
      return vnode;
    } else if (isDef(vnode)) {
      if (isDef(ns)) {
        applyNS(vnode, ns);
      }
      if (isDef(data)) {
        registerDeepBindings(data);
      }
      return vnode;
    } else {
      return createEmptyVNode();
    }
  }

  function applyNS(vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
      // use default namespace inside foreignObject
      ns = undefined;
      force = true;
    }
    if (isDef(vnode.children)) {
      for (var i = 0, l = vnode.children.length; i < l; i++) {
        var child = vnode.children[i];
        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
          applyNS(child, ns, force);
        }
      }
    }
  }

  // ref #5318
  // necessary to ensure parent re-render when deep bindings like :style and
  // :class are used on slot nodes
  function registerDeepBindings(data) {
    if (isObject(data.style)) {
      traverse(data.style);
    }
    if (isObject(data.class)) {
      traverse(data.class);
    }
  }

  /*  */

  function initRender(vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null; // v-once cached trees
    var options = vm.$options;
    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    vm._c = function (a, b, c, d) {
      return createElement(vm, a, b, c, d, false);
    };
    // normalization is always applied for the public version, used in
    // user-written render functions.
    vm.$createElement = function (a, b, c, d) {
      return createElement(vm, a, b, c, d, true);
    };

    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    var parentData = parentVnode && parentVnode.data;

    /* istanbul ignore else */
    {
      defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
        !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
      }, true);
      defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
        !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
      }, true);
    }
  }

  function renderMixin(Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);

    Vue.prototype.$nextTick = function (fn) {
      return nextTick(fn, this);
    };

    Vue.prototype._render = function () {
      var vm = this;
      var ref = vm.$options;
      var render = ref.render;
      var _parentVnode = ref._parentVnode;

      // reset _rendered flag on slots for duplicate slot check
      {
        for (var key in vm.$slots) {
          // $flow-disable-line
          vm.$slots[key]._rendered = false;
        }
      }

      if (_parentVnode) {
        vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;
      }

      // set parent vnode. this allows render functions to have access
      // to the data on the placeholder node.
      vm.$vnode = _parentVnode;
      // render self
      var vnode;
      try {
        vnode = render.call(vm._renderProxy, vm.$createElement);
      } catch (e) {
        handleError(e, vm, "render");
        // return error render result,
        // or previous vnode to prevent render error causing blank component
        /* istanbul ignore else */
        {
          if (vm.$options.renderError) {
            try {
              vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
            } catch (e) {
              handleError(e, vm, "renderError");
              vnode = vm._vnode;
            }
          } else {
            vnode = vm._vnode;
          }
        }
      }
      // return empty vnode in case the render function errored out
      if (!(vnode instanceof VNode)) {
        if ("development" !== 'production' && Array.isArray(vnode)) {
          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
        }
        vnode = createEmptyVNode();
      }
      // set parent
      vnode.parent = _parentVnode;
      return vnode;
    };
  }

  /*  */

  var uid$3 = 0;

  function initMixin(Vue) {
    Vue.prototype._init = function (options) {
      var vm = this;
      // a uid
      vm._uid = uid$3++;

      var startTag, endTag;
      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        startTag = "vue-perf-start:" + vm._uid;
        endTag = "vue-perf-end:" + vm._uid;
        mark(startTag);
      }

      // a flag to avoid this being observed
      vm._isVue = true;
      // merge options
      if (options && options._isComponent) {
        // optimize internal component instantiation
        // since dynamic options merging is pretty slow, and none of the
        // internal component options needs special treatment.
        initInternalComponent(vm, options);
      } else {
        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
      }
      /* istanbul ignore else */
      {
        initProxy(vm);
      }
      // expose real self
      vm._self = vm;
      initLifecycle(vm);
      initEvents(vm);
      initRender(vm);
      callHook(vm, 'beforeCreate');
      initInjections(vm); // resolve injections before data/props
      initState(vm);
      initProvide(vm); // resolve provide after data/props
      callHook(vm, 'created');

      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        vm._name = formatComponentName(vm, false);
        mark(endTag);
        measure("vue " + vm._name + " init", startTag, endTag);
      }

      if (vm.$options.el) {
        vm.$mount(vm.$options.el);
      }
    };
  }

  function initInternalComponent(vm, options) {
    var opts = vm.$options = Object.create(vm.constructor.options);
    // doing this because it's faster than dynamic enumeration.
    var parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;
    opts._parentElm = options._parentElm;
    opts._refElm = options._refElm;

    var vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;

    if (options.render) {
      opts.render = options.render;
      opts.staticRenderFns = options.staticRenderFns;
    }
  }

  function resolveConstructorOptions(Ctor) {
    var options = Ctor.options;
    if (Ctor.super) {
      var superOptions = resolveConstructorOptions(Ctor.super);
      var cachedSuperOptions = Ctor.superOptions;
      if (superOptions !== cachedSuperOptions) {
        // super option changed,
        // need to resolve new options.
        Ctor.superOptions = superOptions;
        // check if there are any late-modified/attached options (#4976)
        var modifiedOptions = resolveModifiedOptions(Ctor);
        // update base extend options
        if (modifiedOptions) {
          extend(Ctor.extendOptions, modifiedOptions);
        }
        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
        if (options.name) {
          options.components[options.name] = Ctor;
        }
      }
    }
    return options;
  }

  function resolveModifiedOptions(Ctor) {
    var modified;
    var latest = Ctor.options;
    var extended = Ctor.extendOptions;
    var sealed = Ctor.sealedOptions;
    for (var key in latest) {
      if (latest[key] !== sealed[key]) {
        if (!modified) {
          modified = {};
        }
        modified[key] = dedupe(latest[key], extended[key], sealed[key]);
      }
    }
    return modified;
  }

  function dedupe(latest, extended, sealed) {
    // compare latest and sealed to ensure lifecycle hooks won't be duplicated
    // between merges
    if (Array.isArray(latest)) {
      var res = [];
      sealed = Array.isArray(sealed) ? sealed : [sealed];
      extended = Array.isArray(extended) ? extended : [extended];
      for (var i = 0; i < latest.length; i++) {
        // push original options and not sealed options to exclude duplicated options
        if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
          res.push(latest[i]);
        }
      }
      return res;
    } else {
      return latest;
    }
  }

  function Vue(options) {
    if ("development" !== 'production' && !(this instanceof Vue)) {
      warn('Vue is a constructor and should be called with the `new` keyword');
    }
    this._init(options);
  }

  initMixin(Vue);
  stateMixin(Vue);
  eventsMixin(Vue);
  lifecycleMixin(Vue);
  renderMixin(Vue);

  /*  */

  function initUse(Vue) {
    Vue.use = function (plugin) {
      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
      if (installedPlugins.indexOf(plugin) > -1) {
        return this;
      }

      // additional parameters
      var args = toArray(arguments, 1);
      args.unshift(this);
      if (typeof plugin.install === 'function') {
        plugin.install.apply(plugin, args);
      } else if (typeof plugin === 'function') {
        plugin.apply(null, args);
      }
      installedPlugins.push(plugin);
      return this;
    };
  }

  /*  */

  function initMixin$1(Vue) {
    Vue.mixin = function (mixin) {
      this.options = mergeOptions(this.options, mixin);
      return this;
    };
  }

  /*  */

  function initExtend(Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    var cid = 1;

    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
      extendOptions = extendOptions || {};
      var Super = this;
      var SuperId = Super.cid;
      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
      if (cachedCtors[SuperId]) {
        return cachedCtors[SuperId];
      }

      var name = extendOptions.name || Super.options.name;
      if ("development" !== 'production' && name) {
        validateComponentName(name);
      }

      var Sub = function VueComponent(options) {
        this._init(options);
      };
      Sub.prototype = Object.create(Super.prototype);
      Sub.prototype.constructor = Sub;
      Sub.cid = cid++;
      Sub.options = mergeOptions(Super.options, extendOptions);
      Sub['super'] = Super;

      // For props and computed properties, we define the proxy getters on
      // the Vue instances at extension time, on the extended prototype. This
      // avoids Object.defineProperty calls for each instance created.
      if (Sub.options.props) {
        initProps$1(Sub);
      }
      if (Sub.options.computed) {
        initComputed$1(Sub);
      }

      // allow further extension/mixin/plugin usage
      Sub.extend = Super.extend;
      Sub.mixin = Super.mixin;
      Sub.use = Super.use;

      // create asset registers, so extended classes
      // can have their private assets too.
      ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type];
      });
      // enable recursive self-lookup
      if (name) {
        Sub.options.components[name] = Sub;
      }

      // keep a reference to the super options at extension time.
      // later at instantiation we can check if Super's options have
      // been updated.
      Sub.superOptions = Super.options;
      Sub.extendOptions = extendOptions;
      Sub.sealedOptions = extend({}, Sub.options);

      // cache constructor
      cachedCtors[SuperId] = Sub;
      return Sub;
    };
  }

  function initProps$1(Comp) {
    var props = Comp.options.props;
    for (var key in props) {
      proxy(Comp.prototype, "_props", key);
    }
  }

  function initComputed$1(Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
      defineComputed(Comp.prototype, key, computed[key]);
    }
  }

  /*  */

  function initAssetRegisters(Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(function (type) {
      Vue[type] = function (id, definition) {
        if (!definition) {
          return this.options[type + 's'][id];
        } else {
          /* istanbul ignore if */
          if ("development" !== 'production' && type === 'component') {
            validateComponentName(id);
          }
          if (type === 'component' && isPlainObject(definition)) {
            definition.name = definition.name || id;
            definition = this.options._base.extend(definition);
          }
          if (type === 'directive' && typeof definition === 'function') {
            definition = { bind: definition, update: definition };
          }
          this.options[type + 's'][id] = definition;
          return definition;
        }
      };
    });
  }

  /*  */

  function getComponentName(opts) {
    return opts && (opts.Ctor.options.name || opts.tag);
  }

  function matches(pattern, name) {
    if (Array.isArray(pattern)) {
      return pattern.indexOf(name) > -1;
    } else if (typeof pattern === 'string') {
      return pattern.split(',').indexOf(name) > -1;
    } else if (isRegExp(pattern)) {
      return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
  }

  function pruneCache(keepAliveInstance, filter) {
    var cache = keepAliveInstance.cache;
    var keys = keepAliveInstance.keys;
    var _vnode = keepAliveInstance._vnode;
    for (var key in cache) {
      var cachedNode = cache[key];
      if (cachedNode) {
        var name = getComponentName(cachedNode.componentOptions);
        if (name && !filter(name)) {
          pruneCacheEntry(cache, key, keys, _vnode);
        }
      }
    }
  }

  function pruneCacheEntry(cache, key, keys, current) {
    var cached$$1 = cache[key];
    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
      cached$$1.componentInstance.$destroy();
    }
    cache[key] = null;
    remove(keys, key);
  }

  var patternTypes = [String, RegExp, Array];

  var KeepAlive = {
    name: 'keep-alive',
    abstract: true,

    props: {
      include: patternTypes,
      exclude: patternTypes,
      max: [String, Number]
    },

    created: function created() {
      this.cache = Object.create(null);
      this.keys = [];
    },

    destroyed: function destroyed() {
      var this$1 = this;

      for (var key in this$1.cache) {
        pruneCacheEntry(this$1.cache, key, this$1.keys);
      }
    },

    mounted: function mounted() {
      var this$1 = this;

      this.$watch('include', function (val) {
        pruneCache(this$1, function (name) {
          return matches(val, name);
        });
      });
      this.$watch('exclude', function (val) {
        pruneCache(this$1, function (name) {
          return !matches(val, name);
        });
      });
    },

    render: function render() {
      var slot = this.$slots.default;
      var vnode = getFirstComponentChild(slot);
      var componentOptions = vnode && vnode.componentOptions;
      if (componentOptions) {
        // check pattern
        var name = getComponentName(componentOptions);
        var ref = this;
        var include = ref.include;
        var exclude = ref.exclude;
        if (
        // not included
        include && (!name || !matches(include, name)) ||
        // excluded
        exclude && name && matches(exclude, name)) {
          return vnode;
        }

        var ref$1 = this;
        var cache = ref$1.cache;
        var keys = ref$1.keys;
        var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
        if (cache[key]) {
          vnode.componentInstance = cache[key].componentInstance;
          // make current key freshest
          remove(keys, key);
          keys.push(key);
        } else {
          cache[key] = vnode;
          keys.push(key);
          // prune oldest entry
          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode);
          }
        }

        vnode.data.keepAlive = true;
      }
      return vnode || slot && slot[0];
    }
  };

  var builtInComponents = {
    KeepAlive: KeepAlive

    /*  */

  };function initGlobalAPI(Vue) {
    // config
    var configDef = {};
    configDef.get = function () {
      return config;
    };
    {
      configDef.set = function () {
        warn('Do not replace the Vue.config object, set individual fields instead.');
      };
    }
    Object.defineProperty(Vue, 'config', configDef);

    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
      warn: warn,
      extend: extend,
      mergeOptions: mergeOptions,
      defineReactive: defineReactive
    };

    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick;

    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
      Vue.options[type + 's'] = Object.create(null);
    });

    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;

    extend(Vue.options.components, builtInComponents);

    initUse(Vue);
    initMixin$1(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
  }

  initGlobalAPI(Vue);

  Object.defineProperty(Vue.prototype, '$isServer', {
    get: isServerRendering
  });

  Object.defineProperty(Vue.prototype, '$ssrContext', {
    get: function get() {
      /* istanbul ignore next */
      return this.$vnode && this.$vnode.ssrContext;
    }
  });

  // expose FunctionalRenderContext for ssr runtime helper installation
  Object.defineProperty(Vue, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
  });

  Vue.version = '2.5.16';

  /*  */

  // these are reserved for web because they are directly compiled away
  // during template compilation
  var isReservedAttr = makeMap('style,class');

  // attributes that should be using props for binding
  var acceptValue = makeMap('input,textarea,option,select,progress');
  var mustUseProp = function mustUseProp(tag, type, attr) {
    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
  };

  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

  var xlinkNS = 'http://www.w3.org/1999/xlink';

  var isXlink = function isXlink(name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
  };

  var getXlinkProp = function getXlinkProp(name) {
    return isXlink(name) ? name.slice(6, name.length) : '';
  };

  var isFalsyAttrValue = function isFalsyAttrValue(val) {
    return val == null || val === false;
  };

  /*  */

  function genClassForVnode(vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data) {
        data = mergeClassData(childNode.data, data);
      }
    }
    while (isDef(parentNode = parentNode.parent)) {
      if (parentNode && parentNode.data) {
        data = mergeClassData(data, parentNode.data);
      }
    }
    return renderClass(data.staticClass, data.class);
  }

  function mergeClassData(child, parent) {
    return {
      staticClass: concat(child.staticClass, parent.staticClass),
      class: isDef(child.class) ? [child.class, parent.class] : parent.class
    };
  }

  function renderClass(staticClass, dynamicClass) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
      return concat(staticClass, stringifyClass(dynamicClass));
    }
    /* istanbul ignore next */
    return '';
  }

  function concat(a, b) {
    return a ? b ? a + ' ' + b : a : b || '';
  }

  function stringifyClass(value) {
    if (Array.isArray(value)) {
      return stringifyArray(value);
    }
    if (isObject(value)) {
      return stringifyObject(value);
    }
    if (typeof value === 'string') {
      return value;
    }
    /* istanbul ignore next */
    return '';
  }

  function stringifyArray(value) {
    var res = '';
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
        if (res) {
          res += ' ';
        }
        res += stringified;
      }
    }
    return res;
  }

  function stringifyObject(value) {
    var res = '';
    for (var key in value) {
      if (value[key]) {
        if (res) {
          res += ' ';
        }
        res += key;
      }
    }
    return res;
  }

  /*  */

  var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
  };

  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');

  // this map is intentionally selective, only covering SVG elements that may
  // contain child elements.
  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

  var isPreTag = function isPreTag(tag) {
    return tag === 'pre';
  };

  var isReservedTag = function isReservedTag(tag) {
    return isHTMLTag(tag) || isSVG(tag);
  };

  function getTagNamespace(tag) {
    if (isSVG(tag)) {
      return 'svg';
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
      return 'math';
    }
  }

  var unknownElementCache = Object.create(null);
  function isUnknownElement(tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
      return true;
    }
    if (isReservedTag(tag)) {
      return false;
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
      return unknownElementCache[tag];
    }
    var el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
      // http://stackoverflow.com/a/28210364/1070244
      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
    } else {
      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
    }
  }

  var isTextInputType = makeMap('text,number,password,search,email,tel,url');

  /*  */

  /**
   * Query an element selector if it's not an element already.
   */
  function query(el) {
    if (typeof el === 'string') {
      var selected = document.querySelector(el);
      if (!selected) {
        "development" !== 'production' && warn('Cannot find element: ' + el);
        return document.createElement('div');
      }
      return selected;
    } else {
      return el;
    }
  }

  /*  */

  function createElement$1(tagName, vnode) {
    var elm = document.createElement(tagName);
    if (tagName !== 'select') {
      return elm;
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
      elm.setAttribute('multiple', 'multiple');
    }
    return elm;
  }

  function createElementNS(namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName);
  }

  function createTextNode(text) {
    return document.createTextNode(text);
  }

  function createComment(text) {
    return document.createComment(text);
  }

  function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
  }

  function removeChild(node, child) {
    node.removeChild(child);
  }

  function appendChild(node, child) {
    node.appendChild(child);
  }

  function parentNode(node) {
    return node.parentNode;
  }

  function nextSibling(node) {
    return node.nextSibling;
  }

  function tagName(node) {
    return node.tagName;
  }

  function setTextContent(node, text) {
    node.textContent = text;
  }

  function setStyleScope(node, scopeId) {
    node.setAttribute(scopeId, '');
  }

  var nodeOps = Object.freeze({
    createElement: createElement$1,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    setStyleScope: setStyleScope
  });

  /*  */

  var ref = {
    create: function create(_, vnode) {
      registerRef(vnode);
    },
    update: function update(oldVnode, vnode) {
      if (oldVnode.data.ref !== vnode.data.ref) {
        registerRef(oldVnode, true);
        registerRef(vnode);
      }
    },
    destroy: function destroy(vnode) {
      registerRef(vnode, true);
    }
  };

  function registerRef(vnode, isRemoval) {
    var key = vnode.data.ref;
    if (!isDef(key)) {
      return;
    }

    var vm = vnode.context;
    var ref = vnode.componentInstance || vnode.elm;
    var refs = vm.$refs;
    if (isRemoval) {
      if (Array.isArray(refs[key])) {
        remove(refs[key], ref);
      } else if (refs[key] === ref) {
        refs[key] = undefined;
      }
    } else {
      if (vnode.data.refInFor) {
        if (!Array.isArray(refs[key])) {
          refs[key] = [ref];
        } else if (refs[key].indexOf(ref) < 0) {
          // $flow-disable-line
          refs[key].push(ref);
        }
      } else {
        refs[key] = ref;
      }
    }
  }

  /**
   * Virtual DOM patching algorithm based on Snabbdom by
   * Simon Friis Vindum (@paldepind)
   * Licensed under the MIT License
   * https://github.com/paldepind/snabbdom/blob/master/LICENSE
   *
   * modified by Evan You (@yyx990803)
   *
   * Not type-checking this because this file is perf-critical and the cost
   * of making flow understand it is not worth it.
   */

  var emptyNode = new VNode('', {}, []);

  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

  function sameVnode(a, b) {
    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
  }

  function sameInputType(a, b) {
    if (a.tag !== 'input') {
      return true;
    }
    var i;
    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
  }

  function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
      key = children[i].key;
      if (isDef(key)) {
        map[key] = i;
      }
    }
    return map;
  }

  function createPatchFunction(backend) {
    var i, j;
    var cbs = {};

    var modules = backend.modules;
    var nodeOps = backend.nodeOps;

    for (i = 0; i < hooks.length; ++i) {
      cbs[hooks[i]] = [];
      for (j = 0; j < modules.length; ++j) {
        if (isDef(modules[j][hooks[i]])) {
          cbs[hooks[i]].push(modules[j][hooks[i]]);
        }
      }
    }

    function emptyNodeAt(elm) {
      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
    }

    function createRmCb(childElm, listeners) {
      function remove() {
        if (--remove.listeners === 0) {
          removeNode(childElm);
        }
      }
      remove.listeners = listeners;
      return remove;
    }

    function removeNode(el) {
      var parent = nodeOps.parentNode(el);
      // element may have already been removed due to v-html / v-text
      if (isDef(parent)) {
        nodeOps.removeChild(parent, el);
      }
    }

    function isUnknownElement$$1(vnode, inVPre) {
      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
      })) && config.isUnknownElement(vnode.tag);
    }

    var creatingElmInVPre = 0;

    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
      if (isDef(vnode.elm) && isDef(ownerArray)) {
        // This vnode was used in a previous render!
        // now it's used as a new node, overwriting its elm would cause
        // potential patch errors down the road when it's used as an insertion
        // reference node. Instead, we clone the node on-demand before creating
        // associated DOM element for it.
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      vnode.isRootInsert = !nested; // for transition enter check
      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return;
      }

      var data = vnode.data;
      var children = vnode.children;
      var tag = vnode.tag;
      if (isDef(tag)) {
        {
          if (data && data.pre) {
            creatingElmInVPre++;
          }
          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
          }
        }

        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
        setScope(vnode);

        /* istanbul ignore if */
        {
          createChildren(vnode, children, insertedVnodeQueue);
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }

        if ("development" !== 'production' && data && data.pre) {
          creatingElmInVPre--;
        }
      } else if (isTrue(vnode.isComment)) {
        vnode.elm = nodeOps.createComment(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      } else {
        vnode.elm = nodeOps.createTextNode(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      }
    }

    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i = vnode.data;
      if (isDef(i)) {
        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
        if (isDef(i = i.hook) && isDef(i = i.init)) {
          i(vnode, false /* hydrating */, parentElm, refElm);
        }
        // after calling the init hook, if the vnode is a child component
        // it should've created a child instance and mounted it. the child
        // component also has set the placeholder vnode's elm.
        // in that case we can just return the element and be done.
        if (isDef(vnode.componentInstance)) {
          initComponent(vnode, insertedVnodeQueue);
          if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }
          return true;
        }
      }
    }

    function initComponent(vnode, insertedVnodeQueue) {
      if (isDef(vnode.data.pendingInsert)) {
        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
        vnode.data.pendingInsert = null;
      }
      vnode.elm = vnode.componentInstance.$el;
      if (isPatchable(vnode)) {
        invokeCreateHooks(vnode, insertedVnodeQueue);
        setScope(vnode);
      } else {
        // empty component root.
        // skip all element-related modules except for ref (#3455)
        registerRef(vnode);
        // make sure to invoke the insert hook
        insertedVnodeQueue.push(vnode);
      }
    }

    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i;
      // hack for #4339: a reactivated component with inner transition
      // does not trigger because the inner node's created hooks are not called
      // again. It's not ideal to involve module-specific logic in here but
      // there doesn't seem to be a better way to do it.
      var innerNode = vnode;
      while (innerNode.componentInstance) {
        innerNode = innerNode.componentInstance._vnode;
        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
          for (i = 0; i < cbs.activate.length; ++i) {
            cbs.activate[i](emptyNode, innerNode);
          }
          insertedVnodeQueue.push(innerNode);
          break;
        }
      }
      // unlike a newly created component,
      // a reactivated keep-alive component doesn't insert itself
      insert(parentElm, vnode.elm, refElm);
    }

    function insert(parent, elm, ref$$1) {
      if (isDef(parent)) {
        if (isDef(ref$$1)) {
          if (ref$$1.parentNode === parent) {
            nodeOps.insertBefore(parent, elm, ref$$1);
          }
        } else {
          nodeOps.appendChild(parent, elm);
        }
      }
    }

    function createChildren(vnode, children, insertedVnodeQueue) {
      if (Array.isArray(children)) {
        {
          checkDuplicateKeys(children);
        }
        for (var i = 0; i < children.length; ++i) {
          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
        }
      } else if (isPrimitive(vnode.text)) {
        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
      }
    }

    function isPatchable(vnode) {
      while (vnode.componentInstance) {
        vnode = vnode.componentInstance._vnode;
      }
      return isDef(vnode.tag);
    }

    function invokeCreateHooks(vnode, insertedVnodeQueue) {
      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
        cbs.create[i$1](emptyNode, vnode);
      }
      i = vnode.data.hook; // Reuse variable
      if (isDef(i)) {
        if (isDef(i.create)) {
          i.create(emptyNode, vnode);
        }
        if (isDef(i.insert)) {
          insertedVnodeQueue.push(vnode);
        }
      }
    }

    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope(vnode) {
      var i;
      if (isDef(i = vnode.fnScopeId)) {
        nodeOps.setStyleScope(vnode.elm, i);
      } else {
        var ancestor = vnode;
        while (ancestor) {
          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
            nodeOps.setStyleScope(vnode.elm, i);
          }
          ancestor = ancestor.parent;
        }
      }
      // for slot content they should also get the scopeId from the host instance.
      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
        nodeOps.setStyleScope(vnode.elm, i);
      }
    }

    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
      for (; startIdx <= endIdx; ++startIdx) {
        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
      }
    }

    function invokeDestroyHook(vnode) {
      var i, j;
      var data = vnode.data;
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.destroy)) {
          i(vnode);
        }
        for (i = 0; i < cbs.destroy.length; ++i) {
          cbs.destroy[i](vnode);
        }
      }
      if (isDef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }

    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        var ch = vnodes[startIdx];
        if (isDef(ch)) {
          if (isDef(ch.tag)) {
            removeAndInvokeRemoveHook(ch);
            invokeDestroyHook(ch);
          } else {
            // Text node
            removeNode(ch.elm);
          }
        }
      }
    }

    function removeAndInvokeRemoveHook(vnode, rm) {
      if (isDef(rm) || isDef(vnode.data)) {
        var i;
        var listeners = cbs.remove.length + 1;
        if (isDef(rm)) {
          // we have a recursively passed down rm callback
          // increase the listeners count
          rm.listeners += listeners;
        } else {
          // directly removing
          rm = createRmCb(vnode.elm, listeners);
        }
        // recursively invoke hooks on child component root node
        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
          removeAndInvokeRemoveHook(i, rm);
        }
        for (i = 0; i < cbs.remove.length; ++i) {
          cbs.remove[i](vnode, rm);
        }
        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
          i(vnode, rm);
        } else {
          rm();
        }
      } else {
        removeNode(vnode.elm);
      }
    }

    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newEndIdx = newCh.length - 1;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

      // removeOnly is a special flag used only by <transition-group>
      // to ensure removed elements stay in correct relative positions
      // during leaving transitions
      var canMove = !removeOnly;

      {
        checkDuplicateKeys(newCh);
      }

      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (isUndef(oldStartVnode)) {
          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
        } else if (isUndef(oldEndVnode)) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (sameVnode(oldStartVnode, newStartVnode)) {
          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (sameVnode(oldEndVnode, newEndVnode)) {
          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldStartVnode, newEndVnode)) {
          // Vnode moved right
          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldEndVnode, newStartVnode)) {
          // Vnode moved left
          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          if (isUndef(oldKeyToIdx)) {
            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
          }
          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
          if (isUndef(idxInOld)) {
            // New element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          } else {
            vnodeToMove = oldCh[idxInOld];
            if (sameVnode(vnodeToMove, newStartVnode)) {
              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
              oldCh[idxInOld] = undefined;
              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
            } else {
              // same key but different element. treat as new element
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
            }
          }
          newStartVnode = newCh[++newStartIdx];
        }
      }
      if (oldStartIdx > oldEndIdx) {
        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }

    function checkDuplicateKeys(children) {
      var seenKeys = {};
      for (var i = 0; i < children.length; i++) {
        var vnode = children[i];
        var key = vnode.key;
        if (isDef(key)) {
          if (seenKeys[key]) {
            warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
          } else {
            seenKeys[key] = true;
          }
        }
      }
    }

    function findIdxInOld(node, oldCh, start, end) {
      for (var i = start; i < end; i++) {
        var c = oldCh[i];
        if (isDef(c) && sameVnode(node, c)) {
          return i;
        }
      }
    }

    function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
      if (oldVnode === vnode) {
        return;
      }

      var elm = vnode.elm = oldVnode.elm;

      if (isTrue(oldVnode.isAsyncPlaceholder)) {
        if (isDef(vnode.asyncFactory.resolved)) {
          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
        } else {
          vnode.isAsyncPlaceholder = true;
        }
        return;
      }

      // reuse element for static trees.
      // note we only do this if the vnode is cloned -
      // if the new node is not cloned it means the render functions have been
      // reset by the hot-reload-api and we need to do a proper re-render.
      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
        vnode.componentInstance = oldVnode.componentInstance;
        return;
      }

      var i;
      var data = vnode.data;
      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
        i(oldVnode, vnode);
      }

      var oldCh = oldVnode.children;
      var ch = vnode.children;
      if (isDef(data) && isPatchable(vnode)) {
        for (i = 0; i < cbs.update.length; ++i) {
          cbs.update[i](oldVnode, vnode);
        }
        if (isDef(i = data.hook) && isDef(i = i.update)) {
          i(oldVnode, vnode);
        }
      }
      if (isUndef(vnode.text)) {
        if (isDef(oldCh) && isDef(ch)) {
          if (oldCh !== ch) {
            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
          }
        } else if (isDef(ch)) {
          if (isDef(oldVnode.text)) {
            nodeOps.setTextContent(elm, '');
          }
          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
        } else if (isDef(oldCh)) {
          removeVnodes(elm, oldCh, 0, oldCh.length - 1);
        } else if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
      } else if (oldVnode.text !== vnode.text) {
        nodeOps.setTextContent(elm, vnode.text);
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
          i(oldVnode, vnode);
        }
      }
    }

    function invokeInsertHook(vnode, queue, initial) {
      // delay insert hooks for component root nodes, invoke them after the
      // element is really inserted
      if (isTrue(initial) && isDef(vnode.parent)) {
        vnode.parent.data.pendingInsert = queue;
      } else {
        for (var i = 0; i < queue.length; ++i) {
          queue[i].data.hook.insert(queue[i]);
        }
      }
    }

    var hydrationBailed = false;
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
      var i;
      var tag = vnode.tag;
      var data = vnode.data;
      var children = vnode.children;
      inVPre = inVPre || data && data.pre;
      vnode.elm = elm;

      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
        vnode.isAsyncPlaceholder = true;
        return true;
      }
      // assert node match
      {
        if (!assertNodeMatch(elm, vnode, inVPre)) {
          return false;
        }
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.init)) {
          i(vnode, true /* hydrating */);
        }
        if (isDef(i = vnode.componentInstance)) {
          // child component. it should have hydrated its own tree.
          initComponent(vnode, insertedVnodeQueue);
          return true;
        }
      }
      if (isDef(tag)) {
        if (isDef(children)) {
          // empty element, allow client to pick up and populate children
          if (!elm.hasChildNodes()) {
            createChildren(vnode, children, insertedVnodeQueue);
          } else {
            // v-html and domProps: innerHTML
            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
              if (i !== elm.innerHTML) {
                /* istanbul ignore if */
                if ("development" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                  hydrationBailed = true;
                  console.warn('Parent: ', elm);
                  console.warn('server innerHTML: ', i);
                  console.warn('client innerHTML: ', elm.innerHTML);
                }
                return false;
              }
            } else {
              // iterate and compare children lists
              var childrenMatch = true;
              var childNode = elm.firstChild;
              for (var i$1 = 0; i$1 < children.length; i$1++) {
                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                  childrenMatch = false;
                  break;
                }
                childNode = childNode.nextSibling;
              }
              // if childNode is not null, it means the actual childNodes list is
              // longer than the virtual children list.
              if (!childrenMatch || childNode) {
                /* istanbul ignore if */
                if ("development" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                  hydrationBailed = true;
                  console.warn('Parent: ', elm);
                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                }
                return false;
              }
            }
          }
        }
        if (isDef(data)) {
          var fullInvoke = false;
          for (var key in data) {
            if (!isRenderedModule(key)) {
              fullInvoke = true;
              invokeCreateHooks(vnode, insertedVnodeQueue);
              break;
            }
          }
          if (!fullInvoke && data['class']) {
            // ensure collecting deps for deep class bindings for future updates
            traverse(data['class']);
          }
        }
      } else if (elm.data !== vnode.text) {
        elm.data = vnode.text;
      }
      return true;
    }

    function assertNodeMatch(node, vnode, inVPre) {
      if (isDef(vnode.tag)) {
        return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
      } else {
        return node.nodeType === (vnode.isComment ? 8 : 3);
      }
    }

    return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
      if (isUndef(vnode)) {
        if (isDef(oldVnode)) {
          invokeDestroyHook(oldVnode);
        }
        return;
      }

      var isInitialPatch = false;
      var insertedVnodeQueue = [];

      if (isUndef(oldVnode)) {
        // empty mount (likely as component), create new root element
        isInitialPatch = true;
        createElm(vnode, insertedVnodeQueue, parentElm, refElm);
      } else {
        var isRealElement = isDef(oldVnode.nodeType);
        if (!isRealElement && sameVnode(oldVnode, vnode)) {
          // patch existing root node
          patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
        } else {
          if (isRealElement) {
            // mounting to a real element
            // check if this is server-rendered content and if we can perform
            // a successful hydration.
            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
              oldVnode.removeAttribute(SSR_ATTR);
              hydrating = true;
            }
            if (isTrue(hydrating)) {
              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                invokeInsertHook(vnode, insertedVnodeQueue, true);
                return oldVnode;
              } else {
                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
              }
            }
            // either not server-rendered, or hydration failed.
            // create an empty node and replace it
            oldVnode = emptyNodeAt(oldVnode);
          }

          // replacing existing element
          var oldElm = oldVnode.elm;
          var parentElm$1 = nodeOps.parentNode(oldElm);

          // create new node
          createElm(vnode, insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

          // update parent placeholder node element, recursively
          if (isDef(vnode.parent)) {
            var ancestor = vnode.parent;
            var patchable = isPatchable(vnode);
            while (ancestor) {
              for (var i = 0; i < cbs.destroy.length; ++i) {
                cbs.destroy[i](ancestor);
              }
              ancestor.elm = vnode.elm;
              if (patchable) {
                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                  cbs.create[i$1](emptyNode, ancestor);
                }
                // #6513
                // invoke insert hooks that may have been merged by create hooks.
                // e.g. for directives that uses the "inserted" hook.
                var insert = ancestor.data.hook.insert;
                if (insert.merged) {
                  // start at index 1 to avoid re-invoking component mounted hook
                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                    insert.fns[i$2]();
                  }
                }
              } else {
                registerRef(ancestor);
              }
              ancestor = ancestor.parent;
            }
          }

          // destroy old node
          if (isDef(parentElm$1)) {
            removeVnodes(parentElm$1, [oldVnode], 0, 0);
          } else if (isDef(oldVnode.tag)) {
            invokeDestroyHook(oldVnode);
          }
        }
      }

      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
      return vnode.elm;
    };
  }

  /*  */

  var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives(vnode) {
      updateDirectives(vnode, emptyNode);
    }
  };

  function updateDirectives(oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
      _update(oldVnode, vnode);
    }
  }

  function _update(oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

    var dirsWithInsert = [];
    var dirsWithPostpatch = [];

    var key, oldDir, dir;
    for (key in newDirs) {
      oldDir = oldDirs[key];
      dir = newDirs[key];
      if (!oldDir) {
        // new directive, bind
        callHook$1(dir, 'bind', vnode, oldVnode);
        if (dir.def && dir.def.inserted) {
          dirsWithInsert.push(dir);
        }
      } else {
        // existing directive, update
        dir.oldValue = oldDir.value;
        callHook$1(dir, 'update', vnode, oldVnode);
        if (dir.def && dir.def.componentUpdated) {
          dirsWithPostpatch.push(dir);
        }
      }
    }

    if (dirsWithInsert.length) {
      var callInsert = function callInsert() {
        for (var i = 0; i < dirsWithInsert.length; i++) {
          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
        }
      };
      if (isCreate) {
        mergeVNodeHook(vnode, 'insert', callInsert);
      } else {
        callInsert();
      }
    }

    if (dirsWithPostpatch.length) {
      mergeVNodeHook(vnode, 'postpatch', function () {
        for (var i = 0; i < dirsWithPostpatch.length; i++) {
          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
        }
      });
    }

    if (!isCreate) {
      for (key in oldDirs) {
        if (!newDirs[key]) {
          // no longer present, unbind
          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
        }
      }
    }
  }

  var emptyModifiers = Object.create(null);

  function normalizeDirectives$1(dirs, vm) {
    var res = Object.create(null);
    if (!dirs) {
      // $flow-disable-line
      return res;
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
      dir = dirs[i];
      if (!dir.modifiers) {
        // $flow-disable-line
        dir.modifiers = emptyModifiers;
      }
      res[getRawDirName(dir)] = dir;
      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    // $flow-disable-line
    return res;
  }

  function getRawDirName(dir) {
    return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
  }

  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];
    if (fn) {
      try {
        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
      } catch (e) {
        handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
      }
    }
  }

  var baseModules = [ref, directives];

  /*  */

  function updateAttrs(oldVnode, vnode) {
    var opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
      return;
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
      return;
    }
    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__)) {
      attrs = vnode.data.attrs = extend({}, attrs);
    }

    for (key in attrs) {
      cur = attrs[key];
      old = oldAttrs[key];
      if (old !== cur) {
        setAttr(elm, key, cur);
      }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max
    /* istanbul ignore if */
    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
      setAttr(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
      if (isUndef(attrs[key])) {
        if (isXlink(key)) {
          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } else if (!isEnumeratedAttr(key)) {
          elm.removeAttribute(key);
        }
      }
    }
  }

  function setAttr(el, key, value) {
    if (el.tagName.indexOf('-') > -1) {
      baseSetAttr(el, key, value);
    } else if (isBooleanAttr(key)) {
      // set attribute for blank value
      // e.g. <option disabled>Select one</option>
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        // technically allowfullscreen is a boolean attribute for <iframe>,
        // but Flash expects a value of "true" when used on <embed> tag
        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
        el.setAttribute(key, value);
      }
    } else if (isEnumeratedAttr(key)) {
      el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
    } else if (isXlink(key)) {
      if (isFalsyAttrValue(value)) {
        el.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      baseSetAttr(el, key, value);
    }
  }

  function baseSetAttr(el, key, value) {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // #7138: IE10 & 11 fires input event when setting placeholder on
      // <textarea>... block the first input event and remove the blocker
      // immediately.
      /* istanbul ignore if */
      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && !el.__ieph) {
        var blocker = function blocker(e) {
          e.stopImmediatePropagation();
          el.removeEventListener('input', blocker);
        };
        el.addEventListener('input', blocker);
        // $flow-disable-line
        el.__ieph = true; /* IE placeholder patched */
      }
      el.setAttribute(key, value);
    }
  }

  var attrs = {
    create: updateAttrs,
    update: updateAttrs

    /*  */

  };function updateClass(oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
      return;
    }

    var cls = genClassForVnode(vnode);

    // handle transition classes
    var transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
      cls = concat(cls, stringifyClass(transitionClass));
    }

    // set the class
    if (cls !== el._prevClass) {
      el.setAttribute('class', cls);
      el._prevClass = cls;
    }
  }

  var klass = {
    create: updateClass,
    update: updateClass

    /*  */

  };var validDivisionCharRE = /[\w).+\-_$\]]/;

  function parseFilters(exp) {
    var inSingle = false;
    var inDouble = false;
    var inTemplateString = false;
    var inRegex = false;
    var curly = 0;
    var square = 0;
    var paren = 0;
    var lastFilterIndex = 0;
    var c, prev, i, expression, filters;

    for (i = 0; i < exp.length; i++) {
      prev = c;
      c = exp.charCodeAt(i);
      if (inSingle) {
        if (c === 0x27 && prev !== 0x5C) {
          inSingle = false;
        }
      } else if (inDouble) {
        if (c === 0x22 && prev !== 0x5C) {
          inDouble = false;
        }
      } else if (inTemplateString) {
        if (c === 0x60 && prev !== 0x5C) {
          inTemplateString = false;
        }
      } else if (inRegex) {
        if (c === 0x2f && prev !== 0x5C) {
          inRegex = false;
        }
      } else if (c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
        if (expression === undefined) {
          // first filter, end of expression
          lastFilterIndex = i + 1;
          expression = exp.slice(0, i).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c) {
          case 0x22:
            inDouble = true;break; // "
          case 0x27:
            inSingle = true;break; // '
          case 0x60:
            inTemplateString = true;break; // `
          case 0x28:
            paren++;break; // (
          case 0x29:
            paren--;break; // )
          case 0x5B:
            square++;break; // [
          case 0x5D:
            square--;break; // ]
          case 0x7B:
            curly++;break; // {
          case 0x7D:
            curly--;break; // }
        }
        if (c === 0x2f) {
          // /
          var j = i - 1;
          var p = void 0;
          // find first non-whitespace prev char
          for (; j >= 0; j--) {
            p = exp.charAt(j);
            if (p !== ' ') {
              break;
            }
          }
          if (!p || !validDivisionCharRE.test(p)) {
            inRegex = true;
          }
        }
      }
    }

    if (expression === undefined) {
      expression = exp.slice(0, i).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }

    function pushFilter() {
      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
      lastFilterIndex = i + 1;
    }

    if (filters) {
      for (i = 0; i < filters.length; i++) {
        expression = wrapFilter(expression, filters[i]);
      }
    }

    return expression;
  }

  function wrapFilter(exp, filter) {
    var i = filter.indexOf('(');
    if (i < 0) {
      // _f: resolveFilter
      return "_f(\"" + filter + "\")(" + exp + ")";
    } else {
      var name = filter.slice(0, i);
      var args = filter.slice(i + 1);
      return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
    }
  }

  /*  */

  function baseWarn(msg) {
    console.error("[Vue compiler]: " + msg);
  }

  function pluckModuleFunction(modules, key) {
    return modules ? modules.map(function (m) {
      return m[key];
    }).filter(function (_) {
      return _;
    }) : [];
  }

  function addProp(el, name, value) {
    (el.props || (el.props = [])).push({ name: name, value: value });
    el.plain = false;
  }

  function addAttr(el, name, value) {
    (el.attrs || (el.attrs = [])).push({ name: name, value: value });
    el.plain = false;
  }

  // add a raw attr (use this in preTransforms)
  function addRawAttr(el, name, value) {
    el.attrsMap[name] = value;
    el.attrsList.push({ name: name, value: value });
  }

  function addDirective(el, name, rawName, value, arg, modifiers) {
    (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
    el.plain = false;
  }

  function addHandler(el, name, value, modifiers, important, warn) {
    modifiers = modifiers || emptyObject;
    // warn prevent and passive modifier
    /* istanbul ignore if */
    if ("development" !== 'production' && warn && modifiers.prevent && modifiers.passive) {
      warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.');
    }

    // check capture modifier
    if (modifiers.capture) {
      delete modifiers.capture;
      name = '!' + name; // mark the event as captured
    }
    if (modifiers.once) {
      delete modifiers.once;
      name = '~' + name; // mark the event as once
    }
    /* istanbul ignore if */
    if (modifiers.passive) {
      delete modifiers.passive;
      name = '&' + name; // mark the event as passive
    }

    // normalize click.right and click.middle since they don't actually fire
    // this is technically browser-specific, but at least for now browsers are
    // the only target envs that have right/middle clicks.
    if (name === 'click') {
      if (modifiers.right) {
        name = 'contextmenu';
        delete modifiers.right;
      } else if (modifiers.middle) {
        name = 'mouseup';
      }
    }

    var events;
    if (modifiers.native) {
      delete modifiers.native;
      events = el.nativeEvents || (el.nativeEvents = {});
    } else {
      events = el.events || (el.events = {});
    }

    var newHandler = {
      value: value.trim()
    };
    if (modifiers !== emptyObject) {
      newHandler.modifiers = modifiers;
    }

    var handlers = events[name];
    /* istanbul ignore if */
    if (Array.isArray(handlers)) {
      important ? handlers.unshift(newHandler) : handlers.push(newHandler);
    } else if (handlers) {
      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
    } else {
      events[name] = newHandler;
    }

    el.plain = false;
  }

  function getBindingAttr(el, name, getStatic) {
    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
    if (dynamicValue != null) {
      return parseFilters(dynamicValue);
    } else if (getStatic !== false) {
      var staticValue = getAndRemoveAttr(el, name);
      if (staticValue != null) {
        return JSON.stringify(staticValue);
      }
    }
  }

  // note: this only removes the attr from the Array (attrsList) so that it
  // doesn't get processed by processAttrs.
  // By default it does NOT remove it from the map (attrsMap) because the map is
  // needed during codegen.
  function getAndRemoveAttr(el, name, removeFromMap) {
    var val;
    if ((val = el.attrsMap[name]) != null) {
      var list = el.attrsList;
      for (var i = 0, l = list.length; i < l; i++) {
        if (list[i].name === name) {
          list.splice(i, 1);
          break;
        }
      }
    }
    if (removeFromMap) {
      delete el.attrsMap[name];
    }
    return val;
  }

  /*  */

  /**
   * Cross-platform code generation for component v-model
   */
  function genComponentModel(el, value, modifiers) {
    var ref = modifiers || {};
    var number = ref.number;
    var trim = ref.trim;

    var baseValueExpression = '$$v';
    var valueExpression = baseValueExpression;
    if (trim) {
      valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }
    var assignment = genAssignmentCode(value, valueExpression);

    el.model = {
      value: "(" + value + ")",
      expression: "\"" + value + "\"",
      callback: "function (" + baseValueExpression + ") {" + assignment + "}"
    };
  }

  /**
   * Cross-platform codegen helper for generating v-model value assignment code.
   */
  function genAssignmentCode(value, assignment) {
    var res = parseModel(value);
    if (res.key === null) {
      return value + "=" + assignment;
    } else {
      return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
    }
  }

  /**
   * Parse a v-model expression into a base path and a final key segment.
   * Handles both dot-path and possible square brackets.
   *
   * Possible cases:
   *
   * - test
   * - test[key]
   * - test[test1[key]]
   * - test["a"][key]
   * - xxx.test[a[a].test1[key]]
   * - test.xxx.a["asa"][test1[key]]
   *
   */

  var len;
  var str;
  var chr;
  var index$1;
  var expressionPos;
  var expressionEndPos;

  function parseModel(val) {
    // Fix https://github.com/vuejs/vue/pull/7730
    // allow v-model="obj.val " (trailing whitespace)
    val = val.trim();
    len = val.length;

    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
      index$1 = val.lastIndexOf('.');
      if (index$1 > -1) {
        return {
          exp: val.slice(0, index$1),
          key: '"' + val.slice(index$1 + 1) + '"'
        };
      } else {
        return {
          exp: val,
          key: null
        };
      }
    }

    str = val;
    index$1 = expressionPos = expressionEndPos = 0;

    while (!eof()) {
      chr = next();
      /* istanbul ignore if */
      if (isStringStart(chr)) {
        parseString(chr);
      } else if (chr === 0x5B) {
        parseBracket(chr);
      }
    }

    return {
      exp: val.slice(0, expressionPos),
      key: val.slice(expressionPos + 1, expressionEndPos)
    };
  }

  function next() {
    return str.charCodeAt(++index$1);
  }

  function eof() {
    return index$1 >= len;
  }

  function isStringStart(chr) {
    return chr === 0x22 || chr === 0x27;
  }

  function parseBracket(chr) {
    var inBracket = 1;
    expressionPos = index$1;
    while (!eof()) {
      chr = next();
      if (isStringStart(chr)) {
        parseString(chr);
        continue;
      }
      if (chr === 0x5B) {
        inBracket++;
      }
      if (chr === 0x5D) {
        inBracket--;
      }
      if (inBracket === 0) {
        expressionEndPos = index$1;
        break;
      }
    }
  }

  function parseString(chr) {
    var stringQuote = chr;
    while (!eof()) {
      chr = next();
      if (chr === stringQuote) {
        break;
      }
    }
  }

  /*  */

  var warn$1;

  // in some cases, the event used has to be determined at runtime
  // so we used some reserved tokens during compile.
  var RANGE_TOKEN = '__r';
  var CHECKBOX_RADIO_TOKEN = '__c';

  function model(el, dir, _warn) {
    warn$1 = _warn;
    var value = dir.value;
    var modifiers = dir.modifiers;
    var tag = el.tag;
    var type = el.attrsMap.type;

    {
      // inputs with type="file" are read only and setting the input's
      // value will throw an error.
      if (tag === 'input' && type === 'file') {
        warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
      }
    }

    if (el.component) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false;
    } else if (tag === 'select') {
      genSelect(el, value, modifiers);
    } else if (tag === 'input' && type === 'checkbox') {
      genCheckboxModel(el, value, modifiers);
    } else if (tag === 'input' && type === 'radio') {
      genRadioModel(el, value, modifiers);
    } else if (tag === 'input' || tag === 'textarea') {
      genDefaultModel(el, value, modifiers);
    } else if (!config.isReservedTag(tag)) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false;
    } else {
      warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
    }

    // ensure runtime directive metadata
    return true;
  }

  function genCheckboxModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
    addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
    addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
  }

  function genRadioModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
    addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
  }

  function genSelect(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
    var code = "var $$selectedVal = " + selectedVal + ";";
    code = code + " " + genAssignmentCode(value, assignment);
    addHandler(el, 'change', code, null, true);
  }

  function genDefaultModel(el, value, modifiers) {
    var type = el.attrsMap.type;

    // warn if v-bind:value conflicts with v-model
    // except for inputs with v-bind:type
    {
      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
      if (value$1 && !typeBinding) {
        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
        warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally');
      }
    }

    var ref = modifiers || {};
    var lazy = ref.lazy;
    var number = ref.number;
    var trim = ref.trim;
    var needCompositionGuard = !lazy && type !== 'range';
    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

    var valueExpression = '$event.target.value';
    if (trim) {
      valueExpression = "$event.target.value.trim()";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }

    var code = genAssignmentCode(value, valueExpression);
    if (needCompositionGuard) {
      code = "if($event.target.composing)return;" + code;
    }

    addProp(el, 'value', "(" + value + ")");
    addHandler(el, event, code, null, true);
    if (trim || number) {
      addHandler(el, 'blur', '$forceUpdate()');
    }
  }

  /*  */

  // normalize v-model event tokens that can only be determined at runtime.
  // it's important to place the event as the first in the array because
  // the whole point is ensuring the v-model callback gets called before
  // user-attached handlers.
  function normalizeEvents(on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
      // IE input[type=range] only supports `change` event
      var event = isIE ? 'change' : 'input';
      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
      delete on[RANGE_TOKEN];
    }
    // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
    /* istanbul ignore if */
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
      delete on[CHECKBOX_RADIO_TOKEN];
    }
  }

  var target$1;

  function createOnceHandler(handler, event, capture) {
    var _target = target$1; // save current target element in closure
    return function onceHandler() {
      var res = handler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, onceHandler, capture, _target);
      }
    };
  }

  function add$1(event, handler, once$$1, capture, passive) {
    handler = withMacroTask(handler);
    if (once$$1) {
      handler = createOnceHandler(handler, event, capture);
    }
    target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
  }

  function remove$2(event, handler, capture, _target) {
    (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);
  }

  function updateDOMListeners(oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
      return;
    }
    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    target$1 = vnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add$1, remove$2, vnode.context);
    target$1 = undefined;
  }

  var events = {
    create: updateDOMListeners,
    update: updateDOMListeners

    /*  */

  };function updateDOMProps(oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
      return;
    }
    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__)) {
      props = vnode.data.domProps = extend({}, props);
    }

    for (key in oldProps) {
      if (isUndef(props[key])) {
        elm[key] = '';
      }
    }
    for (key in props) {
      cur = props[key];
      // ignore children if the node has textContent or innerHTML,
      // as these will throw away existing DOM nodes and cause removal errors
      // on subsequent patches (#3360)
      if (key === 'textContent' || key === 'innerHTML') {
        if (vnode.children) {
          vnode.children.length = 0;
        }
        if (cur === oldProps[key]) {
          continue;
        }
        // #6601 work around Chrome version <= 55 bug where single textNode
        // replaced by innerHTML/textContent retains its parentNode property
        if (elm.childNodes.length === 1) {
          elm.removeChild(elm.childNodes[0]);
        }
      }

      if (key === 'value') {
        // store value as _value as well since
        // non-string values will be stringified
        elm._value = cur;
        // avoid resetting cursor position when value is the same
        var strCur = isUndef(cur) ? '' : String(cur);
        if (shouldUpdateValue(elm, strCur)) {
          elm.value = strCur;
        }
      } else {
        elm[key] = cur;
      }
    }
  }

  // check platforms/web/util/attrs.js acceptValue


  function shouldUpdateValue(elm, checkVal) {
    return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
  }

  function isNotInFocusAndDirty(elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try {
      notInFocus = document.activeElement !== elm;
    } catch (e) {}
    return notInFocus && elm.value !== checkVal;
  }

  function isDirtyWithModifiers(elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers)) {
      if (modifiers.lazy) {
        // inputs with lazy should only be updated when not in focus
        return false;
      }
      if (modifiers.number) {
        return toNumber(value) !== toNumber(newVal);
      }
      if (modifiers.trim) {
        return value.trim() !== newVal.trim();
      }
    }
    return value !== newVal;
  }

  var domProps = {
    create: updateDOMProps,
    update: updateDOMProps

    /*  */

  };var parseStyleText = cached(function (cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
      if (item) {
        var tmp = item.split(propertyDelimiter);
        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return res;
  });

  // merge static and dynamic style data on the same vnode
  function normalizeStyleData(data) {
    var style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle ? extend(data.staticStyle, style) : style;
  }

  // normalize possible array / string values into Object
  function normalizeStyleBinding(bindingStyle) {
    if (Array.isArray(bindingStyle)) {
      return toObject(bindingStyle);
    }
    if (typeof bindingStyle === 'string') {
      return parseStyleText(bindingStyle);
    }
    return bindingStyle;
  }

  /**
   * parent component style should be after child's
   * so that parent component's style could override it
   */
  function getStyle(vnode, checkChild) {
    var res = {};
    var styleData;

    if (checkChild) {
      var childNode = vnode;
      while (childNode.componentInstance) {
        childNode = childNode.componentInstance._vnode;
        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
          extend(res, styleData);
        }
      }
    }

    if (styleData = normalizeStyleData(vnode.data)) {
      extend(res, styleData);
    }

    var parentNode = vnode;
    while (parentNode = parentNode.parent) {
      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
        extend(res, styleData);
      }
    }
    return res;
  }

  /*  */

  var cssVarRE = /^--/;
  var importantRE = /\s*!important$/;
  var setProp = function setProp(el, name, val) {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
      el.style.setProperty(name, val);
    } else if (importantRE.test(val)) {
      el.style.setProperty(name, val.replace(importantRE, ''), 'important');
    } else {
      var normalizedName = normalize(name);
      if (Array.isArray(val)) {
        // Support values array created by autoprefixer, e.g.
        // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
        // Set them one by one, and the browser will only set those it can recognize
        for (var i = 0, len = val.length; i < len; i++) {
          el.style[normalizedName] = val[i];
        }
      } else {
        el.style[normalizedName] = val;
      }
    }
  };

  var vendorNames = ['Webkit', 'Moz', 'ms'];

  var emptyStyle;
  var normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && prop in emptyStyle) {
      return prop;
    }
    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = 0; i < vendorNames.length; i++) {
      var name = vendorNames[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  });

  function updateStyle(oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;

    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
      return;
    }

    var cur, name;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    var oldStyle = oldStaticStyle || oldStyleBinding;

    var style = normalizeStyleBinding(vnode.data.style) || {};

    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

    var newStyle = getStyle(vnode, true);

    for (name in oldStyle) {
      if (isUndef(newStyle[name])) {
        setProp(el, name, '');
      }
    }
    for (name in newStyle) {
      cur = newStyle[name];
      if (cur !== oldStyle[name]) {
        // ie9 setting to null has no effect, must use empty string
        setProp(el, name, cur == null ? '' : cur);
      }
    }
  }

  var style = {
    create: updateStyle,
    update: updateStyle

    /*  */

    /**
     * Add class with compatibility for SVG since classList is not supported on
     * SVG elements in IE
     */
  };function addClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return;
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(/\s+/).forEach(function (c) {
          return el.classList.add(c);
        });
      } else {
        el.classList.add(cls);
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      if (cur.indexOf(' ' + cls + ' ') < 0) {
        el.setAttribute('class', (cur + cls).trim());
      }
    }
  }

  /**
   * Remove class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function removeClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return;
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(/\s+/).forEach(function (c) {
          return el.classList.remove(c);
        });
      } else {
        el.classList.remove(cls);
      }
      if (!el.classList.length) {
        el.removeAttribute('class');
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      var tar = ' ' + cls + ' ';
      while (cur.indexOf(tar) >= 0) {
        cur = cur.replace(tar, ' ');
      }
      cur = cur.trim();
      if (cur) {
        el.setAttribute('class', cur);
      } else {
        el.removeAttribute('class');
      }
    }
  }

  /*  */

  function resolveTransition(def) {
    if (!def) {
      return;
    }
    /* istanbul ignore else */
    if ((typeof def === 'undefined' ? 'undefined' : _typeof(def)) === 'object') {
      var res = {};
      if (def.css !== false) {
        extend(res, autoCssTransition(def.name || 'v'));
      }
      extend(res, def);
      return res;
    } else if (typeof def === 'string') {
      return autoCssTransition(def);
    }
  }

  var autoCssTransition = cached(function (name) {
    return {
      enterClass: name + "-enter",
      enterToClass: name + "-enter-to",
      enterActiveClass: name + "-enter-active",
      leaveClass: name + "-leave",
      leaveToClass: name + "-leave-to",
      leaveActiveClass: name + "-leave-active"
    };
  });

  var hasTransition = inBrowser && !isIE9;
  var TRANSITION = 'transition';
  var ANIMATION = 'animation';

  // Transition property/event sniffing
  var transitionProp = 'transition';
  var transitionEndEvent = 'transitionend';
  var animationProp = 'animation';
  var animationEndEvent = 'animationend';
  if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
      transitionProp = 'WebkitTransition';
      transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
      animationProp = 'WebkitAnimation';
      animationEndEvent = 'webkitAnimationEnd';
    }
  }

  // binding to window is necessary to make hot reload work in IE in strict mode
  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {
    return fn();
  };

  function nextFrame(fn) {
    raf(function () {
      raf(fn);
    });
  }

  function addTransitionClass(el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
      transitionClasses.push(cls);
      addClass(el, cls);
    }
  }

  function removeTransitionClass(el, cls) {
    if (el._transitionClasses) {
      remove(el._transitionClasses, cls);
    }
    removeClass(el, cls);
  }

  function whenTransitionEnds(el, expectedType, cb) {
    var ref = getTransitionInfo(el, expectedType);
    var type = ref.type;
    var timeout = ref.timeout;
    var propCount = ref.propCount;
    if (!type) {
      return cb();
    }
    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;
    var end = function end() {
      el.removeEventListener(event, onEnd);
      cb();
    };
    var onEnd = function onEnd(e) {
      if (e.target === el) {
        if (++ended >= propCount) {
          end();
        }
      }
    };
    setTimeout(function () {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
  }

  var transformRE = /\b(transform|all)(,|$)/;

  function getTransitionInfo(el, expectedType) {
    var styles = window.getComputedStyle(el);
    var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
    var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = styles[animationProp + 'Delay'].split(', ');
    var animationDurations = styles[animationProp + 'Duration'].split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);

    var type;
    var timeout = 0;
    var propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
    return {
      type: type,
      timeout: timeout,
      propCount: propCount,
      hasTransform: hasTransform
    };
  }

  function getTimeout(delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }

    return Math.max.apply(null, durations.map(function (d, i) {
      return toMs(d) + toMs(delays[i]);
    }));
  }

  function toMs(s) {
    return Number(s.slice(0, -1)) * 1000;
  }

  /*  */

  function enter(vnode, toggleDisplay) {
    var el = vnode.elm;

    // call leave callback now
    if (isDef(el._leaveCb)) {
      el._leaveCb.cancelled = true;
      el._leaveCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
      return;
    }

    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
      return;
    }

    var css = data.css;
    var type = data.type;
    var enterClass = data.enterClass;
    var enterToClass = data.enterToClass;
    var enterActiveClass = data.enterActiveClass;
    var appearClass = data.appearClass;
    var appearToClass = data.appearToClass;
    var appearActiveClass = data.appearActiveClass;
    var beforeEnter = data.beforeEnter;
    var enter = data.enter;
    var afterEnter = data.afterEnter;
    var enterCancelled = data.enterCancelled;
    var beforeAppear = data.beforeAppear;
    var appear = data.appear;
    var afterAppear = data.afterAppear;
    var appearCancelled = data.appearCancelled;
    var duration = data.duration;

    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
      transitionNode = transitionNode.parent;
      context = transitionNode.context;
    }

    var isAppear = !context._isMounted || !vnode.isRootInsert;

    if (isAppear && !appear && appear !== '') {
      return;
    }

    var startClass = isAppear && appearClass ? appearClass : enterClass;
    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

    if ("development" !== 'production' && explicitEnterDuration != null) {
      checkDuration(explicitEnterDuration, 'enter', vnode);
    }

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);

    var cb = el._enterCb = once(function () {
      if (expectsCSS) {
        removeTransitionClass(el, toClass);
        removeTransitionClass(el, activeClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, startClass);
        }
        enterCancelledHook && enterCancelledHook(el);
      } else {
        afterEnterHook && afterEnterHook(el);
      }
      el._enterCb = null;
    });

    if (!vnode.data.show) {
      // remove pending leave element on enter by injecting an insert hook
      mergeVNodeHook(vnode, 'insert', function () {
        var parent = el.parentNode;
        var pendingNode = parent && parent._pending && parent._pending[vnode.key];
        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
          pendingNode.elm._leaveCb();
        }
        enterHook && enterHook(el, cb);
      });
    }

    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
      addTransitionClass(el, startClass);
      addTransitionClass(el, activeClass);
      nextFrame(function () {
        removeTransitionClass(el, startClass);
        if (!cb.cancelled) {
          addTransitionClass(el, toClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitEnterDuration)) {
              setTimeout(cb, explicitEnterDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    if (vnode.data.show) {
      toggleDisplay && toggleDisplay();
      enterHook && enterHook(el, cb);
    }

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }

  function leave(vnode, rm) {
    var el = vnode.elm;

    // call enter callback now
    if (isDef(el._enterCb)) {
      el._enterCb.cancelled = true;
      el._enterCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
      return rm();
    }

    /* istanbul ignore if */
    if (isDef(el._leaveCb)) {
      return;
    }

    var css = data.css;
    var type = data.type;
    var leaveClass = data.leaveClass;
    var leaveToClass = data.leaveToClass;
    var leaveActiveClass = data.leaveActiveClass;
    var beforeLeave = data.beforeLeave;
    var leave = data.leave;
    var afterLeave = data.afterLeave;
    var leaveCancelled = data.leaveCancelled;
    var delayLeave = data.delayLeave;
    var duration = data.duration;

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave);

    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

    if ("development" !== 'production' && isDef(explicitLeaveDuration)) {
      checkDuration(explicitLeaveDuration, 'leave', vnode);
    }

    var cb = el._leaveCb = once(function () {
      if (el.parentNode && el.parentNode._pending) {
        el.parentNode._pending[vnode.key] = null;
      }
      if (expectsCSS) {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, leaveClass);
        }
        leaveCancelled && leaveCancelled(el);
      } else {
        rm();
        afterLeave && afterLeave(el);
      }
      el._leaveCb = null;
    });

    if (delayLeave) {
      delayLeave(performLeave);
    } else {
      performLeave();
    }

    function performLeave() {
      // the delayed leave may have already been cancelled
      if (cb.cancelled) {
        return;
      }
      // record leaving element
      if (!vnode.data.show) {
        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
      }
      beforeLeave && beforeLeave(el);
      if (expectsCSS) {
        addTransitionClass(el, leaveClass);
        addTransitionClass(el, leaveActiveClass);
        nextFrame(function () {
          removeTransitionClass(el, leaveClass);
          if (!cb.cancelled) {
            addTransitionClass(el, leaveToClass);
            if (!userWantsControl) {
              if (isValidDuration(explicitLeaveDuration)) {
                setTimeout(cb, explicitLeaveDuration);
              } else {
                whenTransitionEnds(el, type, cb);
              }
            }
          }
        });
      }
      leave && leave(el, cb);
      if (!expectsCSS && !userWantsControl) {
        cb();
      }
    }
  }

  // only used in dev mode
  function checkDuration(val, name, vnode) {
    if (typeof val !== 'number') {
      warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
    } else if (isNaN(val)) {
      warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
    }
  }

  function isValidDuration(val) {
    return typeof val === 'number' && !isNaN(val);
  }

  /**
   * Normalize a transition hook's argument length. The hook may be:
   * - a merged hook (invoker) with the original in .fns
   * - a wrapped component method (check ._length)
   * - a plain function (.length)
   */
  function getHookArgumentsLength(fn) {
    if (isUndef(fn)) {
      return false;
    }
    var invokerFns = fn.fns;
    if (isDef(invokerFns)) {
      // invoker
      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
    } else {
      return (fn._length || fn.length) > 1;
    }
  }

  function _enter(_, vnode) {
    if (vnode.data.show !== true) {
      enter(vnode);
    }
  }

  var transition = inBrowser ? {
    create: _enter,
    activate: _enter,
    remove: function remove$$1(vnode, rm) {
      /* istanbul ignore else */
      if (vnode.data.show !== true) {
        leave(vnode, rm);
      } else {
        rm();
      }
    }
  } : {};

  var platformModules = [attrs, klass, events, domProps, style, transition];

  /*  */

  // the directive module should be applied last, after all
  // built-in modules have been applied.
  var modules = platformModules.concat(baseModules);

  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

  /**
   * Not type checking this file because flow doesn't like attaching
   * properties to Elements.
   */

  /* istanbul ignore if */
  if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', function () {
      var el = document.activeElement;
      if (el && el.vmodel) {
        trigger(el, 'input');
      }
    });
  }

  var directive = {
    inserted: function inserted(el, binding, vnode, oldVnode) {
      if (vnode.tag === 'select') {
        // #6903
        if (oldVnode.elm && !oldVnode.elm._vOptions) {
          mergeVNodeHook(vnode, 'postpatch', function () {
            directive.componentUpdated(el, binding, vnode);
          });
        } else {
          setSelected(el, binding, vnode.context);
        }
        el._vOptions = [].map.call(el.options, getValue);
      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
        el._vModifiers = binding.modifiers;
        if (!binding.modifiers.lazy) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
          // Safari < 10.2 & UIWebView doesn't fire compositionend when
          // switching focus before confirming composition choice
          // this also fixes the issue where some browsers e.g. iOS Chrome
          // fires "change" instead of "input" on autocomplete.
          el.addEventListener('change', onCompositionEnd);
          /* istanbul ignore if */
          if (isIE9) {
            el.vmodel = true;
          }
        }
      }
    },

    componentUpdated: function componentUpdated(el, binding, vnode) {
      if (vnode.tag === 'select') {
        setSelected(el, binding, vnode.context);
        // in case the options rendered by v-for have changed,
        // it's possible that the value is out-of-sync with the rendered options.
        // detect such cases and filter out values that no longer has a matching
        // option in the DOM.
        var prevOptions = el._vOptions;
        var curOptions = el._vOptions = [].map.call(el.options, getValue);
        if (curOptions.some(function (o, i) {
          return !looseEqual(o, prevOptions[i]);
        })) {
          // trigger change event if
          // no matching option found for at least one value
          var needReset = el.multiple ? binding.value.some(function (v) {
            return hasNoMatchingOption(v, curOptions);
          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
          if (needReset) {
            trigger(el, 'change');
          }
        }
      }
    }
  };

  function setSelected(el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    /* istanbul ignore if */
    if (isIE || isEdge) {
      setTimeout(function () {
        actuallySetSelected(el, binding, vm);
      }, 0);
    }
  }

  function actuallySetSelected(el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
      "development" !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
      return;
    }
    var selected, option;
    for (var i = 0, l = el.options.length; i < l; i++) {
      option = el.options[i];
      if (isMultiple) {
        selected = looseIndexOf(value, getValue(option)) > -1;
        if (option.selected !== selected) {
          option.selected = selected;
        }
      } else {
        if (looseEqual(getValue(option), value)) {
          if (el.selectedIndex !== i) {
            el.selectedIndex = i;
          }
          return;
        }
      }
    }
    if (!isMultiple) {
      el.selectedIndex = -1;
    }
  }

  function hasNoMatchingOption(value, options) {
    return options.every(function (o) {
      return !looseEqual(o, value);
    });
  }

  function getValue(option) {
    return '_value' in option ? option._value : option.value;
  }

  function onCompositionStart(e) {
    e.target.composing = true;
  }

  function onCompositionEnd(e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing) {
      return;
    }
    e.target.composing = false;
    trigger(e.target, 'input');
  }

  function trigger(el, type) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
  }

  /*  */

  // recursively search for possible transition defined inside the component root
  function locateNode(vnode) {
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
  }

  var show = {
    bind: function bind(el, ref, vnode) {
      var value = ref.value;

      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
      if (value && transition$$1) {
        vnode.data.show = true;
        enter(vnode, function () {
          el.style.display = originalDisplay;
        });
      } else {
        el.style.display = value ? originalDisplay : 'none';
      }
    },

    update: function update(el, ref, vnode) {
      var value = ref.value;
      var oldValue = ref.oldValue;

      /* istanbul ignore if */
      if (!value === !oldValue) {
        return;
      }
      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      if (transition$$1) {
        vnode.data.show = true;
        if (value) {
          enter(vnode, function () {
            el.style.display = el.__vOriginalDisplay;
          });
        } else {
          leave(vnode, function () {
            el.style.display = 'none';
          });
        }
      } else {
        el.style.display = value ? el.__vOriginalDisplay : 'none';
      }
    },

    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
      if (!isDestroy) {
        el.style.display = el.__vOriginalDisplay;
      }
    }
  };

  var platformDirectives = {
    model: directive,
    show: show

    /*  */

    // Provides transition support for a single element/component.
    // supports transition mode (out-in / in-out)

  };var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
  };

  // in case the child is also an abstract component, e.g. <keep-alive>
  // we want to recursively retrieve the real component to be rendered
  function getRealChild(vnode) {
    var compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
      return getRealChild(getFirstComponentChild(compOptions.children));
    } else {
      return vnode;
    }
  }

  function extractTransitionData(comp) {
    var data = {};
    var options = comp.$options;
    // props
    for (var key in options.propsData) {
      data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    var listeners = options._parentListeners;
    for (var key$1 in listeners) {
      data[camelize(key$1)] = listeners[key$1];
    }
    return data;
  }

  function placeholder(h, rawChild) {
    if (/\d-keep-alive$/.test(rawChild.tag)) {
      return h('keep-alive', {
        props: rawChild.componentOptions.propsData
      });
    }
  }

  function hasParentTransition(vnode) {
    while (vnode = vnode.parent) {
      if (vnode.data.transition) {
        return true;
      }
    }
  }

  function isSameChild(child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag;
  }

  var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,

    render: function render(h) {
      var this$1 = this;

      var children = this.$slots.default;
      if (!children) {
        return;
      }

      // filter out text nodes (possible whitespaces)
      children = children.filter(function (c) {
        return c.tag || isAsyncPlaceholder(c);
      });
      /* istanbul ignore if */
      if (!children.length) {
        return;
      }

      // warn multiple elements
      if ("development" !== 'production' && children.length > 1) {
        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
      }

      var mode = this.mode;

      // warn invalid mode
      if ("development" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
        warn('invalid <transition> mode: ' + mode, this.$parent);
      }

      var rawChild = children[0];

      // if this is a component root node and the component's
      // parent container node also has transition, skip.
      if (hasParentTransition(this.$vnode)) {
        return rawChild;
      }

      // apply transition data to child
      // use getRealChild() to ignore abstract components e.g. keep-alive
      var child = getRealChild(rawChild);
      /* istanbul ignore if */
      if (!child) {
        return rawChild;
      }

      if (this._leaving) {
        return placeholder(h, rawChild);
      }

      // ensure a key that is unique to the vnode type and to this transition
      // component instance. This key will be used to remove pending leaving nodes
      // during entering.
      var id = "__transition-" + this._uid + "-";
      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
      var oldRawChild = this._vnode;
      var oldChild = getRealChild(oldRawChild);

      // mark v-show
      // so that the transition module can hand over the control to the directive
      if (child.data.directives && child.data.directives.some(function (d) {
        return d.name === 'show';
      })) {
        child.data.show = true;
      }

      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
        // replace old child transition data with fresh one
        // important for dynamic transitions!
        var oldData = oldChild.data.transition = extend({}, data);
        // handle transition mode
        if (mode === 'out-in') {
          // return placeholder node and queue update when leave finishes
          this._leaving = true;
          mergeVNodeHook(oldData, 'afterLeave', function () {
            this$1._leaving = false;
            this$1.$forceUpdate();
          });
          return placeholder(h, rawChild);
        } else if (mode === 'in-out') {
          if (isAsyncPlaceholder(child)) {
            return oldRawChild;
          }
          var delayedLeave;
          var performLeave = function performLeave() {
            delayedLeave();
          };
          mergeVNodeHook(data, 'afterEnter', performLeave);
          mergeVNodeHook(data, 'enterCancelled', performLeave);
          mergeVNodeHook(oldData, 'delayLeave', function (leave) {
            delayedLeave = leave;
          });
        }
      }

      return rawChild;
    }

    /*  */

    // Provides transition support for list items.
    // supports move transitions using the FLIP technique.

    // Because the vdom's children update algorithm is "unstable" - i.e.
    // it doesn't guarantee the relative positioning of removed elements,
    // we force transition-group to update its children into two passes:
    // in the first pass, we remove all nodes that need to be removed,
    // triggering their leaving transition; in the second pass, we insert/move
    // into the final desired state. This way in the second pass removed
    // nodes will remain where they should be.

  };var props = extend({
    tag: String,
    moveClass: String
  }, transitionProps);

  delete props.mode;

  var TransitionGroup = {
    props: props,

    render: function render(h) {
      var tag = this.tag || this.$vnode.data.tag || 'span';
      var map = Object.create(null);
      var prevChildren = this.prevChildren = this.children;
      var rawChildren = this.$slots.default || [];
      var children = this.children = [];
      var transitionData = extractTransitionData(this);

      for (var i = 0; i < rawChildren.length; i++) {
        var c = rawChildren[i];
        if (c.tag) {
          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
            children.push(c);
            map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
          } else {
            var opts = c.componentOptions;
            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
            warn("<transition-group> children must be keyed: <" + name + ">");
          }
        }
      }

      if (prevChildren) {
        var kept = [];
        var removed = [];
        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
          var c$1 = prevChildren[i$1];
          c$1.data.transition = transitionData;
          c$1.data.pos = c$1.elm.getBoundingClientRect();
          if (map[c$1.key]) {
            kept.push(c$1);
          } else {
            removed.push(c$1);
          }
        }
        this.kept = h(tag, null, kept);
        this.removed = removed;
      }

      return h(tag, null, children);
    },

    beforeUpdate: function beforeUpdate() {
      // force removing pass
      this.__patch__(this._vnode, this.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );
      this._vnode = this.kept;
    },

    updated: function updated() {
      var children = this.prevChildren;
      var moveClass = this.moveClass || (this.name || 'v') + '-move';
      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
        return;
      }

      // we divide the work into three loops to avoid mixing DOM reads and writes
      // in each iteration - which helps prevent layout thrashing.
      children.forEach(callPendingCbs);
      children.forEach(recordPosition);
      children.forEach(applyTranslation);

      // force reflow to put everything in position
      // assign to this to avoid being removed in tree-shaking
      // $flow-disable-line
      this._reflow = document.body.offsetHeight;

      children.forEach(function (c) {
        if (c.data.moved) {
          var el = c.elm;
          var s = el.style;
          addTransitionClass(el, moveClass);
          s.transform = s.WebkitTransform = s.transitionDuration = '';
          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener(transitionEndEvent, cb);
              el._moveCb = null;
              removeTransitionClass(el, moveClass);
            }
          });
        }
      });
    },

    methods: {
      hasMove: function hasMove(el, moveClass) {
        /* istanbul ignore if */
        if (!hasTransition) {
          return false;
        }
        /* istanbul ignore if */
        if (this._hasMove) {
          return this._hasMove;
        }
        // Detect whether an element with the move class applied has
        // CSS transitions. Since the element may be inside an entering
        // transition at this very moment, we make a clone of it and remove
        // all other transition classes applied to ensure only the move class
        // is applied.
        var clone = el.cloneNode();
        if (el._transitionClasses) {
          el._transitionClasses.forEach(function (cls) {
            removeClass(clone, cls);
          });
        }
        addClass(clone, moveClass);
        clone.style.display = 'none';
        this.$el.appendChild(clone);
        var info = getTransitionInfo(clone);
        this.$el.removeChild(clone);
        return this._hasMove = info.hasTransform;
      }
    }
  };

  function callPendingCbs(c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
      c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
      c.elm._enterCb();
    }
  }

  function recordPosition(c) {
    c.data.newPos = c.elm.getBoundingClientRect();
  }

  function applyTranslation(c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
      c.data.moved = true;
      var s = c.elm.style;
      s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
      s.transitionDuration = '0s';
    }
  }

  var platformComponents = {
    Transition: Transition,
    TransitionGroup: TransitionGroup

    /*  */

    // install platform specific utils
  };Vue.config.mustUseProp = mustUseProp;
  Vue.config.isReservedTag = isReservedTag;
  Vue.config.isReservedAttr = isReservedAttr;
  Vue.config.getTagNamespace = getTagNamespace;
  Vue.config.isUnknownElement = isUnknownElement;

  // install platform runtime directives & components
  extend(Vue.options.directives, platformDirectives);
  extend(Vue.options.components, platformComponents);

  // install platform patch function
  Vue.prototype.__patch__ = inBrowser ? patch : noop;

  // public mount method
  Vue.prototype.$mount = function (el, hydrating) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating);
  };

  // devtools global hook
  /* istanbul ignore next */
  if (inBrowser) {
    setTimeout(function () {
      if (config.devtools) {
        if (devtools) {
          devtools.emit('init', Vue);
        } else if ("development" !== 'production' && "development" !== 'test' && isChrome) {
          console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
        }
      }
      if ("development" !== 'production' && "development" !== 'test' && config.productionTip !== false && typeof console !== 'undefined') {
        console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
      }
    }, 0);
  }

  /*  */

  var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
  var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

  var buildRegex = cached(function (delimiters) {
    var open = delimiters[0].replace(regexEscapeRE, '\\$&');
    var close = delimiters[1].replace(regexEscapeRE, '\\$&');
    return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
  });

  function parseText(text, delimiters) {
    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
    if (!tagRE.test(text)) {
      return;
    }
    var tokens = [];
    var rawTokens = [];
    var lastIndex = tagRE.lastIndex = 0;
    var match, index, tokenValue;
    while (match = tagRE.exec(text)) {
      index = match.index;
      // push text token
      if (index > lastIndex) {
        rawTokens.push(tokenValue = text.slice(lastIndex, index));
        tokens.push(JSON.stringify(tokenValue));
      }
      // tag token
      var exp = parseFilters(match[1].trim());
      tokens.push("_s(" + exp + ")");
      rawTokens.push({ '@binding': exp });
      lastIndex = index + match[0].length;
    }
    if (lastIndex < text.length) {
      rawTokens.push(tokenValue = text.slice(lastIndex));
      tokens.push(JSON.stringify(tokenValue));
    }
    return {
      expression: tokens.join('+'),
      tokens: rawTokens
    };
  }

  /*  */

  function transformNode(el, options) {
    var warn = options.warn || baseWarn;
    var staticClass = getAndRemoveAttr(el, 'class');
    if ("development" !== 'production' && staticClass) {
      var res = parseText(staticClass, options.delimiters);
      if (res) {
        warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
      }
    }
    if (staticClass) {
      el.staticClass = JSON.stringify(staticClass);
    }
    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
    if (classBinding) {
      el.classBinding = classBinding;
    }
  }

  function genData(el) {
    var data = '';
    if (el.staticClass) {
      data += "staticClass:" + el.staticClass + ",";
    }
    if (el.classBinding) {
      data += "class:" + el.classBinding + ",";
    }
    return data;
  }

  var klass$1 = {
    staticKeys: ['staticClass'],
    transformNode: transformNode,
    genData: genData

    /*  */

  };function transformNode$1(el, options) {
    var warn = options.warn || baseWarn;
    var staticStyle = getAndRemoveAttr(el, 'style');
    if (staticStyle) {
      /* istanbul ignore if */
      {
        var res = parseText(staticStyle, options.delimiters);
        if (res) {
          warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
        }
      }
      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
    }

    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
    if (styleBinding) {
      el.styleBinding = styleBinding;
    }
  }

  function genData$1(el) {
    var data = '';
    if (el.staticStyle) {
      data += "staticStyle:" + el.staticStyle + ",";
    }
    if (el.styleBinding) {
      data += "style:(" + el.styleBinding + "),";
    }
    return data;
  }

  var style$1 = {
    staticKeys: ['staticStyle'],
    transformNode: transformNode$1,
    genData: genData$1

    /*  */

  };var decoder;

  var he = {
    decode: function decode(html) {
      decoder = decoder || document.createElement('div');
      decoder.innerHTML = html;
      return decoder.textContent;
    }

    /*  */

  };var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

  // Elements that you can, intentionally, leave open
  // (and which close themselves)
  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

  /**
   * Not type-checking this file because it's mostly vendor code.
   */

  /*!
   * HTML Parser By John Resig (ejohn.org)
   * Modified by Juriy "kangax" Zaytsev
   * Original code by Erik Arvidsson, Mozilla Public License
   * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
   */

  // Regular Expressions for parsing tags and attributes
  var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
  // could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
  // but for Vue templates we can enforce a simple charset
  var ncname = '[a-zA-Z_][\\w\\-\\.]*';
  var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
  var startTagOpen = new RegExp("^<" + qnameCapture);
  var startTagClose = /^\s*(\/?)>/;
  var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
  var doctype = /^<!DOCTYPE [^>]+>/i;
  // #7298: escape - to avoid being pased as HTML comment when inlined in page
  var comment = /^<!\--/;
  var conditionalComment = /^<!\[/;

  var IS_REGEX_CAPTURING_BROKEN = false;
  'x'.replace(/x(.)?/g, function (m, g) {
    IS_REGEX_CAPTURING_BROKEN = g === '';
  });

  // Special Elements (can contain anything)
  var isPlainTextElement = makeMap('script,style,textarea', true);
  var reCache = {};

  var decodingMap = {
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&amp;': '&',
    '&#10;': '\n',
    '&#9;': '\t'
  };
  var encodedAttr = /&(?:lt|gt|quot|amp);/g;
  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;

  // #5992
  var isIgnoreNewlineTag = makeMap('pre,textarea', true);
  var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {
    return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
  };

  function decodeAttr(value, shouldDecodeNewlines) {
    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
    return value.replace(re, function (match) {
      return decodingMap[match];
    });
  }

  function parseHTML(html, options) {
    var stack = [];
    var expectHTML = options.expectHTML;
    var isUnaryTag$$1 = options.isUnaryTag || no;
    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
    var index = 0;
    var last, lastTag;
    while (html) {
      last = html;
      // Make sure we're not in a plaintext content element like script/style
      if (!lastTag || !isPlainTextElement(lastTag)) {
        var textEnd = html.indexOf('<');
        if (textEnd === 0) {
          // Comment:
          if (comment.test(html)) {
            var commentEnd = html.indexOf('-->');

            if (commentEnd >= 0) {
              if (options.shouldKeepComment) {
                options.comment(html.substring(4, commentEnd));
              }
              advance(commentEnd + 3);
              continue;
            }
          }

          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
          if (conditionalComment.test(html)) {
            var conditionalEnd = html.indexOf(']>');

            if (conditionalEnd >= 0) {
              advance(conditionalEnd + 2);
              continue;
            }
          }

          // Doctype:
          var doctypeMatch = html.match(doctype);
          if (doctypeMatch) {
            advance(doctypeMatch[0].length);
            continue;
          }

          // End tag:
          var endTagMatch = html.match(endTag);
          if (endTagMatch) {
            var curIndex = index;
            advance(endTagMatch[0].length);
            parseEndTag(endTagMatch[1], curIndex, index);
            continue;
          }

          // Start tag:
          var startTagMatch = parseStartTag();
          if (startTagMatch) {
            handleStartTag(startTagMatch);
            if (shouldIgnoreFirstNewline(lastTag, html)) {
              advance(1);
            }
            continue;
          }
        }

        var text = void 0,
            rest = void 0,
            next = void 0;
        if (textEnd >= 0) {
          rest = html.slice(textEnd);
          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
            // < in plain text, be forgiving and treat it as text
            next = rest.indexOf('<', 1);
            if (next < 0) {
              break;
            }
            textEnd += next;
            rest = html.slice(textEnd);
          }
          text = html.substring(0, textEnd);
          advance(textEnd);
        }

        if (textEnd < 0) {
          text = html;
          html = '';
        }

        if (options.chars && text) {
          options.chars(text);
        }
      } else {
        var endTagLength = 0;
        var stackedTag = lastTag.toLowerCase();
        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
          endTagLength = endTag.length;
          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
            text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
          }
          if (shouldIgnoreFirstNewline(stackedTag, text)) {
            text = text.slice(1);
          }
          if (options.chars) {
            options.chars(text);
          }
          return '';
        });
        index += html.length - rest$1.length;
        html = rest$1;
        parseEndTag(stackedTag, index - endTagLength, index);
      }

      if (html === last) {
        options.chars && options.chars(html);
        if ("development" !== 'production' && !stack.length && options.warn) {
          options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
        }
        break;
      }
    }

    // Clean up any remaining tags
    parseEndTag();

    function advance(n) {
      index += n;
      html = html.substring(n);
    }

    function parseStartTag() {
      var start = html.match(startTagOpen);
      if (start) {
        var match = {
          tagName: start[1],
          attrs: [],
          start: index
        };
        advance(start[0].length);
        var end, attr;
        while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
          advance(attr[0].length);
          match.attrs.push(attr);
        }
        if (end) {
          match.unarySlash = end[1];
          advance(end[0].length);
          match.end = index;
          return match;
        }
      }
    }

    function handleStartTag(match) {
      var tagName = match.tagName;
      var unarySlash = match.unarySlash;

      if (expectHTML) {
        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
          parseEndTag(lastTag);
        }
        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
          parseEndTag(tagName);
        }
      }

      var unary = isUnaryTag$$1(tagName) || !!unarySlash;

      var l = match.attrs.length;
      var attrs = new Array(l);
      for (var i = 0; i < l; i++) {
        var args = match.attrs[i];
        // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
          if (args[3] === '') {
            delete args[3];
          }
          if (args[4] === '') {
            delete args[4];
          }
          if (args[5] === '') {
            delete args[5];
          }
        }
        var value = args[3] || args[4] || args[5] || '';
        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
        attrs[i] = {
          name: args[1],
          value: decodeAttr(value, shouldDecodeNewlines)
        };
      }

      if (!unary) {
        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
        lastTag = tagName;
      }

      if (options.start) {
        options.start(tagName, attrs, unary, match.start, match.end);
      }
    }

    function parseEndTag(tagName, start, end) {
      var pos, lowerCasedTagName;
      if (start == null) {
        start = index;
      }
      if (end == null) {
        end = index;
      }

      if (tagName) {
        lowerCasedTagName = tagName.toLowerCase();
      }

      // Find the closest opened tag of the same type
      if (tagName) {
        for (pos = stack.length - 1; pos >= 0; pos--) {
          if (stack[pos].lowerCasedTag === lowerCasedTagName) {
            break;
          }
        }
      } else {
        // If no tag name is provided, clean shop
        pos = 0;
      }

      if (pos >= 0) {
        // Close all the open elements, up the stack
        for (var i = stack.length - 1; i >= pos; i--) {
          if ("development" !== 'production' && (i > pos || !tagName) && options.warn) {
            options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
          }
          if (options.end) {
            options.end(stack[i].tag, start, end);
          }
        }

        // Remove the open elements from the stack
        stack.length = pos;
        lastTag = pos && stack[pos - 1].tag;
      } else if (lowerCasedTagName === 'br') {
        if (options.start) {
          options.start(tagName, [], true, start, end);
        }
      } else if (lowerCasedTagName === 'p') {
        if (options.start) {
          options.start(tagName, [], false, start, end);
        }
        if (options.end) {
          options.end(tagName, start, end);
        }
      }
    }
  }

  /*  */

  var onRE = /^@|^v-on:/;
  var dirRE = /^v-|^@|^:/;
  var forAliasRE = /([^]*?)\s+(?:in|of)\s+([^]*)/;
  var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  var stripParensRE = /^\(|\)$/g;

  var argRE = /:(.*)$/;
  var bindRE = /^:|^v-bind:/;
  var modifierRE = /\.[^.]+/g;

  var decodeHTMLCached = cached(he.decode);

  // configurable state
  var warn$2;
  var delimiters;
  var transforms;
  var preTransforms;
  var postTransforms;
  var platformIsPreTag;
  var platformMustUseProp;
  var platformGetTagNamespace;

  function createASTElement(tag, attrs, parent) {
    return {
      type: 1,
      tag: tag,
      attrsList: attrs,
      attrsMap: makeAttrsMap(attrs),
      parent: parent,
      children: []
    };
  }

  /**
   * Convert HTML string to AST.
   */
  function parse(template, options) {
    warn$2 = options.warn || baseWarn;

    platformIsPreTag = options.isPreTag || no;
    platformMustUseProp = options.mustUseProp || no;
    platformGetTagNamespace = options.getTagNamespace || no;

    transforms = pluckModuleFunction(options.modules, 'transformNode');
    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

    delimiters = options.delimiters;

    var stack = [];
    var preserveWhitespace = options.preserveWhitespace !== false;
    var root;
    var currentParent;
    var inVPre = false;
    var inPre = false;
    var warned = false;

    function warnOnce(msg) {
      if (!warned) {
        warned = true;
        warn$2(msg);
      }
    }

    function closeElement(element) {
      // check pre state
      if (element.pre) {
        inVPre = false;
      }
      if (platformIsPreTag(element.tag)) {
        inPre = false;
      }
      // apply post-transforms
      for (var i = 0; i < postTransforms.length; i++) {
        postTransforms[i](element, options);
      }
    }

    parseHTML(template, {
      warn: warn$2,
      expectHTML: options.expectHTML,
      isUnaryTag: options.isUnaryTag,
      canBeLeftOpenTag: options.canBeLeftOpenTag,
      shouldDecodeNewlines: options.shouldDecodeNewlines,
      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
      shouldKeepComment: options.comments,
      start: function start(tag, attrs, unary) {
        // check namespace.
        // inherit parent ns if there is one
        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

        // handle IE svg bug
        /* istanbul ignore if */
        if (isIE && ns === 'svg') {
          attrs = guardIESVGBug(attrs);
        }

        var element = createASTElement(tag, attrs, currentParent);
        if (ns) {
          element.ns = ns;
        }

        if (isForbiddenTag(element) && !isServerRendering()) {
          element.forbidden = true;
          "development" !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
        }

        // apply pre-transforms
        for (var i = 0; i < preTransforms.length; i++) {
          element = preTransforms[i](element, options) || element;
        }

        if (!inVPre) {
          processPre(element);
          if (element.pre) {
            inVPre = true;
          }
        }
        if (platformIsPreTag(element.tag)) {
          inPre = true;
        }
        if (inVPre) {
          processRawAttrs(element);
        } else if (!element.processed) {
          // structural directives
          processFor(element);
          processIf(element);
          processOnce(element);
          // element-scope stuff
          processElement(element, options);
        }

        function checkRootConstraints(el) {
          {
            if (el.tag === 'slot' || el.tag === 'template') {
              warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
            }
            if (el.attrsMap.hasOwnProperty('v-for')) {
              warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
            }
          }
        }

        // tree management
        if (!root) {
          root = element;
          checkRootConstraints(root);
        } else if (!stack.length) {
          // allow root elements with v-if, v-else-if and v-else
          if (root.if && (element.elseif || element.else)) {
            checkRootConstraints(element);
            addIfCondition(root, {
              exp: element.elseif,
              block: element
            });
          } else {
            warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
          }
        }
        if (currentParent && !element.forbidden) {
          if (element.elseif || element.else) {
            processIfConditions(element, currentParent);
          } else if (element.slotScope) {
            // scoped slot
            currentParent.plain = false;
            var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
          } else {
            currentParent.children.push(element);
            element.parent = currentParent;
          }
        }
        if (!unary) {
          currentParent = element;
          stack.push(element);
        } else {
          closeElement(element);
        }
      },

      end: function end() {
        // remove trailing whitespace
        var element = stack[stack.length - 1];
        var lastNode = element.children[element.children.length - 1];
        if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
          element.children.pop();
        }
        // pop stack
        stack.length -= 1;
        currentParent = stack[stack.length - 1];
        closeElement(element);
      },

      chars: function chars(text) {
        if (!currentParent) {
          {
            if (text === template) {
              warnOnce('Component template requires a root element, rather than just text.');
            } else if (text = text.trim()) {
              warnOnce("text \"" + text + "\" outside root element will be ignored.");
            }
          }
          return;
        }
        // IE textarea placeholder bug
        /* istanbul ignore if */
        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
          return;
        }
        var children = currentParent.children;
        text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
        // only preserve whitespace if its not right after a starting tag
        : preserveWhitespace && children.length ? ' ' : '';
        if (text) {
          var res;
          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
            children.push({
              type: 2,
              expression: res.expression,
              tokens: res.tokens,
              text: text
            });
          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
            children.push({
              type: 3,
              text: text
            });
          }
        }
      },
      comment: function comment(text) {
        currentParent.children.push({
          type: 3,
          text: text,
          isComment: true
        });
      }
    });
    return root;
  }

  function processPre(el) {
    if (getAndRemoveAttr(el, 'v-pre') != null) {
      el.pre = true;
    }
  }

  function processRawAttrs(el) {
    var l = el.attrsList.length;
    if (l) {
      var attrs = el.attrs = new Array(l);
      for (var i = 0; i < l; i++) {
        attrs[i] = {
          name: el.attrsList[i].name,
          value: JSON.stringify(el.attrsList[i].value)
        };
      }
    } else if (!el.pre) {
      // non root node in pre blocks with no attributes
      el.plain = true;
    }
  }

  function processElement(element, options) {
    processKey(element);

    // determine whether this is a plain element after
    // removing structural attributes
    element.plain = !element.key && !element.attrsList.length;

    processRef(element);
    processSlot(element);
    processComponent(element);
    for (var i = 0; i < transforms.length; i++) {
      element = transforms[i](element, options) || element;
    }
    processAttrs(element);
  }

  function processKey(el) {
    var exp = getBindingAttr(el, 'key');
    if (exp) {
      if ("development" !== 'production' && el.tag === 'template') {
        warn$2("<template> cannot be keyed. Place the key on real elements instead.");
      }
      el.key = exp;
    }
  }

  function processRef(el) {
    var ref = getBindingAttr(el, 'ref');
    if (ref) {
      el.ref = ref;
      el.refInFor = checkInFor(el);
    }
  }

  function processFor(el) {
    var exp;
    if (exp = getAndRemoveAttr(el, 'v-for')) {
      var res = parseFor(exp);
      if (res) {
        extend(el, res);
      } else {
        warn$2("Invalid v-for expression: " + exp);
      }
    }
  }

  function parseFor(exp) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      return;
    }
    var res = {};
    res.for = inMatch[2].trim();
    var alias = inMatch[1].trim().replace(stripParensRE, '');
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      res.alias = alias.replace(forIteratorRE, '');
      res.iterator1 = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.iterator2 = iteratorMatch[2].trim();
      }
    } else {
      res.alias = alias;
    }
    return res;
  }

  function processIf(el) {
    var exp = getAndRemoveAttr(el, 'v-if');
    if (exp) {
      el.if = exp;
      addIfCondition(el, {
        exp: exp,
        block: el
      });
    } else {
      if (getAndRemoveAttr(el, 'v-else') != null) {
        el.else = true;
      }
      var elseif = getAndRemoveAttr(el, 'v-else-if');
      if (elseif) {
        el.elseif = elseif;
      }
    }
  }

  function processIfConditions(el, parent) {
    var prev = findPrevElement(parent.children);
    if (prev && prev.if) {
      addIfCondition(prev, {
        exp: el.elseif,
        block: el
      });
    } else {
      warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
    }
  }

  function findPrevElement(children) {
    var i = children.length;
    while (i--) {
      if (children[i].type === 1) {
        return children[i];
      } else {
        if ("development" !== 'production' && children[i].text !== ' ') {
          warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
        }
        children.pop();
      }
    }
  }

  function addIfCondition(el, condition) {
    if (!el.ifConditions) {
      el.ifConditions = [];
    }
    el.ifConditions.push(condition);
  }

  function processOnce(el) {
    var once$$1 = getAndRemoveAttr(el, 'v-once');
    if (once$$1 != null) {
      el.once = true;
    }
  }

  function processSlot(el) {
    if (el.tag === 'slot') {
      el.slotName = getBindingAttr(el, 'name');
      if ("development" !== 'production' && el.key) {
        warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
      }
    } else {
      var slotScope;
      if (el.tag === 'template') {
        slotScope = getAndRemoveAttr(el, 'scope');
        /* istanbul ignore if */
        if ("development" !== 'production' && slotScope) {
          warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", true);
        }
        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
      } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
        /* istanbul ignore if */
        if ("development" !== 'production' && el.attrsMap['v-for']) {
          warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", true);
        }
        el.slotScope = slotScope;
      }
      var slotTarget = getBindingAttr(el, 'slot');
      if (slotTarget) {
        el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
        // preserve slot as an attribute for native shadow DOM compat
        // only for non-scoped slots.
        if (el.tag !== 'template' && !el.slotScope) {
          addAttr(el, 'slot', slotTarget);
        }
      }
    }
  }

  function processComponent(el) {
    var binding;
    if (binding = getBindingAttr(el, 'is')) {
      el.component = binding;
    }
    if (getAndRemoveAttr(el, 'inline-template') != null) {
      el.inlineTemplate = true;
    }
  }

  function processAttrs(el) {
    var list = el.attrsList;
    var i, l, name, rawName, value, modifiers, isProp;
    for (i = 0, l = list.length; i < l; i++) {
      name = rawName = list[i].name;
      value = list[i].value;
      if (dirRE.test(name)) {
        // mark element as dynamic
        el.hasBindings = true;
        // modifiers
        modifiers = parseModifiers(name);
        if (modifiers) {
          name = name.replace(modifierRE, '');
        }
        if (bindRE.test(name)) {
          // v-bind
          name = name.replace(bindRE, '');
          value = parseFilters(value);
          isProp = false;
          if (modifiers) {
            if (modifiers.prop) {
              isProp = true;
              name = camelize(name);
              if (name === 'innerHtml') {
                name = 'innerHTML';
              }
            }
            if (modifiers.camel) {
              name = camelize(name);
            }
            if (modifiers.sync) {
              addHandler(el, "update:" + camelize(name), genAssignmentCode(value, "$event"));
            }
          }
          if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
            addProp(el, name, value);
          } else {
            addAttr(el, name, value);
          }
        } else if (onRE.test(name)) {
          // v-on
          name = name.replace(onRE, '');
          addHandler(el, name, value, modifiers, false, warn$2);
        } else {
          // normal directives
          name = name.replace(dirRE, '');
          // parse arg
          var argMatch = name.match(argRE);
          var arg = argMatch && argMatch[1];
          if (arg) {
            name = name.slice(0, -(arg.length + 1));
          }
          addDirective(el, name, rawName, value, arg, modifiers);
          if ("development" !== 'production' && name === 'model') {
            checkForAliasModel(el, value);
          }
        }
      } else {
        // literal attribute
        {
          var res = parseText(value, delimiters);
          if (res) {
            warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
          }
        }
        addAttr(el, name, JSON.stringify(value));
        // #6887 firefox doesn't update muted state if set via attribute
        // even immediately after element creation
        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, 'true');
        }
      }
    }
  }

  function checkInFor(el) {
    var parent = el;
    while (parent) {
      if (parent.for !== undefined) {
        return true;
      }
      parent = parent.parent;
    }
    return false;
  }

  function parseModifiers(name) {
    var match = name.match(modifierRE);
    if (match) {
      var ret = {};
      match.forEach(function (m) {
        ret[m.slice(1)] = true;
      });
      return ret;
    }
  }

  function makeAttrsMap(attrs) {
    var map = {};
    for (var i = 0, l = attrs.length; i < l; i++) {
      if ("development" !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {
        warn$2('duplicate attribute: ' + attrs[i].name);
      }
      map[attrs[i].name] = attrs[i].value;
    }
    return map;
  }

  // for script (e.g. type="x/template") or style, do not decode content
  function isTextTag(el) {
    return el.tag === 'script' || el.tag === 'style';
  }

  function isForbiddenTag(el) {
    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
  }

  var ieNSBug = /^xmlns:NS\d+/;
  var ieNSPrefix = /^NS\d+:/;

  /* istanbul ignore next */
  function guardIESVGBug(attrs) {
    var res = [];
    for (var i = 0; i < attrs.length; i++) {
      var attr = attrs[i];
      if (!ieNSBug.test(attr.name)) {
        attr.name = attr.name.replace(ieNSPrefix, '');
        res.push(attr);
      }
    }
    return res;
  }

  function checkForAliasModel(el, value) {
    var _el = el;
    while (_el) {
      if (_el.for && _el.alias === value) {
        warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
      }
      _el = _el.parent;
    }
  }

  /*  */

  /**
   * Expand input[v-model] with dyanmic type bindings into v-if-else chains
   * Turn this:
   *   <input v-model="data[type]" :type="type">
   * into this:
   *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
   *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
   *   <input v-else :type="type" v-model="data[type]">
   */

  function preTransformNode(el, options) {
    if (el.tag === 'input') {
      var map = el.attrsMap;
      if (!map['v-model']) {
        return;
      }

      var typeBinding;
      if (map[':type'] || map['v-bind:type']) {
        typeBinding = getBindingAttr(el, 'type');
      }
      if (!map.type && !typeBinding && map['v-bind']) {
        typeBinding = "(" + map['v-bind'] + ").type";
      }

      if (typeBinding) {
        var ifCondition = getAndRemoveAttr(el, 'v-if', true);
        var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
        // 1. checkbox
        var branch0 = cloneASTElement(el);
        // process for on the main node
        processFor(branch0);
        addRawAttr(branch0, 'type', 'checkbox');
        processElement(branch0, options);
        branch0.processed = true; // prevent it from double-processed
        branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
        addIfCondition(branch0, {
          exp: branch0.if,
          block: branch0
        });
        // 2. add radio else-if condition
        var branch1 = cloneASTElement(el);
        getAndRemoveAttr(branch1, 'v-for', true);
        addRawAttr(branch1, 'type', 'radio');
        processElement(branch1, options);
        addIfCondition(branch0, {
          exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
          block: branch1
        });
        // 3. other
        var branch2 = cloneASTElement(el);
        getAndRemoveAttr(branch2, 'v-for', true);
        addRawAttr(branch2, ':type', typeBinding);
        processElement(branch2, options);
        addIfCondition(branch0, {
          exp: ifCondition,
          block: branch2
        });

        if (hasElse) {
          branch0.else = true;
        } else if (elseIfCondition) {
          branch0.elseif = elseIfCondition;
        }

        return branch0;
      }
    }
  }

  function cloneASTElement(el) {
    return createASTElement(el.tag, el.attrsList.slice(), el.parent);
  }

  var model$2 = {
    preTransformNode: preTransformNode
  };

  var modules$1 = [klass$1, style$1, model$2];

  /*  */

  function text(el, dir) {
    if (dir.value) {
      addProp(el, 'textContent', "_s(" + dir.value + ")");
    }
  }

  /*  */

  function html(el, dir) {
    if (dir.value) {
      addProp(el, 'innerHTML', "_s(" + dir.value + ")");
    }
  }

  var directives$1 = {
    model: model,
    text: text,
    html: html

    /*  */

  };var baseOptions = {
    expectHTML: true,
    modules: modules$1,
    directives: directives$1,
    isPreTag: isPreTag,
    isUnaryTag: isUnaryTag,
    mustUseProp: mustUseProp,
    canBeLeftOpenTag: canBeLeftOpenTag,
    isReservedTag: isReservedTag,
    getTagNamespace: getTagNamespace,
    staticKeys: genStaticKeys(modules$1)
  };

  /*  */

  var isStaticKey;
  var isPlatformReservedTag;

  var genStaticKeysCached = cached(genStaticKeys$1);

  /**
   * Goal of the optimizer: walk the generated template AST tree
   * and detect sub-trees that are purely static, i.e. parts of
   * the DOM that never needs to change.
   *
   * Once we detect these sub-trees, we can:
   *
   * 1. Hoist them into constants, so that we no longer need to
   *    create fresh nodes for them on each re-render;
   * 2. Completely skip them in the patching process.
   */
  function optimize(root, options) {
    if (!root) {
      return;
    }
    isStaticKey = genStaticKeysCached(options.staticKeys || '');
    isPlatformReservedTag = options.isReservedTag || no;
    // first pass: mark all non-static nodes.
    markStatic$1(root);
    // second pass: mark static roots.
    markStaticRoots(root, false);
  }

  function genStaticKeys$1(keys) {
    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
  }

  function markStatic$1(node) {
    node.static = isStatic(node);
    if (node.type === 1) {
      // do not make component slot content static. this avoids
      // 1. components not able to mutate slot nodes
      // 2. static slot content fails for hot-reloading
      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
        return;
      }
      for (var i = 0, l = node.children.length; i < l; i++) {
        var child = node.children[i];
        markStatic$1(child);
        if (!child.static) {
          node.static = false;
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          var block = node.ifConditions[i$1].block;
          markStatic$1(block);
          if (!block.static) {
            node.static = false;
          }
        }
      }
    }
  }

  function markStaticRoots(node, isInFor) {
    if (node.type === 1) {
      if (node.static || node.once) {
        node.staticInFor = isInFor;
      }
      // For a node to qualify as a static root, it should have children that
      // are not just static text. Otherwise the cost of hoisting out will
      // outweigh the benefits and it's better off to just always render it fresh.
      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
        node.staticRoot = true;
        return;
      } else {
        node.staticRoot = false;
      }
      if (node.children) {
        for (var i = 0, l = node.children.length; i < l; i++) {
          markStaticRoots(node.children[i], isInFor || !!node.for);
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          markStaticRoots(node.ifConditions[i$1].block, isInFor);
        }
      }
    }
  }

  function isStatic(node) {
    if (node.type === 2) {
      // expression
      return false;
    }
    if (node.type === 3) {
      // text
      return true;
    }
    return !!(node.pre || !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
  }

  function isDirectChildOfTemplateFor(node) {
    while (node.parent) {
      node = node.parent;
      if (node.tag !== 'template') {
        return false;
      }
      if (node.for) {
        return true;
      }
    }
    return false;
  }

  /*  */

  var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
  var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

  // KeyboardEvent.keyCode aliases
  var keyCodes = {
    esc: 27,
    tab: 9,
    enter: 13,
    space: 32,
    up: 38,
    left: 37,
    right: 39,
    down: 40,
    'delete': [8, 46]
  };

  // KeyboardEvent.key aliases
  var keyNames = {
    esc: 'Escape',
    tab: 'Tab',
    enter: 'Enter',
    space: ' ',
    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
    up: ['Up', 'ArrowUp'],
    left: ['Left', 'ArrowLeft'],
    right: ['Right', 'ArrowRight'],
    down: ['Down', 'ArrowDown'],
    'delete': ['Backspace', 'Delete']
  };

  // #4868: modifiers that prevent the execution of the listener
  // need to explicitly return null so that we can determine whether to remove
  // the listener for .once
  var genGuard = function genGuard(condition) {
    return "if(" + condition + ")return null;";
  };

  var modifierCode = {
    stop: '$event.stopPropagation();',
    prevent: '$event.preventDefault();',
    self: genGuard("$event.target !== $event.currentTarget"),
    ctrl: genGuard("!$event.ctrlKey"),
    shift: genGuard("!$event.shiftKey"),
    alt: genGuard("!$event.altKey"),
    meta: genGuard("!$event.metaKey"),
    left: genGuard("'button' in $event && $event.button !== 0"),
    middle: genGuard("'button' in $event && $event.button !== 1"),
    right: genGuard("'button' in $event && $event.button !== 2")
  };

  function genHandlers(events, isNative, warn) {
    var res = isNative ? 'nativeOn:{' : 'on:{';
    for (var name in events) {
      res += "\"" + name + "\":" + genHandler(name, events[name]) + ",";
    }
    return res.slice(0, -1) + '}';
  }

  function genHandler(name, handler) {
    if (!handler) {
      return 'function(){}';
    }

    if (Array.isArray(handler)) {
      return "[" + handler.map(function (handler) {
        return genHandler(name, handler);
      }).join(',') + "]";
    }

    var isMethodPath = simplePathRE.test(handler.value);
    var isFunctionExpression = fnExpRE.test(handler.value);

    if (!handler.modifiers) {
      if (isMethodPath || isFunctionExpression) {
        return handler.value;
      }
      /* istanbul ignore if */
      return "function($event){" + handler.value + "}"; // inline statement
    } else {
      var code = '';
      var genModifierCode = '';
      var keys = [];
      for (var key in handler.modifiers) {
        if (modifierCode[key]) {
          genModifierCode += modifierCode[key];
          // left/right
          if (keyCodes[key]) {
            keys.push(key);
          }
        } else if (key === 'exact') {
          var modifiers = handler.modifiers;
          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
            return !modifiers[keyModifier];
          }).map(function (keyModifier) {
            return "$event." + keyModifier + "Key";
          }).join('||'));
        } else {
          keys.push(key);
        }
      }
      if (keys.length) {
        code += genKeyFilter(keys);
      }
      // Make sure modifiers like prevent and stop get executed after key filtering
      if (genModifierCode) {
        code += genModifierCode;
      }
      var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : handler.value;
      /* istanbul ignore if */
      return "function($event){" + code + handlerCode + "}";
    }
  }

  function genKeyFilter(keys) {
    return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
  }

  function genFilterCode(key) {
    var keyVal = parseInt(key, 10);
    if (keyVal) {
      return "$event.keyCode!==" + keyVal;
    }
    var keyCode = keyCodes[key];
    var keyName = keyNames[key];
    return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
  }

  /*  */

  function on(el, dir) {
    if ("development" !== 'production' && dir.modifiers) {
      warn("v-on without argument does not support modifiers.");
    }
    el.wrapListeners = function (code) {
      return "_g(" + code + "," + dir.value + ")";
    };
  }

  /*  */

  function bind$1(el, dir) {
    el.wrapData = function (code) {
      return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
    };
  }

  /*  */

  var baseDirectives = {
    on: on,
    bind: bind$1,
    cloak: noop

    /*  */

  };var CodegenState = function CodegenState(options) {
    this.options = options;
    this.warn = options.warn || baseWarn;
    this.transforms = pluckModuleFunction(options.modules, 'transformCode');
    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
    this.directives = extend(extend({}, baseDirectives), options.directives);
    var isReservedTag = options.isReservedTag || no;
    this.maybeComponent = function (el) {
      return !isReservedTag(el.tag);
    };
    this.onceId = 0;
    this.staticRenderFns = [];
  };

  function generate(ast, options) {
    var state = new CodegenState(options);
    var code = ast ? genElement(ast, state) : '_c("div")';
    return {
      render: "with(this){return " + code + "}",
      staticRenderFns: state.staticRenderFns
    };
  }

  function genElement(el, state) {
    if (el.staticRoot && !el.staticProcessed) {
      return genStatic(el, state);
    } else if (el.once && !el.onceProcessed) {
      return genOnce(el, state);
    } else if (el.for && !el.forProcessed) {
      return genFor(el, state);
    } else if (el.if && !el.ifProcessed) {
      return genIf(el, state);
    } else if (el.tag === 'template' && !el.slotTarget) {
      return genChildren(el, state) || 'void 0';
    } else if (el.tag === 'slot') {
      return genSlot(el, state);
    } else {
      // component or element
      var code;
      if (el.component) {
        code = genComponent(el.component, el, state);
      } else {
        var data = el.plain ? undefined : genData$2(el, state);

        var children = el.inlineTemplate ? null : genChildren(el, state, true);
        code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
      }
      // module transforms
      for (var i = 0; i < state.transforms.length; i++) {
        code = state.transforms[i](el, code);
      }
      return code;
    }
  }

  // hoist static sub-trees out
  function genStatic(el, state) {
    el.staticProcessed = true;
    state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
    return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
  }

  // v-once
  function genOnce(el, state) {
    el.onceProcessed = true;
    if (el.if && !el.ifProcessed) {
      return genIf(el, state);
    } else if (el.staticInFor) {
      var key = '';
      var parent = el.parent;
      while (parent) {
        if (parent.for) {
          key = parent.key;
          break;
        }
        parent = parent.parent;
      }
      if (!key) {
        "development" !== 'production' && state.warn("v-once can only be used inside v-for that is keyed. ");
        return genElement(el, state);
      }
      return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
    } else {
      return genStatic(el, state);
    }
  }

  function genIf(el, state, altGen, altEmpty) {
    el.ifProcessed = true; // avoid recursion
    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
  }

  function genIfConditions(conditions, state, altGen, altEmpty) {
    if (!conditions.length) {
      return altEmpty || '_e()';
    }

    var condition = conditions.shift();
    if (condition.exp) {
      return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
    } else {
      return "" + genTernaryExp(condition.block);
    }

    // v-if with v-once should generate code like (a)?_m(0):_m(1)
    function genTernaryExp(el) {
      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
    }
  }

  function genFor(el, state, altGen, altHelper) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
    var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

    if ("development" !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
      state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
      );
    }

    el.forProcessed = true; // avoid recursion
    return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
  }

  function genData$2(el, state) {
    var data = '{';

    // directives first.
    // directives may mutate the el's other properties before they are generated.
    var dirs = genDirectives(el, state);
    if (dirs) {
      data += dirs + ',';
    }

    // key
    if (el.key) {
      data += "key:" + el.key + ",";
    }
    // ref
    if (el.ref) {
      data += "ref:" + el.ref + ",";
    }
    if (el.refInFor) {
      data += "refInFor:true,";
    }
    // pre
    if (el.pre) {
      data += "pre:true,";
    }
    // record original tag name for components using "is" attribute
    if (el.component) {
      data += "tag:\"" + el.tag + "\",";
    }
    // module data generation functions
    for (var i = 0; i < state.dataGenFns.length; i++) {
      data += state.dataGenFns[i](el);
    }
    // attributes
    if (el.attrs) {
      data += "attrs:{" + genProps(el.attrs) + "},";
    }
    // DOM props
    if (el.props) {
      data += "domProps:{" + genProps(el.props) + "},";
    }
    // event handlers
    if (el.events) {
      data += genHandlers(el.events, false, state.warn) + ",";
    }
    if (el.nativeEvents) {
      data += genHandlers(el.nativeEvents, true, state.warn) + ",";
    }
    // slot target
    // only for non-scoped slots
    if (el.slotTarget && !el.slotScope) {
      data += "slot:" + el.slotTarget + ",";
    }
    // scoped slots
    if (el.scopedSlots) {
      data += genScopedSlots(el.scopedSlots, state) + ",";
    }
    // component v-model
    if (el.model) {
      data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
    }
    // inline-template
    if (el.inlineTemplate) {
      var inlineTemplate = genInlineTemplate(el, state);
      if (inlineTemplate) {
        data += inlineTemplate + ",";
      }
    }
    data = data.replace(/,$/, '') + '}';
    // v-bind data wrap
    if (el.wrapData) {
      data = el.wrapData(data);
    }
    // v-on data wrap
    if (el.wrapListeners) {
      data = el.wrapListeners(data);
    }
    return data;
  }

  function genDirectives(el, state) {
    var dirs = el.directives;
    if (!dirs) {
      return;
    }
    var res = 'directives:[';
    var hasRuntime = false;
    var i, l, dir, needRuntime;
    for (i = 0, l = dirs.length; i < l; i++) {
      dir = dirs[i];
      needRuntime = true;
      var gen = state.directives[dir.name];
      if (gen) {
        // compile-time directive that manipulates AST.
        // returns true if it also needs a runtime counterpart.
        needRuntime = !!gen(el, dir, state.warn);
      }
      if (needRuntime) {
        hasRuntime = true;
        res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
      }
    }
    if (hasRuntime) {
      return res.slice(0, -1) + ']';
    }
  }

  function genInlineTemplate(el, state) {
    var ast = el.children[0];
    if ("development" !== 'production' && (el.children.length !== 1 || ast.type !== 1)) {
      state.warn('Inline-template components must have exactly one child element.');
    }
    if (ast.type === 1) {
      var inlineRenderFns = generate(ast, state.options);
      return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
        return "function(){" + code + "}";
      }).join(',') + "]}";
    }
  }

  function genScopedSlots(slots, state) {
    return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
      return genScopedSlot(key, slots[key], state);
    }).join(',') + "])";
  }

  function genScopedSlot(key, el, state) {
    if (el.for && !el.forProcessed) {
      return genForScopedSlot(key, el, state);
    }
    var fn = "function(" + String(el.slotScope) + "){" + "return " + (el.tag === 'template' ? el.if ? el.if + "?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}";
    return "{key:" + key + ",fn:" + fn + "}";
  }

  function genForScopedSlot(key, el, state) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
    var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
    el.forProcessed = true; // avoid recursion
    return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genScopedSlot(key, el, state) + '})';
  }

  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
    var children = el.children;
    if (children.length) {
      var el$1 = children[0];
      // optimize single v-for
      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
        return (altGenElement || genElement)(el$1, state);
      }
      var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
      var gen = altGenNode || genNode;
      return "[" + children.map(function (c) {
        return gen(c, state);
      }).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
    }
  }

  // determine the normalization needed for the children array.
  // 0: no normalization needed
  // 1: simple normalization needed (possible 1-level deep nested array)
  // 2: full normalization needed
  function getNormalizationType(children, maybeComponent) {
    var res = 0;
    for (var i = 0; i < children.length; i++) {
      var el = children[i];
      if (el.type !== 1) {
        continue;
      }
      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
        return needsNormalization(c.block);
      })) {
        res = 2;
        break;
      }
      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
        return maybeComponent(c.block);
      })) {
        res = 1;
      }
    }
    return res;
  }

  function needsNormalization(el) {
    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
  }

  function genNode(node, state) {
    if (node.type === 1) {
      return genElement(node, state);
    }if (node.type === 3 && node.isComment) {
      return genComment(node);
    } else {
      return genText(node);
    }
  }

  function genText(text) {
    return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
  }

  function genComment(comment) {
    return "_e(" + JSON.stringify(comment.text) + ")";
  }

  function genSlot(el, state) {
    var slotName = el.slotName || '"default"';
    var children = genChildren(el, state);
    var res = "_t(" + slotName + (children ? "," + children : '');
    var attrs = el.attrs && "{" + el.attrs.map(function (a) {
      return camelize(a.name) + ":" + a.value;
    }).join(',') + "}";
    var bind$$1 = el.attrsMap['v-bind'];
    if ((attrs || bind$$1) && !children) {
      res += ",null";
    }
    if (attrs) {
      res += "," + attrs;
    }
    if (bind$$1) {
      res += (attrs ? '' : ',null') + "," + bind$$1;
    }
    return res + ')';
  }

  // componentName is el.component, take it as argument to shun flow's pessimistic refinement
  function genComponent(componentName, el, state) {
    var children = el.inlineTemplate ? null : genChildren(el, state, true);
    return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
  }

  function genProps(props) {
    var res = '';
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      /* istanbul ignore if */
      {
        res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
      }
    }
    return res.slice(0, -1);
  }

  // #3895, #4268
  function transformSpecialNewlines(text) {
    return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
  }

  /*  */

  // these keywords should not appear inside expressions, but operators like
  // typeof, instanceof and in are allowed
  var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

  // these unary operators should not be used as property/method names
  var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

  // strip strings in expressions
  var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

  // detect problematic expressions in a template
  function detectErrors(ast) {
    var errors = [];
    if (ast) {
      checkNode(ast, errors);
    }
    return errors;
  }

  function checkNode(node, errors) {
    if (node.type === 1) {
      for (var name in node.attrsMap) {
        if (dirRE.test(name)) {
          var value = node.attrsMap[name];
          if (value) {
            if (name === 'v-for') {
              checkFor(node, "v-for=\"" + value + "\"", errors);
            } else if (onRE.test(name)) {
              checkEvent(value, name + "=\"" + value + "\"", errors);
            } else {
              checkExpression(value, name + "=\"" + value + "\"", errors);
            }
          }
        }
      }
      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          checkNode(node.children[i], errors);
        }
      }
    } else if (node.type === 2) {
      checkExpression(node.expression, node.text, errors);
    }
  }

  function checkEvent(exp, text, errors) {
    var stipped = exp.replace(stripStringRE, '');
    var keywordMatch = stipped.match(unaryOperatorsRE);
    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
      errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
    }
    checkExpression(exp, text, errors);
  }

  function checkFor(node, text, errors) {
    checkExpression(node.for || '', text, errors);
    checkIdentifier(node.alias, 'v-for alias', text, errors);
    checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
    checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
  }

  function checkIdentifier(ident, type, text, errors) {
    if (typeof ident === 'string') {
      try {
        new Function("var " + ident + "=_");
      } catch (e) {
        errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
      }
    }
  }

  function checkExpression(exp, text, errors) {
    try {
      new Function("return " + exp);
    } catch (e) {
      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
      if (keywordMatch) {
        errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim());
      } else {
        errors.push("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n");
      }
    }
  }

  /*  */

  function createFunction(code, errors) {
    try {
      return new Function(code);
    } catch (err) {
      errors.push({ err: err, code: code });
      return noop;
    }
  }

  function createCompileToFunctionFn(compile) {
    var cache = Object.create(null);

    return function compileToFunctions(template, options, vm) {
      options = extend({}, options);
      var warn$$1 = options.warn || warn;
      delete options.warn;

      /* istanbul ignore if */
      {
        // detect possible CSP restriction
        try {
          new Function('return 1');
        } catch (e) {
          if (e.toString().match(/unsafe-eval|CSP/)) {
            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
          }
        }
      }

      // check cache
      var key = options.delimiters ? String(options.delimiters) + template : template;
      if (cache[key]) {
        return cache[key];
      }

      // compile
      var compiled = compile(template, options);

      // check compilation errors/tips
      {
        if (compiled.errors && compiled.errors.length) {
          warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
            return "- " + e;
          }).join('\n') + '\n', vm);
        }
        if (compiled.tips && compiled.tips.length) {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm);
          });
        }
      }

      // turn code into functions
      var res = {};
      var fnGenErrors = [];
      res.render = createFunction(compiled.render, fnGenErrors);
      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
        return createFunction(code, fnGenErrors);
      });

      // check function generation errors.
      // this should only happen if there is a bug in the compiler itself.
      // mostly for codegen development use
      /* istanbul ignore if */
      {
        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
          warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return err.toString() + " in\n\n" + code + "\n";
          }).join('\n'), vm);
        }
      }

      return cache[key] = res;
    };
  }

  /*  */

  function createCompilerCreator(baseCompile) {
    return function createCompiler(baseOptions) {
      function compile(template, options) {
        var finalOptions = Object.create(baseOptions);
        var errors = [];
        var tips = [];
        finalOptions.warn = function (msg, tip) {
          (tip ? tips : errors).push(msg);
        };

        if (options) {
          // merge custom modules
          if (options.modules) {
            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
          }
          // merge custom directives
          if (options.directives) {
            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
          }
          // copy other options
          for (var key in options) {
            if (key !== 'modules' && key !== 'directives') {
              finalOptions[key] = options[key];
            }
          }
        }

        var compiled = baseCompile(template, finalOptions);
        {
          errors.push.apply(errors, detectErrors(compiled.ast));
        }
        compiled.errors = errors;
        compiled.tips = tips;
        return compiled;
      }

      return {
        compile: compile,
        compileToFunctions: createCompileToFunctionFn(compile)
      };
    };
  }

  /*  */

  // `createCompilerCreator` allows creating compilers that use alternative
  // parser/optimizer/codegen, e.g the SSR optimizing compiler.
  // Here we just export a default compiler using the default parts.
  var createCompiler = createCompilerCreator(function baseCompile(template, options) {
    var ast = parse(template.trim(), options);
    if (options.optimize !== false) {
      optimize(ast, options);
    }
    var code = generate(ast, options);
    return {
      ast: ast,
      render: code.render,
      staticRenderFns: code.staticRenderFns
    };
  });

  /*  */

  var ref$1 = createCompiler(baseOptions);
  var compileToFunctions = ref$1.compileToFunctions;

  /*  */

  // check whether current browser encodes a char inside attribute values
  var div;
  function getShouldDecode(href) {
    div = div || document.createElement('div');
    div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
    return div.innerHTML.indexOf('&#10;') > 0;
  }

  // #3663: IE encodes newlines inside attribute values while other browsers don't
  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
  // #6828: chrome encodes content in a[href]
  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

  /*  */

  var idToTemplate = cached(function (id) {
    var el = query(id);
    return el && el.innerHTML;
  });

  var mount = Vue.prototype.$mount;
  Vue.prototype.$mount = function (el, hydrating) {
    el = el && query(el);

    /* istanbul ignore if */
    if (el === document.body || el === document.documentElement) {
      "development" !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
      return this;
    }

    var options = this.$options;
    // resolve template/el and convert to render function
    if (!options.render) {
      var template = options.template;
      if (template) {
        if (typeof template === 'string') {
          if (template.charAt(0) === '#') {
            template = idToTemplate(template);
            /* istanbul ignore if */
            if ("development" !== 'production' && !template) {
              warn("Template element not found or is empty: " + options.template, this);
            }
          }
        } else if (template.nodeType) {
          template = template.innerHTML;
        } else {
          {
            warn('invalid template option:' + template, this);
          }
          return this;
        }
      } else if (el) {
        template = getOuterHTML(el);
      }
      if (template) {
        /* istanbul ignore if */
        if ("development" !== 'production' && config.performance && mark) {
          mark('compile');
        }

        var ref = compileToFunctions(template, {
          shouldDecodeNewlines: shouldDecodeNewlines,
          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        }, this);
        var render = ref.render;
        var staticRenderFns = ref.staticRenderFns;
        options.render = render;
        options.staticRenderFns = staticRenderFns;

        /* istanbul ignore if */
        if ("development" !== 'production' && config.performance && mark) {
          mark('compile end');
          measure("vue " + this._name + " compile", 'compile', 'compile end');
        }
      }
    }
    return mount.call(this, el, hydrating);
  };

  /**
   * Get outerHTML of elements, taking care
   * of SVG elements in IE as well.
   */
  function getOuterHTML(el) {
    if (el.outerHTML) {
      return el.outerHTML;
    } else {
      var container = document.createElement('div');
      container.appendChild(el.cloneNode(true));
      return container.innerHTML;
    }
  }

  Vue.compile = compileToFunctions;

  return Vue;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../node_modules/timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYmJlZDdkMDJhNTA5NmZhNmEzOTciLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL3Z1ZWpzL3Z1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJWdWUiLCJlbXB0eU9iamVjdCIsIk9iamVjdCIsImZyZWV6ZSIsImlzVW5kZWYiLCJ2IiwidW5kZWZpbmVkIiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJ2YWx1ZSIsImlzT2JqZWN0Iiwib2JqIiwiX3RvU3RyaW5nIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJ0b1Jhd1R5cGUiLCJjYWxsIiwic2xpY2UiLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsIm4iLCJwYXJzZUZsb2F0IiwiU3RyaW5nIiwiTWF0aCIsImZsb29yIiwiaXNGaW5pdGUiLCJKU09OIiwic3RyaW5naWZ5IiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwiaSIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImhhc093biIsImtleSIsImNhY2hlZCIsImZuIiwiY2FjaGUiLCJjYWNoZWRGbiIsImhpdCIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsInJlcGxhY2UiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwicG9seWZpbGxCaW5kIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJfbGVuZ3RoIiwibmF0aXZlQmluZCIsImJpbmQiLCJGdW5jdGlvbiIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsIkFycmF5IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwicmVzIiwibm9vcCIsImIiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJrZXlzIiwibSIsImNvbmNhdCIsInN0YXRpY0tleXMiLCJqb2luIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImlzQXJyYXlBIiwiaXNBcnJheSIsImlzQXJyYXlCIiwiZXZlcnkiLCJlIiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfbGlmZWN5Y2xlSG9va3MiLCJpc1Jlc2VydmVkIiwiY2hhckNvZGVBdCIsImRlZiIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYmFpbFJFIiwicGFyc2VQYXRoIiwicGF0aCIsInRlc3QiLCJzZWdtZW50cyIsImhhc1Byb3RvIiwiaW5Ccm93c2VyIiwid2luZG93IiwiaW5XZWV4IiwiV1hFbnZpcm9ubWVudCIsInBsYXRmb3JtIiwid2VleFBsYXRmb3JtIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJlbnYiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwiX1NldCIsIlNldCIsInNldCIsImhhcyIsImFkZCIsImNsZWFyIiwid2FybiIsInRpcCIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsInRyYWNlIiwiZXJyb3IiLCJpbmNsdWRlRmlsZSIsIiRyb290Iiwib3B0aW9ucyIsImNpZCIsIl9pc1Z1ZSIsIiRvcHRpb25zIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJtYXRjaCIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsInB1c2giLCJ1aWQiLCJEZXAiLCJpZCIsInN1YnMiLCJhZGRTdWIiLCJzdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJfdGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiVk5vZGUiLCJ0YWciLCJkYXRhIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZuQ29udGV4dCIsImZuT3B0aW9ucyIsImZuU2NvcGVJZCIsImNvbXBvbmVudEluc3RhbmNlIiwicGFyZW50IiwicmF3IiwiaXNTdGF0aWMiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsImFzeW5jTWV0YSIsImlzQXN5bmNQbGFjZWhvbGRlciIsInByb3RvdHlwZUFjY2Vzc29ycyIsImNoaWxkIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsIm1ldGhvZHNUb1BhdGNoIiwiZm9yRWFjaCIsIm1ldGhvZCIsIm9yaWdpbmFsIiwibXV0YXRvciIsImFyZ3MiLCJsZW4iLCJyZXN1bHQiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInNob3VsZE9ic2VydmUiLCJ0b2dnbGVPYnNlcnZpbmciLCJPYnNlcnZlciIsInZtQ291bnQiLCJhdWdtZW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUiLCJpdGVtcyIsIm9ic2VydmUiLCJzcmMiLCJfX3Byb3RvX18iLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsInByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0dGVyIiwic2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsIm1heCIsImRlbCIsInN0cmF0cyIsImVsIiwicHJvcHNEYXRhIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJob29rIiwibWVyZ2VBc3NldHMiLCJhc3NlcnRPYmplY3RUeXBlIiwidHlwZSIsImtleSQxIiwicHJvcHMiLCJtZXRob2RzIiwiaW5qZWN0IiwiY29tcHV0ZWQiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsInZhbGlkYXRlQ29tcG9uZW50TmFtZSIsIm5vcm1hbGl6ZVByb3BzIiwibm9ybWFsaXplSW5qZWN0Iiwibm9ybWFsaXplZCIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsIm1lcmdlT3B0aW9ucyIsImV4dGVuZHNGcm9tIiwiZXh0ZW5kcyIsIm1peGlucyIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInJlc29sdmVBc3NldCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJ2YWxpZGF0ZVByb3AiLCJwcm9wT3B0aW9ucyIsInByb3AiLCJhYnNlbnQiLCJib29sZWFuSW5kZXgiLCJnZXRUeXBlSW5kZXgiLCJCb29sZWFuIiwic3RyaW5nSW5kZXgiLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZE9ic2VydmUiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwidCIsImlzU2FtZVR5cGUiLCJoYW5kbGVFcnJvciIsImVyciIsImluZm8iLCJjdXIiLCJob29rcyIsImVycm9yQ2FwdHVyZWQiLCJjYXB0dXJlIiwiZ2xvYmFsSGFuZGxlRXJyb3IiLCJsb2dFcnJvciIsImNhbGxiYWNrcyIsInBlbmRpbmciLCJmbHVzaENhbGxiYWNrcyIsImNvcGllcyIsIm1pY3JvVGltZXJGdW5jIiwibWFjcm9UaW1lckZ1bmMiLCJ1c2VNYWNyb1Rhc2siLCJzZXRJbW1lZGlhdGUiLCJNZXNzYWdlQ2hhbm5lbCIsImNoYW5uZWwiLCJwb3J0IiwicG9ydDIiLCJwb3J0MSIsIm9ubWVzc2FnZSIsInBvc3RNZXNzYWdlIiwic2V0VGltZW91dCIsIlByb21pc2UiLCJwIiwicmVzb2x2ZSIsInRoZW4iLCJ3aXRoTWFjcm9UYXNrIiwiX3dpdGhUYXNrIiwibmV4dFRpY2siLCJjYiIsIl9yZXNvbHZlIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsInNlZW5PYmplY3RzIiwidHJhdmVyc2UiLCJfdHJhdmVyc2UiLCJzZWVuIiwiaXNBIiwiaXNGcm96ZW4iLCJkZXBJZCIsIm5vcm1hbGl6ZUV2ZW50IiwicGFzc2l2ZSIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwiYXJndW1lbnRzJDEiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbiIsIm9sZE9uIiwicmVtb3ZlJCQxIiwib2xkIiwiZXZlbnQiLCJwYXJhbXMiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsImhhc2giLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwibGFzdEluZGV4Iiwic2hpZnQiLCJfaXNWTGlzdCIsImVuc3VyZUN0b3IiLCJjb21wIiwiYmFzZSIsIl9fZXNNb2R1bGUiLCJ0b1N0cmluZ1RhZyIsImNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJiYXNlQ3RvciIsImVycm9yQ29tcCIsInJlc29sdmVkIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwiY29udGV4dHMiLCJzeW5jIiwiZm9yY2VSZW5kZXIiLCIkZm9yY2VVcGRhdGUiLCJyZWplY3QiLCJyZWFzb24iLCJjb21wb25lbnQiLCJkZWxheSIsInRpbWVvdXQiLCJnZXRGaXJzdENvbXBvbmVudENoaWxkIiwiaW5pdEV2ZW50cyIsIl9ldmVudHMiLCJfaGFzSG9va0V2ZW50IiwibGlzdGVuZXJzIiwiX3BhcmVudExpc3RlbmVycyIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsIiRvbmNlIiwiJG9uIiwicmVtb3ZlJDEiLCIkb2ZmIiwib2xkTGlzdGVuZXJzIiwiZXZlbnRzTWl4aW4iLCJob29rUkUiLCJ0aGlzJDEiLCJjYnMiLCJpJDEiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJzbG90IiwibmFtZSQxIiwiaXNXaGl0ZXNwYWNlIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiYWN0aXZlSW5zdGFuY2UiLCJpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQiLCJpbml0TGlmZWN5Y2xlIiwiYWJzdHJhY3QiLCIkY2hpbGRyZW4iLCIkcmVmcyIsIl93YXRjaGVyIiwiX2luYWN0aXZlIiwiX2RpcmVjdEluYWN0aXZlIiwiX2lzTW91bnRlZCIsIl9pc0Rlc3Ryb3llZCIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwiaHlkcmF0aW5nIiwiY2FsbEhvb2siLCJwcmV2RWwiLCIkZWwiLCJwcmV2Vm5vZGUiLCJfdm5vZGUiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJfX3BhdGNoX18iLCJfcGFyZW50RWxtIiwiX3JlZkVsbSIsIl9fdnVlX18iLCIkdm5vZGUiLCIkZGVzdHJveSIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInRlbXBsYXRlIiwidXBkYXRlQ29tcG9uZW50IiwiX25hbWUiLCJfdWlkIiwiX3JlbmRlciIsIldhdGNoZXIiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsInBhcmVudFZub2RlIiwicmVuZGVyQ2hpbGRyZW4iLCJoYXNDaGlsZHJlbiIsIl9yZW5kZXJDaGlsZHJlbiIsInNjb3BlZFNsb3RzIiwiJHNjb3BlZFNsb3RzIiwiX3BhcmVudFZub2RlIiwiJGF0dHJzIiwiJGxpc3RlbmVycyIsInByb3BLZXlzIiwiX3Byb3BLZXlzIiwiJHNsb3RzIiwiaXNJbkluYWN0aXZlVHJlZSIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkaXJlY3QiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJqIiwiTUFYX1VQREFURV9DT1VOVCIsInF1ZXVlIiwiYWN0aXZhdGVkQ2hpbGRyZW4iLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInNvcnQiLCJydW4iLCJ1c2VyIiwiZXhwcmVzc2lvbiIsImFjdGl2YXRlZFF1ZXVlIiwidXBkYXRlZFF1ZXVlIiwiY2FsbEFjdGl2YXRlZEhvb2tzIiwiY2FsbFVwZGF0ZWRIb29rcyIsImVtaXQiLCJxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCIsInF1ZXVlV2F0Y2hlciIsInVpZCQxIiwiZXhwT3JGbiIsImlzUmVuZGVyV2F0Y2hlciIsImRlZXAiLCJsYXp5IiwiYWN0aXZlIiwiZGlydHkiLCJkZXBzIiwibmV3RGVwcyIsImRlcElkcyIsIm5ld0RlcElkcyIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiIsInByb3h5Iiwic291cmNlS2V5IiwicHJveHlHZXR0ZXIiLCJwcm94eVNldHRlciIsImluaXRTdGF0ZSIsImluaXRQcm9wcyIsImluaXRNZXRob2RzIiwiaW5pdERhdGEiLCJpbml0Q29tcHV0ZWQiLCJpbml0V2F0Y2giLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJsb29wIiwiaHlwaGVuYXRlZEtleSIsImdldERhdGEiLCJjb21wdXRlZFdhdGNoZXJPcHRpb25zIiwid2F0Y2hlcnMiLCJfY29tcHV0ZWRXYXRjaGVycyIsImlzU1NSIiwidXNlckRlZiIsImRlZmluZUNvbXB1dGVkIiwiJGRhdGEiLCJzaG91bGRDYWNoZSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY29tcHV0ZWRHZXR0ZXIiLCJoYW5kbGVyIiwiY3JlYXRlV2F0Y2hlciIsIiR3YXRjaCIsInN0YXRlTWl4aW4iLCJkYXRhRGVmIiwicHJvcHNEZWYiLCJuZXdEYXRhIiwiJHNldCIsIiRkZWxldGUiLCJpbW1lZGlhdGUiLCJ1bndhdGNoRm4iLCJpbml0UHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwicmVzb2x2ZUluamVjdCIsImZpbHRlciIsInByb3ZpZGVLZXkiLCJzb3VyY2UiLCJwcm92aWRlRGVmYXVsdCIsInJlbmRlckxpc3QiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwibm9kZXMiLCJzbG90Tm9kZXMiLCJfcmVuZGVyZWQiLCIkY3JlYXRlRWxlbWVudCIsInJlc29sdmVGaWx0ZXIiLCJpc0tleU5vdE1hdGNoIiwiZXhwZWN0IiwiYWN0dWFsIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5LZXlDb2RlIiwiZXZlbnRLZXlOYW1lIiwiYnVpbHRJbktleU5hbWUiLCJtYXBwZWRLZXlDb2RlIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwic3RhdGljUmVuZGVyRm5zIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwiaW5zdGFsbFJlbmRlckhlbHBlcnMiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwiX2ciLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsImNvbnRleHRWbSIsIl9vcmlnaW5hbCIsImlzQ29tcGlsZWQiLCJfY29tcGlsZWQiLCJuZWVkTm9ybWFsaXphdGlvbiIsImluamVjdGlvbnMiLCJfc2NvcGVJZCIsIl9jIiwiZCIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibWVyZ2VQcm9wcyIsInJlbmRlckNvbnRleHQiLCJjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0Iiwidm5vZGVzIiwiY2xvbmUiLCJjb21wb25lbnRWTm9kZUhvb2tzIiwiaW5pdCIsInBhcmVudEVsbSIsInJlZkVsbSIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwib2xkVm5vZGUiLCJpbnNlcnQiLCJkZXN0cm95IiwiaG9va3NUb01lcmdlIiwiY3JlYXRlQ29tcG9uZW50IiwiX2Jhc2UiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImZ1bmN0aW9uYWwiLCJuYXRpdmVPbiIsImluc3RhbGxDb21wb25lbnRIb29rcyIsIl9pc0NvbXBvbmVudCIsImlubGluZVRlbXBsYXRlIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsImFwcGx5TlMiLCJyZWdpc3RlckRlZXBCaW5kaW5ncyIsImZvcmNlIiwic3R5bGUiLCJjbGFzcyIsImluaXRSZW5kZXIiLCJwYXJlbnREYXRhIiwicmVuZGVyTWl4aW4iLCIkbmV4dFRpY2siLCJyZWYiLCJyZW5kZXJFcnJvciIsInVpZCQzIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsImV4dGVuZGVkIiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImRlZHVwZSIsImluaXRVc2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsZWRQbHVnaW5zIiwiX2luc3RhbGxlZFBsdWdpbnMiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiUmVnRXhwIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJOdW1iZXIiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwibW91bnRlZCIsInJlZiQxIiwicGFyc2VJbnQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVsZXRlIiwic3NyQ29udGV4dCIsInZlcnNpb24iLCJhY2NlcHRWYWx1ZSIsImF0dHIiLCJpc0VudW1lcmF0ZWRBdHRyIiwiaXNCb29sZWFuQXR0ciIsInhsaW5rTlMiLCJpc1hsaW5rIiwiZ2V0WGxpbmtQcm9wIiwiaXNGYWxzeUF0dHJWYWx1ZSIsImdlbkNsYXNzRm9yVm5vZGUiLCJwYXJlbnROb2RlIiwiY2hpbGROb2RlIiwibWVyZ2VDbGFzc0RhdGEiLCJyZW5kZXJDbGFzcyIsInN0YXRpY0NsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZnlBcnJheSIsInN0cmluZ2lmeU9iamVjdCIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwiaXNQcmVUYWciLCJ1bmtub3duRWxlbWVudENhY2hlIiwiZG9jdW1lbnQiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzVGV4dElucHV0VHlwZSIsInF1ZXJ5Iiwic2VsZWN0ZWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwibmFtZXNwYWNlIiwiY3JlYXRlVGV4dE5vZGUiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50Iiwic2V0U3R5bGVTY29wZSIsInNjb3BlSWQiLCJub2RlT3BzIiwicmVnaXN0ZXJSZWYiLCJpc1JlbW92YWwiLCJyZWZzIiwicmVmSW5Gb3IiLCJlbXB0eU5vZGUiLCJzYW1lVm5vZGUiLCJzYW1lSW5wdXRUeXBlIiwidHlwZUEiLCJ0eXBlQiIsImNyZWF0ZUtleVRvT2xkSWR4IiwiYmVnaW5JZHgiLCJlbmRJZHgiLCJjcmVhdGVQYXRjaEZ1bmN0aW9uIiwiYmFja2VuZCIsImVtcHR5Tm9kZUF0IiwiY3JlYXRlUm1DYiIsImNoaWxkRWxtIiwicmVtb3ZlTm9kZSIsImlzVW5rbm93bkVsZW1lbnQkJDEiLCJpblZQcmUiLCJzb21lIiwiaWdub3JlIiwiY3JlYXRpbmdFbG1JblZQcmUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJuZXN0ZWQiLCJvd25lckFycmF5IiwicHJlIiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiY2hlY2tEdXBsaWNhdGVLZXlzIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiZmluZElkeEluT2xkIiwic2VlbktleXMiLCJlbmQiLCJoeWRyYXRlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJoeWRyYXRpb25CYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImlubmVySFRNTCIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsImZ1bGxJbnZva2UiLCJub2RlVHlwZSIsInBhdGNoIiwiaXNJbml0aWFsUGF0Y2giLCJpc1JlYWxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwicGFyZW50RWxtJDEiLCJfbGVhdmVDYiIsInBhdGNoYWJsZSIsImkkMiIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJkaXIiLCJjYWxsSG9vayQxIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsImluaGVyaXRBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiYmFzZVNldEF0dHIiLCJzZXRBdHRyaWJ1dGVOUyIsIl9faWVwaCIsImJsb2NrZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJwcmV2IiwiZmlsdGVycyIsInRyaW0iLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJwbGFpbiIsImFkZEF0dHIiLCJhZGRSYXdBdHRyIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJhZGREaXJlY3RpdmUiLCJhcmciLCJhZGRIYW5kbGVyIiwiaW1wb3J0YW50IiwicHJldmVudCIsInJpZ2h0IiwibWlkZGxlIiwiZXZlbnRzIiwibmF0aXZlIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwicmVtb3ZlRnJvbU1hcCIsImdlbkNvbXBvbmVudE1vZGVsIiwibnVtYmVyIiwiYmFzZVZhbHVlRXhwcmVzc2lvbiIsInZhbHVlRXhwcmVzc2lvbiIsImFzc2lnbm1lbnQiLCJnZW5Bc3NpZ25tZW50Q29kZSIsInBhcnNlTW9kZWwiLCJjaHIiLCJpbmRleCQxIiwiZXhwcmVzc2lvblBvcyIsImV4cHJlc3Npb25FbmRQb3MiLCJsYXN0SW5kZXhPZiIsImVvZiIsIm5leHQiLCJpc1N0cmluZ1N0YXJ0IiwicGFyc2VTdHJpbmciLCJwYXJzZUJyYWNrZXQiLCJpbkJyYWNrZXQiLCJzdHJpbmdRdW90ZSIsIndhcm4kMSIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJfd2FybiIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwidmFsdWUkMSIsInR5cGVCaW5kaW5nIiwiYmluZGluZyIsIm5lZWRDb21wb3NpdGlvbkd1YXJkIiwibm9ybWFsaXplRXZlbnRzIiwiY2hhbmdlIiwidGFyZ2V0JDEiLCJjcmVhdGVPbmNlSGFuZGxlciIsIm9uY2VIYW5kbGVyIiwicmVtb3ZlJDIiLCJhZGQkMSIsInVwZGF0ZURPTUxpc3RlbmVycyIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNOb3RJbkZvY3VzQW5kRGlydHkiLCJpc0RpcnR5V2l0aE1vZGlmaWVycyIsIm5vdEluRm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsImRpcmVjdGl2ZSIsIl92T3B0aW9ucyIsInNldFNlbGVjdGVkIiwiZ2V0VmFsdWUiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uRW5kIiwicHJldk9wdGlvbnMiLCJjdXJPcHRpb25zIiwibyIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJhY3R1YWxseVNldFNlbGVjdGVkIiwiaXNNdWx0aXBsZSIsIm9wdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwidHJhbnNpdGlvbiQkMSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJwbGFjZWhvbGRlciIsImgiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwia2VwdCIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJiZWZvcmVVcGRhdGUiLCJ1cGRhdGVkIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiX3JlZmxvdyIsImJvZHkiLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwibGVmdCIsImR5IiwidG9wIiwicGxhdGZvcm1Db21wb25lbnRzIiwiZGVmYXVsdFRhZ1JFIiwicmVnZXhFc2NhcGVSRSIsImJ1aWxkUmVnZXgiLCJkZWxpbWl0ZXJzIiwib3BlbiIsImNsb3NlIiwicGFyc2VUZXh0IiwidGFnUkUiLCJ0b2tlbnMiLCJyYXdUb2tlbnMiLCJ0b2tlblZhbHVlIiwiZXhlYyIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMSIsInN0eWxlJDEiLCJkZWNvZGVyIiwiaGUiLCJkZWNvZGUiLCJodG1sIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYXR0cmlidXRlIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiIsImciLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJyZUNhY2hlIiwiZGVjb2RpbmdNYXAiLCJlbmNvZGVkQXR0ciIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiaXNJZ25vcmVOZXdsaW5lVGFnIiwic2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lIiwiZGVjb2RlQXR0ciIsInNob3VsZERlY29kZU5ld2xpbmVzIiwicmUiLCJwYXJzZUhUTUwiLCJzdGFjayIsImV4cGVjdEhUTUwiLCJpc1VuYXJ5VGFnJCQxIiwiY2FuQmVMZWZ0T3BlblRhZyQkMSIsImxhc3RUYWciLCJ0ZXh0RW5kIiwiY29tbWVudEVuZCIsInNob3VsZEtlZXBDb21tZW50Iiwic3Vic3RyaW5nIiwiYWR2YW5jZSIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZW5kVGFnTWF0Y2giLCJjdXJJbmRleCIsInBhcnNlRW5kVGFnIiwic3RhcnRUYWdNYXRjaCIsInBhcnNlU3RhcnRUYWciLCJoYW5kbGVTdGFydFRhZyIsInJlc3QiLCJjaGFycyIsImVuZFRhZ0xlbmd0aCIsInN0YWNrZWRUYWciLCJyZVN0YWNrZWRUYWciLCJyZXN0JDEiLCJhbGwiLCJ1bmFyeVNsYXNoIiwidW5hcnkiLCJzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJvblJFIiwiZGlyUkUiLCJmb3JBbGlhc1JFIiwiZm9ySXRlcmF0b3JSRSIsInN0cmlwUGFyZW5zUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJjcmVhdGVBU1RFbGVtZW50IiwibWFrZUF0dHJzTWFwIiwicGFyc2UiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJyb290IiwiY3VycmVudFBhcmVudCIsImluUHJlIiwid2FybmVkIiwid2Fybk9uY2UiLCJjbG9zZUVsZW1lbnQiLCJlbGVtZW50IiwiY29tbWVudHMiLCJndWFyZElFU1ZHQnVnIiwiaXNGb3JiaWRkZW5UYWciLCJmb3JiaWRkZW4iLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc2VkIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwicHJvY2Vzc0VsZW1lbnQiLCJjaGVja1Jvb3RDb25zdHJhaW50cyIsImlmIiwiZWxzZWlmIiwiZWxzZSIsImFkZElmQ29uZGl0aW9uIiwiYmxvY2siLCJwcm9jZXNzSWZDb25kaXRpb25zIiwic2xvdFNjb3BlIiwic2xvdFRhcmdldCIsImxhc3ROb2RlIiwiaXNUZXh0VGFnIiwicHJvY2Vzc0tleSIsInByb2Nlc3NSZWYiLCJwcm9jZXNzU2xvdCIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJjaGVja0luRm9yIiwicGFyc2VGb3IiLCJpbk1hdGNoIiwiZm9yIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiaXRlcmF0b3IxIiwiaXRlcmF0b3IyIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdE5hbWUiLCJpc1Byb3AiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwicHJlVHJhbnNmb3JtTm9kZSIsImlmQ29uZGl0aW9uIiwiaWZDb25kaXRpb25FeHRyYSIsImhhc0Vsc2UiLCJlbHNlSWZDb25kaXRpb24iLCJicmFuY2gwIiwiY2xvbmVBU1RFbGVtZW50IiwiYnJhbmNoMSIsImJyYW5jaDIiLCJtb2RlbCQyIiwibW9kdWxlcyQxIiwiZGlyZWN0aXZlcyQxIiwiYmFzZU9wdGlvbnMiLCJpc1N0YXRpY0tleSIsImlzUGxhdGZvcm1SZXNlcnZlZFRhZyIsImdlblN0YXRpY0tleXNDYWNoZWQiLCJnZW5TdGF0aWNLZXlzJDEiLCJvcHRpbWl6ZSIsIm1hcmtTdGF0aWMkMSIsIm1hcmtTdGF0aWNSb290cyIsInN0YXRpYyIsImwkMSIsInN0YXRpY0luRm9yIiwic3RhdGljUm9vdCIsImlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIiwiZm5FeHBSRSIsInNpbXBsZVBhdGhSRSIsImVzYyIsInRhYiIsInNwYWNlIiwidXAiLCJkb3duIiwia2V5TmFtZXMiLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJzZWxmIiwiY3RybCIsImFsdCIsIm1ldGEiLCJnZW5IYW5kbGVycyIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImdlbk1vZGlmaWVyQ29kZSIsImtleU1vZGlmaWVyIiwiZ2VuS2V5RmlsdGVyIiwiaGFuZGxlckNvZGUiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwia2V5Q29kZSIsImtleU5hbWUiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm1heWJlQ29tcG9uZW50Iiwib25jZUlkIiwiZ2VuZXJhdGUiLCJhc3QiLCJzdGF0ZSIsImdlbkVsZW1lbnQiLCJzdGF0aWNQcm9jZXNzZWQiLCJnZW5TdGF0aWMiLCJvbmNlUHJvY2Vzc2VkIiwiZ2VuT25jZSIsImZvclByb2Nlc3NlZCIsImdlbkZvciIsImlmUHJvY2Vzc2VkIiwiZ2VuSWYiLCJnZW5DaGlsZHJlbiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhJDIiLCJhbHRHZW4iLCJhbHRFbXB0eSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwiYWx0SGVscGVyIiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImdlblNjb3BlZFNsb3QiLCJnZW5Gb3JTY29wZWRTbG90IiwiY2hlY2tTa2lwIiwiYWx0R2VuRWxlbWVudCIsImFsdEdlbk5vZGUiLCJlbCQxIiwiZ2V0Tm9ybWFsaXphdGlvblR5cGUiLCJnZW5Ob2RlIiwibmVlZHNOb3JtYWxpemF0aW9uIiwiZ2VuQ29tbWVudCIsImdlblRleHQiLCJ0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMiLCJiaW5kJCQxIiwiY29tcG9uZW50TmFtZSIsInByb2hpYml0ZWRLZXl3b3JkUkUiLCJ1bmFyeU9wZXJhdG9yc1JFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsIm1lc3NhZ2UiLCJjcmVhdGVGdW5jdGlvbiIsImNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4iLCJjb21waWxlIiwiY29tcGlsZVRvRnVuY3Rpb25zIiwid2FybiQkMSIsImNvbXBpbGVkIiwidGlwcyIsImZuR2VuRXJyb3JzIiwiY3JlYXRlQ29tcGlsZXJDcmVhdG9yIiwiYmFzZUNvbXBpbGUiLCJjcmVhdGVDb21waWxlciIsImZpbmFsT3B0aW9ucyIsImRpdiIsImdldFNob3VsZERlY29kZSIsImhyZWYiLCJpZFRvVGVtcGxhdGUiLCJtb3VudCIsImRvY3VtZW50RWxlbWVudCIsImdldE91dGVySFRNTCIsIm91dGVySFRNTCIsImNvbnRhaW5lciJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUM3REE7Ozs7O0FBS0MsV0FBVUEsTUFBVixFQUFrQkMsT0FBbEIsRUFBMkI7QUFDM0Isa0NBQU9DLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0IsT0FBT0MsTUFBUCxLQUFrQixXQUFqRCxHQUErREEsT0FBT0QsT0FBUCxHQUFpQkQsU0FBaEYsR0FDQSxRQUE2QyxvQ0FBT0EsT0FBUDtBQUFBO0FBQUE7QUFBQTtBQUFBLG9HQUE3QyxHQUNDRCxPQUFPSSxHQUFQLEdBQWFILFNBRmQ7QUFHQSxDQUpBLEVBSUMsSUFKRCxFQUlRLFlBQVk7QUFBRTs7QUFFdkI7O0FBRUEsTUFBSUksY0FBY0MsT0FBT0MsTUFBUCxDQUFjLEVBQWQsQ0FBbEI7O0FBRUE7QUFDQTtBQUNBLFdBQVNDLE9BQVQsQ0FBa0JDLENBQWxCLEVBQXFCO0FBQ25CLFdBQU9BLE1BQU1DLFNBQU4sSUFBbUJELE1BQU0sSUFBaEM7QUFDRDs7QUFFRCxXQUFTRSxLQUFULENBQWdCRixDQUFoQixFQUFtQjtBQUNqQixXQUFPQSxNQUFNQyxTQUFOLElBQW1CRCxNQUFNLElBQWhDO0FBQ0Q7O0FBRUQsV0FBU0csTUFBVCxDQUFp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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQixFQUFFO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7OztBQ3pMRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDOURBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6InZ1ZWpzL2FwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9idWlsZC9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vYXNzZXRzL2pzL3Z1ZWpzL3Z1ZS5qc1wiKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBiYmVkN2QwMmE1MDk2ZmE2YTM5NyIsIi8qIVxyXG4gKiBWdWUuanMgdjIuNS4xNlxyXG4gKiAoYykgMjAxNC0yMDE4IEV2YW4gWW91XHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxyXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XHJcblx0KGdsb2JhbC5WdWUgPSBmYWN0b3J5KCkpO1xyXG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XHJcblxyXG4vLyB0aGVzZSBoZWxwZXJzIHByb2R1Y2VzIGJldHRlciB2bSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXHJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcclxuZnVuY3Rpb24gaXNVbmRlZiAodikge1xyXG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0RlZiAodikge1xyXG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcclxuICByZXR1cm4gdiA9PT0gdHJ1ZVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XHJcbiAgcmV0dXJuIHYgPT09IGZhbHNlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcclxuICovXHJcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xyXG4gIHJldHVybiAoXHJcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XHJcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XHJcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcclxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXHJcbiAgKVxyXG59XHJcblxyXG4vKipcclxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXHJcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcclxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xyXG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUgZS5nLiBbb2JqZWN0IE9iamVjdF1cclxuICovXHJcbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5cclxuZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xyXG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXHJcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcclxuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcclxufVxyXG5cclxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcclxuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cclxuICovXHJcbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcclxuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xyXG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cclxuICovXHJcbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcclxuICByZXR1cm4gdmFsID09IG51bGxcclxuICAgID8gJydcclxuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcclxuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXHJcbiAgICAgIDogU3RyaW5nKHZhbClcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXHJcbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xyXG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cclxufVxyXG5cclxuLyoqXHJcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxyXG4gKiBpcyBpbiB0aGF0IG1hcC5cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VNYXAgKFxyXG4gIHN0cixcclxuICBleHBlY3RzTG93ZXJDYXNlXHJcbikge1xyXG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxyXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XHJcbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cclxuICovXHJcbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxyXG4gKi9cclxudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XHJcbiAgaWYgKGFyci5sZW5ndGgpIHtcclxuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xyXG4gICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXHJcbiAqL1xyXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XHJcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XHJcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcclxuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xyXG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXHJcbiAgfSlcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXHJcbiAqL1xyXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcclxudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcclxuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcclxufSk7XHJcblxyXG4vKipcclxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cclxuICovXHJcbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcclxuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXHJcbiAqL1xyXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xyXG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcclxuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdC4uLiBlLmcuXHJcbiAqIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5IHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlIHNpbmNlIG5hdGl2ZSBiaW5kIGlzXHJcbiAqIG5vdyBtb3JlIHBlcmZvcm1hbnQgaW4gbW9zdCBicm93c2VycywgYnV0IHJlbW92aW5nIGl0IHdvdWxkIGJlIGJyZWFraW5nIGZvclxyXG4gKiBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvclxyXG4gKiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cclxuICovXHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBwb2x5ZmlsbEJpbmQgKGZuLCBjdHgpIHtcclxuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XHJcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICByZXR1cm4gbFxyXG4gICAgICA/IGwgPiAxXHJcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcclxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxyXG4gICAgICA6IGZuLmNhbGwoY3R4KVxyXG4gIH1cclxuXHJcbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xyXG4gIHJldHVybiBib3VuZEZuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5hdGl2ZUJpbmQgKGZuLCBjdHgpIHtcclxuICByZXR1cm4gZm4uYmluZChjdHgpXHJcbn1cclxuXHJcbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcclxuICA/IG5hdGl2ZUJpbmRcclxuICA6IHBvbHlmaWxsQmluZDtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cclxuICovXHJcbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XHJcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xyXG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcclxuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xyXG4gIHdoaWxlIChpLS0pIHtcclxuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcclxuICB9XHJcbiAgcmV0dXJuIHJldFxyXG59XHJcblxyXG4vKipcclxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcclxuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcclxuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gdG9cclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XHJcbiAgdmFyIHJlcyA9IHt9O1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoYXJyW2ldKSB7XHJcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxyXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcclxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pXHJcbiAqL1xyXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxyXG5cclxuLyoqXHJcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XHJcblxyXG4vKipcclxuICogUmV0dXJuIHNhbWUgdmFsdWVcclxuICovXHJcbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cclxuICovXHJcbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcclxuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcclxuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXHJcbiAgfSwgW10pLmpvaW4oJywnKVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXHJcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cclxuICovXHJcbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcclxuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XHJcbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xyXG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcclxuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcclxuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcclxuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XHJcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XHJcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xyXG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xyXG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xyXG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcclxuICAgICAgICB9KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcclxuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cclxuICB9XHJcbiAgcmV0dXJuIC0xXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxyXG4gKi9cclxuZnVuY3Rpb24gb25jZSAoZm4pIHtcclxuICB2YXIgY2FsbGVkID0gZmFsc2U7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghY2FsbGVkKSB7XHJcbiAgICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xyXG5cclxudmFyIEFTU0VUX1RZUEVTID0gW1xyXG4gICdjb21wb25lbnQnLFxyXG4gICdkaXJlY3RpdmUnLFxyXG4gICdmaWx0ZXInXHJcbl07XHJcblxyXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xyXG4gICdiZWZvcmVDcmVhdGUnLFxyXG4gICdjcmVhdGVkJyxcclxuICAnYmVmb3JlTW91bnQnLFxyXG4gICdtb3VudGVkJyxcclxuICAnYmVmb3JlVXBkYXRlJyxcclxuICAndXBkYXRlZCcsXHJcbiAgJ2JlZm9yZURlc3Ryb3knLFxyXG4gICdkZXN0cm95ZWQnLFxyXG4gICdhY3RpdmF0ZWQnLFxyXG4gICdkZWFjdGl2YXRlZCcsXHJcbiAgJ2Vycm9yQ2FwdHVyZWQnXHJcbl07XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBjb25maWcgPSAoe1xyXG4gIC8qKlxyXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxyXG4gICAqL1xyXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcclxuXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cclxuICAgKi9cclxuICBzaWxlbnQ6IGZhbHNlLFxyXG5cclxuICAvKipcclxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xyXG4gICAqL1xyXG4gIHByb2R1Y3Rpb25UaXA6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxyXG5cclxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xyXG4gICAqL1xyXG4gIGRldnRvb2xzOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcclxuXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxyXG4gICAqL1xyXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcclxuXHJcbiAgLyoqXHJcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcclxuICAgKi9cclxuICBlcnJvckhhbmRsZXI6IG51bGwsXHJcblxyXG4gIC8qKlxyXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xyXG4gICAqL1xyXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxyXG5cclxuICAvKipcclxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcclxuICAgKi9cclxuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxyXG5cclxuICAvKipcclxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxyXG4gICAqL1xyXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcclxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXHJcbiAgICovXHJcbiAgaXNSZXNlcnZlZFRhZzogbm8sXHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XHJcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cclxuICAgKi9cclxuICBpc1Jlc2VydmVkQXR0cjogbm8sXHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cclxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXHJcbiAgICovXHJcbiAgaXNVbmtub3duRWxlbWVudDogbm8sXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcclxuICAgKi9cclxuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXHJcblxyXG4gIC8qKlxyXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXHJcbiAgICovXHJcbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxyXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cclxuICAgKi9cclxuICBtdXN0VXNlUHJvcDogbm8sXHJcblxyXG4gIC8qKlxyXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXHJcbiAgICovXHJcbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1NcclxufSlcclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xyXG4gKi9cclxuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XHJcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XHJcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxyXG59XHJcblxyXG4vKipcclxuICogRGVmaW5lIGEgcHJvcGVydHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgIHZhbHVlOiB2YWwsXHJcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2Ugc2ltcGxlIHBhdGguXHJcbiAqL1xyXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcclxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XHJcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XHJcbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqXHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xyXG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcclxuXHJcbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcclxudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xyXG52YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcclxudmFyIHdlZXhQbGF0Zm9ybSA9IGluV2VleCAmJiBXWEVudmlyb25tZW50LnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XHJcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xyXG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xyXG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcclxudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xyXG52YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XHJcbnZhciBpc0lPUyA9IChVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpKSB8fCAod2VleFBsYXRmb3JtID09PSAnaW9zJyk7XHJcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xyXG5cclxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxyXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xyXG5cclxudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xyXG5pZiAoaW5Ccm93c2VyKSB7XHJcbiAgdHJ5IHtcclxuICAgIHZhciBvcHRzID0ge307XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcclxuICB9IGNhdGNoIChlKSB7fVxyXG59XHJcblxyXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcclxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcclxudmFyIF9pc1NlcnZlcjtcclxudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxyXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXHJcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gX2lzU2VydmVyXHJcbn07XHJcblxyXG4vLyBkZXRlY3QgZGV2dG9vbHNcclxudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xyXG5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcclxuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcclxufVxyXG5cclxudmFyIGhhc1N5bWJvbCA9XHJcbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxyXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xyXG5cclxudmFyIF9TZXQ7XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcclxuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cclxuICBfU2V0ID0gU2V0O1xyXG59IGVsc2Uge1xyXG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cclxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNldCAoKSB7XHJcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIH1cclxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcclxuICAgIH07XHJcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XHJcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XHJcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFNldDtcclxuICB9KCkpO1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciB3YXJuID0gbm9vcDtcclxudmFyIHRpcCA9IG5vb3A7XHJcbnZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXHJcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xyXG5cclxue1xyXG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xyXG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xyXG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcclxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcclxuXHJcbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XHJcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XHJcblxyXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xyXG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XHJcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xyXG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxyXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xyXG4gICAgICApKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xyXG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xyXG4gICAgICByZXR1cm4gJzxSb290PidcclxuICAgIH1cclxuICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLmNpZCAhPSBudWxsXHJcbiAgICAgID8gdm0ub3B0aW9uc1xyXG4gICAgICA6IHZtLl9pc1Z1ZVxyXG4gICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xyXG4gICAgICAgIDogdm0gfHwge307XHJcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XHJcbiAgICB2YXIgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xyXG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcclxuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XHJcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcclxuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcclxuICAgIClcclxuICB9O1xyXG5cclxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xyXG4gICAgdmFyIHJlcyA9ICcnO1xyXG4gICAgd2hpbGUgKG4pIHtcclxuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cclxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cclxuICAgICAgbiA+Pj0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXNcclxuICB9O1xyXG5cclxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XHJcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcclxuICAgICAgdmFyIHRyZWUgPSBbXTtcclxuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XHJcbiAgICAgIHdoaWxlICh2bSkge1xyXG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xyXG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcclxuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XHJcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyZWUucHVzaCh2bSk7XHJcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxyXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXHJcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxyXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXHJcbiAgICAgICAgLmpvaW4oJ1xcbicpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuXHJcbnZhciB1aWQgPSAwO1xyXG5cclxuLyoqXHJcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxyXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxyXG4gKi9cclxudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XHJcbiAgdGhpcy5pZCA9IHVpZCsrO1xyXG4gIHRoaXMuc3VicyA9IFtdO1xyXG59O1xyXG5cclxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xyXG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XHJcbn07XHJcblxyXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XHJcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcclxufTtcclxuXHJcbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcclxuICBpZiAoRGVwLnRhcmdldCkge1xyXG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xyXG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XHJcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcclxuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cclxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxyXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cclxuRGVwLnRhcmdldCA9IG51bGw7XHJcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xyXG5cclxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xyXG4gIGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cclxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcclxufVxyXG5cclxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcclxuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxyXG4gIHRhZyxcclxuICBkYXRhLFxyXG4gIGNoaWxkcmVuLFxyXG4gIHRleHQsXHJcbiAgZWxtLFxyXG4gIGNvbnRleHQsXHJcbiAgY29tcG9uZW50T3B0aW9ucyxcclxuICBhc3luY0ZhY3RvcnlcclxuKSB7XHJcbiAgdGhpcy50YWcgPSB0YWc7XHJcbiAgdGhpcy5kYXRhID0gZGF0YTtcclxuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgdGhpcy50ZXh0ID0gdGV4dDtcclxuICB0aGlzLmVsbSA9IGVsbTtcclxuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xyXG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XHJcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xyXG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XHJcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcclxuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICB0aGlzLnJhdyA9IGZhbHNlO1xyXG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcclxuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XHJcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcclxuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XHJcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcclxuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcclxuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcclxuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xyXG59O1xyXG5cclxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcclxuXHJcbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XHJcblxyXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XHJcblxyXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XHJcbiAgbm9kZS50ZXh0ID0gdGV4dDtcclxuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XHJcbiAgcmV0dXJuIG5vZGVcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XHJcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcclxufVxyXG5cclxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcclxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xyXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcclxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cclxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcclxuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxyXG4gICAgdm5vZGUudGFnLFxyXG4gICAgdm5vZGUuZGF0YSxcclxuICAgIHZub2RlLmNoaWxkcmVuLFxyXG4gICAgdm5vZGUudGV4dCxcclxuICAgIHZub2RlLmVsbSxcclxuICAgIHZub2RlLmNvbnRleHQsXHJcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxyXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XHJcbiAgKTtcclxuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcclxuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcclxuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xyXG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XHJcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcclxuICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xyXG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XHJcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcclxuICByZXR1cm4gY2xvbmVkXHJcbn1cclxuXHJcbi8qXHJcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxyXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcclxuICovXHJcblxyXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcclxudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XHJcblxyXG52YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXHJcbiAgJ3B1c2gnLFxyXG4gICdwb3AnLFxyXG4gICdzaGlmdCcsXHJcbiAgJ3Vuc2hpZnQnLFxyXG4gICdzcGxpY2UnLFxyXG4gICdzb3J0JyxcclxuICAncmV2ZXJzZSdcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcclxuICovXHJcbm1ldGhvZHNUb1BhdGNoLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxyXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcclxuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XHJcbiAgICB2YXIgaW5zZXJ0ZWQ7XHJcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xyXG4gICAgICBjYXNlICdwdXNoJzpcclxuICAgICAgY2FzZSAndW5zaGlmdCc6XHJcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgJ3NwbGljZSc6XHJcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICB9XHJcbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxyXG4gICAgLy8gbm90aWZ5IGNoYW5nZVxyXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XHJcblxyXG4vKipcclxuICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXHJcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cclxuICovXHJcbnZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcclxuXHJcbmZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcclxuICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcclxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxyXG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxyXG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cclxuICovXHJcbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xyXG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcclxuICB0aGlzLnZtQ291bnQgPSAwO1xyXG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xyXG4gICAgICA/IHByb3RvQXVnbWVudFxyXG4gICAgICA6IGNvcHlBdWdtZW50O1xyXG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xyXG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLndhbGsodmFsdWUpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cclxuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXHJcbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxyXG4gKi9cclxuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcclxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBkZWZpbmVSZWFjdGl2ZShvYmosIGtleXNbaV0pO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cclxuICovXHJcbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIGhlbHBlcnNcclxuXHJcbi8qKlxyXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXHJcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXHJcbiAqL1xyXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XHJcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cclxuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xyXG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cclxufVxyXG5cclxuLyoqXHJcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xyXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cclxuICovXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXHJcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXHJcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxyXG4gKi9cclxuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcclxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgdmFyIG9iO1xyXG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xyXG4gICAgb2IgPSB2YWx1ZS5fX29iX187XHJcbiAgfSBlbHNlIGlmIChcclxuICAgIHNob3VsZE9ic2VydmUgJiZcclxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXHJcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXHJcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxyXG4gICAgIXZhbHVlLl9pc1Z1ZVxyXG4gICkge1xyXG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xyXG4gIH1cclxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xyXG4gICAgb2Iudm1Db3VudCsrO1xyXG4gIH1cclxuICByZXR1cm4gb2JcclxufVxyXG5cclxuLyoqXHJcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlIChcclxuICBvYmosXHJcbiAga2V5LFxyXG4gIHZhbCxcclxuICBjdXN0b21TZXR0ZXIsXHJcbiAgc2hhbGxvd1xyXG4pIHtcclxuICB2YXIgZGVwID0gbmV3IERlcCgpO1xyXG5cclxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcclxuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcclxuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xyXG4gIGlmICghZ2V0dGVyICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcclxuICAgIHZhbCA9IG9ialtrZXldO1xyXG4gIH1cclxuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xyXG5cclxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcclxuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcclxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcclxuICAgICAgICBkZXAuZGVwZW5kKCk7XHJcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcclxuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xyXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXHJcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcclxuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2V0dGVyKSB7XHJcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcclxuICAgICAgfVxyXG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xyXG4gICAgICBkZXAubm90aWZ5KCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcclxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxyXG4gKiBhbHJlYWR5IGV4aXN0LlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XHJcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXHJcbiAgKSB7XHJcbiAgICB3YXJuKChcIkNhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xyXG4gIH1cclxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcclxuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xyXG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XHJcbiAgICByZXR1cm4gdmFsXHJcbiAgfVxyXG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XHJcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcclxuICAgIHJldHVybiB2YWxcclxuICB9XHJcbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xyXG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xyXG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xyXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xyXG4gICAgKTtcclxuICAgIHJldHVybiB2YWxcclxuICB9XHJcbiAgaWYgKCFvYikge1xyXG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XHJcbiAgICByZXR1cm4gdmFsXHJcbiAgfVxyXG4gIGRlZmluZVJlYWN0aXZlKG9iLnZhbHVlLCBrZXksIHZhbCk7XHJcbiAgb2IuZGVwLm5vdGlmeSgpO1xyXG4gIHJldHVybiB2YWxcclxufVxyXG5cclxuLyoqXHJcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XHJcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXHJcbiAgKSB7XHJcbiAgICB3YXJuKChcIkNhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xyXG4gIH1cclxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcclxuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XHJcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XHJcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcclxuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXHJcbiAgICApO1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcclxuICBpZiAoIW9iKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgb2IuZGVwLm5vdGlmeSgpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcclxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcclxuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBlID0gdmFsdWVbaV07XHJcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XHJcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxyXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxyXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cclxuICovXHJcbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xyXG5cclxuLyoqXHJcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcclxuICovXHJcbntcclxuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcclxuICAgIGlmICghdm0pIHtcclxuICAgICAgd2FybihcclxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xyXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XHJcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XHJcbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XHJcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGtleSA9IGtleXNbaV07XHJcbiAgICB0b1ZhbCA9IHRvW2tleV07XHJcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xyXG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcclxuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xyXG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XHJcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0b1xyXG59XHJcblxyXG4vKipcclxuICogRGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXHJcbiAgcGFyZW50VmFsLFxyXG4gIGNoaWxkVmFsLFxyXG4gIHZtXHJcbikge1xyXG4gIGlmICghdm0pIHtcclxuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXHJcbiAgICBpZiAoIWNoaWxkVmFsKSB7XHJcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcclxuICAgIH1cclxuICAgIGlmICghcGFyZW50VmFsKSB7XHJcbiAgICAgIHJldHVybiBjaGlsZFZhbFxyXG4gICAgfVxyXG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxyXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXHJcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cclxuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxyXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcclxuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcclxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXHJcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXHJcbiAgICAgIClcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcclxuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcclxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXHJcbiAgICAgICAgOiBjaGlsZFZhbDtcclxuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxyXG4gICAgICAgIDogcGFyZW50VmFsO1xyXG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcclxuICBwYXJlbnRWYWwsXHJcbiAgY2hpbGRWYWwsXHJcbiAgdm1cclxuKSB7XHJcbiAgaWYgKCF2bSkge1xyXG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xyXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xyXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxyXG4gICAgICAgIHZtXHJcbiAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm4gcGFyZW50VmFsXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXHJcbn07XHJcblxyXG4vKipcclxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VIb29rIChcclxuICBwYXJlbnRWYWwsXHJcbiAgY2hpbGRWYWxcclxuKSB7XHJcbiAgcmV0dXJuIGNoaWxkVmFsXHJcbiAgICA/IHBhcmVudFZhbFxyXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXHJcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcclxuICAgICAgICA/IGNoaWxkVmFsXHJcbiAgICAgICAgOiBbY2hpbGRWYWxdXHJcbiAgICA6IHBhcmVudFZhbFxyXG59XHJcblxyXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xyXG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcclxufSk7XHJcblxyXG4vKipcclxuICogQXNzZXRzXHJcbiAqXHJcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cclxuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxyXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChcclxuICBwYXJlbnRWYWwsXHJcbiAgY2hpbGRWYWwsXHJcbiAgdm0sXHJcbiAga2V5XHJcbikge1xyXG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcclxuICBpZiAoY2hpbGRWYWwpIHtcclxuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xyXG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfVxyXG59XHJcblxyXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFdhdGNoZXJzLlxyXG4gKlxyXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXHJcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxyXG4gKi9cclxuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKFxyXG4gIHBhcmVudFZhbCxcclxuICBjaGlsZFZhbCxcclxuICB2bSxcclxuICBrZXlcclxuKSB7XHJcbiAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cclxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cclxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxyXG4gIHtcclxuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xyXG4gIH1cclxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxyXG4gIHZhciByZXQgPSB7fTtcclxuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xyXG4gIGZvciAodmFyIGtleSQxIGluIGNoaWxkVmFsKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcclxuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcclxuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xyXG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcclxuICAgIH1cclxuICAgIHJldFtrZXkkMV0gPSBwYXJlbnRcclxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxyXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xyXG4gIH1cclxuICByZXR1cm4gcmV0XHJcbn07XHJcblxyXG4vKipcclxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cclxuICovXHJcbnN0cmF0cy5wcm9wcyA9XHJcbnN0cmF0cy5tZXRob2RzID1cclxuc3RyYXRzLmluamVjdCA9XHJcbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcclxuICBwYXJlbnRWYWwsXHJcbiAgY2hpbGRWYWwsXHJcbiAgdm0sXHJcbiAga2V5XHJcbikge1xyXG4gIGlmIChjaGlsZFZhbCAmJiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XHJcbiAgfVxyXG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XHJcbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcclxuICBpZiAoY2hpbGRWYWwpIHsgZXh0ZW5kKHJldCwgY2hpbGRWYWwpOyB9XHJcbiAgcmV0dXJuIHJldFxyXG59O1xyXG5zdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBzdHJhdGVneS5cclxuICovXHJcbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xyXG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXHJcbiAgICA/IHBhcmVudFZhbFxyXG4gICAgOiBjaGlsZFZhbFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xyXG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcclxuICBpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xyXG4gICAgd2FybihcclxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcclxuICAgICAgJ2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYW5kIHRoZSBoeXBoZW4sICcgK1xyXG4gICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXHJcbiAgICApO1xyXG4gIH1cclxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcclxuICAgICAgJ2lkOiAnICsgbmFtZVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcclxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xyXG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XHJcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxyXG4gIHZhciByZXMgPSB7fTtcclxuICB2YXIgaSwgdmFsLCBuYW1lO1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xyXG4gICAgaSA9IHByb3BzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgdmFsID0gcHJvcHNbaV07XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xyXG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xyXG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xyXG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXHJcbiAgICAgICAgPyB2YWxcclxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHdhcm4oXHJcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xyXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcclxuICAgICAgdm1cclxuICAgICk7XHJcbiAgfVxyXG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XHJcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xyXG4gIGlmICghaW5qZWN0KSB7IHJldHVybiB9XHJcbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcclxuICAgICAgdmFyIHZhbCA9IGluamVjdFtrZXldO1xyXG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcclxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXHJcbiAgICAgICAgOiB7IGZyb206IHZhbCB9O1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXHJcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcclxuICAgICAgdm1cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcclxuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcclxuICBpZiAoZGlycykge1xyXG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcclxuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcclxuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XHJcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgd2FybihcclxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXHJcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxyXG4gICAgICB2bVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXHJcbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxyXG4gIHBhcmVudCxcclxuICBjaGlsZCxcclxuICB2bVxyXG4pIHtcclxuICB7XHJcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xyXG4gIH1cclxuXHJcbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcclxuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcclxuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcclxuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xyXG4gIGlmIChleHRlbmRzRnJvbSkge1xyXG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcclxuICB9XHJcbiAgaWYgKGNoaWxkLm1peGlucykge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xyXG4gICAgfVxyXG4gIH1cclxuICB2YXIgb3B0aW9ucyA9IHt9O1xyXG4gIHZhciBrZXk7XHJcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XHJcbiAgICBtZXJnZUZpZWxkKGtleSk7XHJcbiAgfVxyXG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XHJcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcclxuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcclxuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcclxuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcclxuICB9XHJcbiAgcmV0dXJuIG9wdGlvbnNcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlc29sdmUgYW4gYXNzZXQuXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xyXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxyXG4gIG9wdGlvbnMsXHJcbiAgdHlwZSxcclxuICBpZCxcclxuICB3YXJuTWlzc2luZ1xyXG4pIHtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xyXG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XHJcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XHJcbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xyXG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxyXG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcclxuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxyXG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxyXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XHJcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcclxuICAgIHdhcm4oXHJcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXHJcbiAgICAgIG9wdGlvbnNcclxuICAgICk7XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxyXG4gIGtleSxcclxuICBwcm9wT3B0aW9ucyxcclxuICBwcm9wc0RhdGEsXHJcbiAgdm1cclxuKSB7XHJcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xyXG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcclxuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcclxuICAvLyBib29sZWFuIGNhc3RpbmdcclxuICB2YXIgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XHJcbiAgaWYgKGJvb2xlYW5JbmRleCA+IC0xKSB7XHJcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xyXG4gICAgICB2YWx1ZSA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XHJcbiAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxyXG4gICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcclxuICAgICAgdmFyIHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcclxuICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xyXG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXHJcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcclxuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcclxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxyXG4gICAgdmFyIHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcclxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcclxuICAgIG9ic2VydmUodmFsdWUpO1xyXG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcclxuICB9XHJcbiAge1xyXG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xyXG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcclxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkXHJcbiAgfVxyXG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XHJcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxyXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXHJcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcclxuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxyXG4gICAgICB2bVxyXG4gICAgKTtcclxuICB9XHJcbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcclxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXHJcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cclxuICB9XHJcbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcclxuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XHJcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXHJcbiAgICA/IGRlZi5jYWxsKHZtKVxyXG4gICAgOiBkZWZcclxufVxyXG5cclxuLyoqXHJcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxyXG4gIHByb3AsXHJcbiAgbmFtZSxcclxuICB2YWx1ZSxcclxuICB2bSxcclxuICBhYnNlbnRcclxuKSB7XHJcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcclxuICAgICAgdm1cclxuICAgICk7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcclxuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xyXG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XHJcbiAgaWYgKHR5cGUpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xyXG4gICAgICB0eXBlID0gW3R5cGVdO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xyXG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XHJcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcclxuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICghdmFsaWQpIHtcclxuICAgIHdhcm4oXHJcbiAgICAgIFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcclxuICAgICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSkgK1xyXG4gICAgICBcIiwgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXHJcbiAgICAgIHZtXHJcbiAgICApO1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcclxuICBpZiAodmFsaWRhdG9yKSB7XHJcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXHJcbiAgICAgICAgdm1cclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcclxuXHJcbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XHJcbiAgdmFyIHZhbGlkO1xyXG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xyXG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xyXG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XHJcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcclxuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XHJcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xyXG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XHJcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHZhbGlkOiB2YWxpZCxcclxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxyXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcclxuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcclxuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xyXG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcclxufVxyXG5cclxuZnVuY3Rpb24gaXNTYW1lVHlwZSAoYSwgYikge1xyXG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xyXG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xyXG4gICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTFcclxuICB9XHJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XHJcbiAgICAgIHJldHVybiBpXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAtMVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XHJcbiAgaWYgKHZtKSB7XHJcbiAgICB2YXIgY3VyID0gdm07XHJcbiAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xyXG4gICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcclxuICAgICAgaWYgKGhvb2tzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XHJcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbylcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcclxuICAgIH1cclxuICB9XHJcbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XHJcbiAge1xyXG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xyXG4gIH1cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IGVyclxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcbi8qIGdsb2JhbHMgTWVzc2FnZUNoYW5uZWwgKi9cclxuXHJcbnZhciBjYWxsYmFja3MgPSBbXTtcclxudmFyIHBlbmRpbmcgPSBmYWxzZTtcclxuXHJcbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcclxuICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29waWVzW2ldKCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIGJvdGggbWljcm90YXNrcyBhbmQgKG1hY3JvKSB0YXNrcy5cclxuLy8gSW4gPCAyLjQgd2UgdXNlZCBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGJ1dCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Mgd2hlcmVcclxuLy8gbWljcm90YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmUgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XHJcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCkgb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lXHJcbi8vIGV2ZW50ICgjNjU2NikuIEhvd2V2ZXIsIHVzaW5nIChtYWNybykgdGFza3MgZXZlcnl3aGVyZSBhbHNvIGhhcyBzdWJ0bGUgcHJvYmxlbXNcclxuLy8gd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50IChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxyXG4vLyBIZXJlIHdlIHVzZSBtaWNyb3Rhc2sgYnkgZGVmYXVsdCwgYnV0IGV4cG9zZSBhIHdheSB0byBmb3JjZSAobWFjcm8pIHRhc2sgd2hlblxyXG4vLyBuZWVkZWQgKGUuZy4gaW4gZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgYnkgdi1vbikuXHJcbnZhciBtaWNyb1RpbWVyRnVuYztcclxudmFyIG1hY3JvVGltZXJGdW5jO1xyXG52YXIgdXNlTWFjcm9UYXNrID0gZmFsc2U7XHJcblxyXG4vLyBEZXRlcm1pbmUgKG1hY3JvKSB0YXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxyXG4vLyBUZWNobmljYWxseSBzZXRJbW1lZGlhdGUgc2hvdWxkIGJlIHRoZSBpZGVhbCBjaG9pY2UsIGJ1dCBpdCdzIG9ubHkgYXZhaWxhYmxlXHJcbi8vIGluIElFLiBUaGUgb25seSBwb2x5ZmlsbCB0aGF0IGNvbnNpc3RlbnRseSBxdWV1ZXMgdGhlIGNhbGxiYWNrIGFmdGVyIGFsbCBET01cclxuLy8gZXZlbnRzIHRyaWdnZXJlZCBpbiB0aGUgc2FtZSBsb29wIGlzIGJ5IHVzaW5nIE1lc3NhZ2VDaGFubmVsLlxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcclxuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XHJcbiAgfTtcclxufSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnICYmIChcclxuICBpc05hdGl2ZShNZXNzYWdlQ2hhbm5lbCkgfHxcclxuICAvLyBQaGFudG9tSlNcclxuICBNZXNzYWdlQ2hhbm5lbC50b1N0cmluZygpID09PSAnW29iamVjdCBNZXNzYWdlQ2hhbm5lbENvbnN0cnVjdG9yXSdcclxuKSkge1xyXG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XHJcbiAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xyXG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2hDYWxsYmFja3M7XHJcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBwb3J0LnBvc3RNZXNzYWdlKDEpO1xyXG4gIH07XHJcbn0gZWxzZSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIERldGVybWluZSBtaWNyb3Rhc2sgZGVmZXIgaW1wbGVtZW50YXRpb24uXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cclxuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xyXG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgbWljcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xyXG4gICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XHJcbiAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcclxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXHJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cclxuICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxyXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cclxuICB9O1xyXG59IGVsc2Uge1xyXG4gIC8vIGZhbGxiYWNrIHRvIG1hY3JvXHJcbiAgbWljcm9UaW1lckZ1bmMgPSBtYWNyb1RpbWVyRnVuYztcclxufVxyXG5cclxuLyoqXHJcbiAqIFdyYXAgYSBmdW5jdGlvbiBzbyB0aGF0IGlmIGFueSBjb2RlIGluc2lkZSB0cmlnZ2VycyBzdGF0ZSBjaGFuZ2UsXHJcbiAqIHRoZSBjaGFuZ2VzIGFyZSBxdWV1ZWQgdXNpbmcgYSAobWFjcm8pIHRhc2sgaW5zdGVhZCBvZiBhIG1pY3JvdGFzay5cclxuICovXHJcbmZ1bmN0aW9uIHdpdGhNYWNyb1Rhc2sgKGZuKSB7XHJcbiAgcmV0dXJuIGZuLl93aXRoVGFzayB8fCAoZm4uX3dpdGhUYXNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdXNlTWFjcm9UYXNrID0gdHJ1ZTtcclxuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgdXNlTWFjcm9UYXNrID0gZmFsc2U7XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcclxuICB2YXIgX3Jlc29sdmU7XHJcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGNiKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY2IuY2FsbChjdHgpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xyXG4gICAgICBfcmVzb2x2ZShjdHgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIGlmICghcGVuZGluZykge1xyXG4gICAgcGVuZGluZyA9IHRydWU7XHJcbiAgICBpZiAodXNlTWFjcm9UYXNrKSB7XHJcbiAgICAgIG1hY3JvVGltZXJGdW5jKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtaWNyb1RpbWVyRnVuYygpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgIH0pXHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBtYXJrO1xyXG52YXIgbWVhc3VyZTtcclxuXHJcbntcclxuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKFxyXG4gICAgcGVyZiAmJlxyXG4gICAgcGVyZi5tYXJrICYmXHJcbiAgICBwZXJmLm1lYXN1cmUgJiZcclxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxyXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXHJcbiAgKSB7XHJcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XHJcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcclxuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xyXG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xyXG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcclxuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xyXG5cclxudmFyIGluaXRQcm94eTtcclxuXHJcbntcclxuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxyXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXHJcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXHJcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xyXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcclxuICApO1xyXG5cclxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcclxuICAgIHdhcm4oXHJcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcclxuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXHJcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXHJcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcclxuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXHJcbiAgICAgIHRhcmdldFxyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICB2YXIgaGFzUHJveHkgPVxyXG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XHJcblxyXG4gIGlmIChoYXNQcm94eSkge1xyXG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xyXG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xyXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcclxuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcclxuICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdmFyIGhhc0hhbmRsZXIgPSB7XHJcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XHJcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcclxuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xyXG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB2YXIgZ2V0SGFuZGxlciA9IHtcclxuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xyXG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xyXG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XHJcbiAgICBpZiAoaGFzUHJveHkpIHtcclxuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXHJcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XHJcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcclxuICAgICAgICA/IGdldEhhbmRsZXJcclxuICAgICAgICA6IGhhc0hhbmRsZXI7XHJcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xyXG5cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXHJcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XHJcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XHJcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xyXG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XHJcbiAgdmFyIGksIGtleXM7XHJcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcclxuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8IE9iamVjdC5pc0Zyb3plbih2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgaWYgKHZhbC5fX29iX18pIHtcclxuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xyXG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIHNlZW4uYWRkKGRlcElkKTtcclxuICB9XHJcbiAgaWYgKGlzQSkge1xyXG4gICAgaSA9IHZhbC5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xyXG4gICAgaSA9IGtleXMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcclxuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XHJcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcclxuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcclxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xyXG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcclxuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiBuYW1lLFxyXG4gICAgb25jZTogb25jZSQkMSxcclxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXHJcbiAgICBwYXNzaXZlOiBwYXNzaXZlXHJcbiAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XHJcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XHJcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XHJcblxyXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xyXG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2xvbmVkW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcclxuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXHJcbiAgICB9XHJcbiAgfVxyXG4gIGludm9rZXIuZm5zID0gZm5zO1xyXG4gIHJldHVybiBpbnZva2VyXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXHJcbiAgb24sXHJcbiAgb2xkT24sXHJcbiAgYWRkLFxyXG4gIHJlbW92ZSQkMSxcclxuICB2bVxyXG4pIHtcclxuICB2YXIgbmFtZSwgZGVmLCBjdXIsIG9sZCwgZXZlbnQ7XHJcbiAgZm9yIChuYW1lIGluIG9uKSB7XHJcbiAgICBkZWYgPSBjdXIgPSBvbltuYW1lXTtcclxuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xyXG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xyXG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxyXG4gICAgICAgIHZtXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xyXG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xyXG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XHJcbiAgICAgIH1cclxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcclxuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcclxuICAgICAgb2xkLmZucyA9IGN1cjtcclxuICAgICAgb25bbmFtZV0gPSBvbGQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xyXG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XHJcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XHJcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcclxuICBpZiAoZGVmIGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XHJcbiAgfVxyXG4gIHZhciBpbnZva2VyO1xyXG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xyXG5cclxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XHJcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXHJcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xyXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xyXG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xyXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcclxuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXHJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xyXG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcclxuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcclxuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxyXG4gIGRhdGEsXHJcbiAgQ3RvcixcclxuICB0YWdcclxuKSB7XHJcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXHJcbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXHJcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cclxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XHJcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgdmFyIHJlcyA9IHt9O1xyXG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XHJcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcclxuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XHJcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcclxuICAgICAge1xyXG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcclxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICB0aXAoXHJcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcclxuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcclxuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXHJcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXHJcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXHJcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcclxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tQcm9wIChcclxuICByZXMsXHJcbiAgaGFzaCxcclxuICBrZXksXHJcbiAgYWx0S2V5LFxyXG4gIHByZXNlcnZlXHJcbikge1xyXG4gIGlmIChpc0RlZihoYXNoKSkge1xyXG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XHJcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xyXG4gICAgICBpZiAoIXByZXNlcnZlKSB7XHJcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xyXG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcclxuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xyXG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XHJcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXHJcbi8vXHJcbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXHJcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcclxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxyXG5cclxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxyXG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXHJcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxyXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcclxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxyXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcclxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gY2hpbGRyZW5cclxufVxyXG5cclxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcclxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXHJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cclxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xyXG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcclxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXHJcbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXHJcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcclxuICAgICAgOiB1bmRlZmluZWRcclxufVxyXG5cclxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xyXG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xyXG4gIHZhciByZXMgPSBbXTtcclxuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xyXG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgYyA9IGNoaWxkcmVuW2ldO1xyXG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XHJcbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcclxuICAgIGxhc3QgPSByZXNbbGFzdEluZGV4XTtcclxuICAgIC8vICBuZXN0ZWRcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XHJcbiAgICAgIGlmIChjLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xyXG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcclxuICAgICAgICBpZiAoaXNUZXh0Tm9kZShjWzBdKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XHJcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XHJcbiAgICAgICAgICBjLnNoaWZ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcclxuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcclxuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXHJcbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxyXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xyXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xyXG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XHJcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcclxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XHJcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xyXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcclxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxyXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXHJcbiAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxyXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XHJcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcy5wdXNoKGMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XHJcbiAgaWYgKFxyXG4gICAgY29tcC5fX2VzTW9kdWxlIHx8XHJcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXHJcbiAgKSB7XHJcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xyXG4gIH1cclxuICByZXR1cm4gaXNPYmplY3QoY29tcClcclxuICAgID8gYmFzZS5leHRlbmQoY29tcClcclxuICAgIDogY29tcFxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcclxuICBmYWN0b3J5LFxyXG4gIGRhdGEsXHJcbiAgY29udGV4dCxcclxuICBjaGlsZHJlbixcclxuICB0YWdcclxuKSB7XHJcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XHJcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xyXG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XHJcbiAgcmV0dXJuIG5vZGVcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcclxuICBmYWN0b3J5LFxyXG4gIGJhc2VDdG9yLFxyXG4gIGNvbnRleHRcclxuKSB7XHJcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcclxuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxyXG4gIH1cclxuXHJcbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XHJcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxyXG4gIH1cclxuXHJcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XHJcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxyXG4gIH1cclxuXHJcbiAgaWYgKGlzRGVmKGZhY3RvcnkuY29udGV4dHMpKSB7XHJcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcclxuICAgIGZhY3RvcnkuY29udGV4dHMucHVzaChjb250ZXh0KTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcclxuICAgIHZhciBzeW5jID0gdHJ1ZTtcclxuXHJcbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29udGV4dHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgY29udGV4dHNbaV0uJGZvcmNlVXBkYXRlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcclxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XHJcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcclxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXHJcbiAgICAgIGlmICghc3luYykge1xyXG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcclxuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXHJcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcclxuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcclxuICAgICAgICBmb3JjZVJlbmRlcigpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xyXG5cclxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXHJcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcclxuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuXHJcbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcclxuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcclxuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XHJcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XHJcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xyXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XHJcbiAgICAgICAgICAgICAgcmVqZWN0KFxyXG4gICAgICAgICAgICAgICAgXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN5bmMgPSBmYWxzZTtcclxuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcclxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcclxuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXHJcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcclxuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3RvcnlcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xyXG4gICAgICAgIHJldHVybiBjXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xyXG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcclxuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcclxuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcclxuICBpZiAobGlzdGVuZXJzKSB7XHJcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgdGFyZ2V0O1xyXG5cclxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UpIHtcclxuICBpZiAob25jZSkge1xyXG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcclxuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxyXG4gIHZtLFxyXG4gIGxpc3RlbmVycyxcclxuICBvbGRMaXN0ZW5lcnNcclxuKSB7XHJcbiAgdGFyZ2V0ID0gdm07XHJcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XHJcbiAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XHJcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xyXG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gICAgdmFyIHZtID0gdGhpcztcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XHJcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXHJcbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxyXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XHJcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2bVxyXG4gIH07XHJcblxyXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XHJcbiAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgZnVuY3Rpb24gb24gKCkge1xyXG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XHJcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgb24uZm4gPSBmbjtcclxuICAgIHZtLiRvbihldmVudCwgb24pO1xyXG4gICAgcmV0dXJuIHZtXHJcbiAgfTtcclxuXHJcbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gICAgdmFyIHZtID0gdGhpcztcclxuICAgIC8vIGFsbFxyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICByZXR1cm4gdm1cclxuICAgIH1cclxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaV0sIGZuKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdm1cclxuICAgIH1cclxuICAgIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XHJcbiAgICBpZiAoIWNicykge1xyXG4gICAgICByZXR1cm4gdm1cclxuICAgIH1cclxuICAgIGlmICghZm4pIHtcclxuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xyXG4gICAgICByZXR1cm4gdm1cclxuICAgIH1cclxuICAgIGlmIChmbikge1xyXG4gICAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgICAgIHZhciBjYjtcclxuICAgICAgdmFyIGkkMSA9IGNicy5sZW5ndGg7XHJcbiAgICAgIHdoaWxlIChpJDEtLSkge1xyXG4gICAgICAgIGNiID0gY2JzW2kkMV07XHJcbiAgICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgICAgIGNicy5zcGxpY2UoaSQxLCAxKTtcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm1cclxuICB9O1xyXG5cclxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAge1xyXG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XHJcbiAgICAgICAgdGlwKFxyXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXHJcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXHJcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcclxuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcclxuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XHJcbiAgICBpZiAoY2JzKSB7XHJcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xyXG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2bVxyXG4gIH07XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXHJcbiAgY2hpbGRyZW4sXHJcbiAgY29udGV4dFxyXG4pIHtcclxuICB2YXIgc2xvdHMgPSB7fTtcclxuICBpZiAoIWNoaWxkcmVuKSB7XHJcbiAgICByZXR1cm4gc2xvdHNcclxuICB9XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xyXG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxyXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcclxuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcclxuICAgIH1cclxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxyXG4gICAgLy8gc2FtZSBjb250ZXh0LlxyXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcclxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxyXG4gICAgKSB7XHJcbiAgICAgIHZhciBuYW1lID0gZGF0YS5zbG90O1xyXG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xyXG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XHJcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxyXG4gIGZvciAodmFyIG5hbWUkMSBpbiBzbG90cykge1xyXG4gICAgaWYgKHNsb3RzW25hbWUkMV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xyXG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHNsb3RzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xyXG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxyXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcclxuICByZXNcclxuKSB7XHJcbiAgcmVzID0gcmVzIHx8IHt9O1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XHJcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xyXG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XHJcblxyXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xyXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XHJcblxyXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XHJcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xyXG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcclxuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcclxuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XHJcbiAgICB9XHJcbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xyXG4gIH1cclxuXHJcbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcclxuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xyXG5cclxuICB2bS4kY2hpbGRyZW4gPSBbXTtcclxuICB2bS4kcmVmcyA9IHt9O1xyXG5cclxuICB2bS5fd2F0Y2hlciA9IG51bGw7XHJcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcclxuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcclxuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XHJcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XHJcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xyXG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XHJcbiAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcclxuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcclxuICAgIH1cclxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XHJcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xyXG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xyXG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcclxuICAgIHZtLl92bm9kZSA9IHZub2RlO1xyXG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXHJcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cclxuICAgIGlmICghcHJldlZub2RlKSB7XHJcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXHJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcclxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXHJcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcclxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXHJcbiAgICAgICk7XHJcbiAgICAgIC8vIG5vIG5lZWQgZm9yIHRoZSByZWYgbm9kZXMgYWZ0ZXIgaW5pdGlhbCBwYXRjaFxyXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxyXG4gICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB1cGRhdGVzXHJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcclxuICAgIH1cclxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xyXG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXHJcbiAgICBpZiAocHJldkVsKSB7XHJcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICh2bS4kZWwpIHtcclxuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcclxuICAgIH1cclxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcclxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XHJcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xyXG4gICAgfVxyXG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxyXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cclxuICB9O1xyXG5cclxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcclxuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcclxuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcclxuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XHJcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcclxuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcclxuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcclxuICAgIH1cclxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXHJcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcclxuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcclxuICAgIH1cclxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XHJcbiAgICB9XHJcbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxyXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXHJcbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XHJcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XHJcbiAgICB9XHJcbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cclxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XHJcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcclxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xyXG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xyXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcclxuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXHJcbiAgICB2bS4kb2ZmKCk7XHJcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcclxuICAgIGlmICh2bS4kZWwpIHtcclxuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxyXG4gICAgaWYgKHZtLiR2bm9kZSkge1xyXG4gICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXHJcbiAgdm0sXHJcbiAgZWwsXHJcbiAgaHlkcmF0aW5nXHJcbikge1xyXG4gIHZtLiRlbCA9IGVsO1xyXG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XHJcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xyXG4gICAge1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcclxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXHJcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcclxuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXHJcbiAgICAgICAgICB2bVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcclxuICAgICAgICAgIHZtXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XHJcblxyXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XHJcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XHJcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XHJcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcclxuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XHJcblxyXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcclxuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xyXG4gICAgICBtYXJrKGVuZFRhZyk7XHJcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcblxyXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcclxuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcclxuICAgICAgbWFyayhlbmRUYWcpO1xyXG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXHJcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcclxuICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXHJcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwgbnVsbCwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xyXG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xyXG5cclxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxyXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXHJcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XHJcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcclxuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xyXG4gIH1cclxuICByZXR1cm4gdm1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxyXG4gIHZtLFxyXG4gIHByb3BzRGF0YSxcclxuICBsaXN0ZW5lcnMsXHJcbiAgcGFyZW50Vm5vZGUsXHJcbiAgcmVuZGVyQ2hpbGRyZW5cclxuKSB7XHJcbiAge1xyXG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxyXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXHJcbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXHJcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXHJcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXHJcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXHJcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXHJcbiAgKTtcclxuXHJcbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XHJcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcclxuXHJcbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxyXG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xyXG4gIH1cclxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcclxuXHJcbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXHJcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXHJcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xyXG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XHJcblxyXG4gIC8vIHVwZGF0ZSBwcm9wc1xyXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcclxuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XHJcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XHJcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcclxuICAgICAgdmFyIHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xyXG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xyXG4gICAgfVxyXG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xyXG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxyXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xyXG4gIH1cclxuXHJcbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xyXG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcclxuICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcclxuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xyXG4gIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xyXG5cclxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxyXG4gIGlmIChoYXNDaGlsZHJlbikge1xyXG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcclxuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAge1xyXG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xyXG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xyXG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZVxyXG59XHJcblxyXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XHJcbiAgaWYgKGRpcmVjdCkge1xyXG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XHJcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xyXG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XHJcbiAgICB9XHJcbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XHJcbiAgaWYgKGRpcmVjdCkge1xyXG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcclxuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcclxuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcclxuICAgIH1cclxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xyXG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcclxuICBwdXNoVGFyZ2V0KCk7XHJcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XHJcbiAgaWYgKGhhbmRsZXJzKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcclxuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcclxuICB9XHJcbiAgcG9wVGFyZ2V0KCk7XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuXHJcbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xyXG5cclxudmFyIHF1ZXVlID0gW107XHJcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xyXG52YXIgaGFzID0ge307XHJcbnZhciBjaXJjdWxhciA9IHt9O1xyXG52YXIgd2FpdGluZyA9IGZhbHNlO1xyXG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcclxudmFyIGluZGV4ID0gMDtcclxuXHJcbi8qKlxyXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcclxuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgaGFzID0ge307XHJcbiAge1xyXG4gICAgY2lyY3VsYXIgPSB7fTtcclxuICB9XHJcbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cclxuICovXHJcbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xyXG4gIGZsdXNoaW5nID0gdHJ1ZTtcclxuICB2YXIgd2F0Y2hlciwgaWQ7XHJcblxyXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxyXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxyXG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcclxuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXHJcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxyXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcclxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxyXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cclxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XHJcblxyXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxyXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xyXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcclxuICAgIGlkID0gd2F0Y2hlci5pZDtcclxuICAgIGhhc1tpZF0gPSBudWxsO1xyXG4gICAgd2F0Y2hlci5ydW4oKTtcclxuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cclxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcclxuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XHJcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcclxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXHJcbiAgICAgICAgICAgICAgPyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxyXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcclxuICAgICAgICAgICksXHJcbiAgICAgICAgICB3YXRjaGVyLnZtXHJcbiAgICAgICAgKTtcclxuICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXHJcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcclxuICB2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcclxuXHJcbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xyXG5cclxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcclxuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xyXG4gIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcclxuXHJcbiAgLy8gZGV2dG9vbCBob29rXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xyXG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MgKHF1ZXVlKSB7XHJcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcclxuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XHJcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xyXG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXHJcbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xyXG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cclxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxyXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xyXG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcclxuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cclxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXHJcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XHJcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcclxuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XHJcbiAgICBoYXNbaWRdID0gdHJ1ZTtcclxuICAgIGlmICghZmx1c2hpbmcpIHtcclxuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcclxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cclxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xyXG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xyXG4gICAgICAgIGktLTtcclxuICAgICAgfVxyXG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xyXG4gICAgfVxyXG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXHJcbiAgICBpZiAoIXdhaXRpbmcpIHtcclxuICAgICAgd2FpdGluZyA9IHRydWU7XHJcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgdWlkJDEgPSAwO1xyXG5cclxuLyoqXHJcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxyXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cclxuICovXHJcbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXHJcbiAgdm0sXHJcbiAgZXhwT3JGbixcclxuICBjYixcclxuICBvcHRpb25zLFxyXG4gIGlzUmVuZGVyV2F0Y2hlclxyXG4pIHtcclxuICB0aGlzLnZtID0gdm07XHJcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xyXG4gICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xyXG4gIH1cclxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcclxuICAvLyBvcHRpb25zXHJcbiAgaWYgKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xyXG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XHJcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcclxuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcclxuICB9XHJcbiAgdGhpcy5jYiA9IGNiO1xyXG4gIHRoaXMuaWQgPSArK3VpZCQxOyAvLyB1aWQgZm9yIGJhdGNoaW5nXHJcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXHJcbiAgdGhpcy5kZXBzID0gW107XHJcbiAgdGhpcy5uZXdEZXBzID0gW107XHJcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xyXG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcclxuICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCk7XHJcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXHJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xyXG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xyXG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xyXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXHJcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcclxuICAgICAgICB2bVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XHJcbiAgICA/IHVuZGVmaW5lZFxyXG4gICAgOiB0aGlzLmdldCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cclxuICovXHJcbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XHJcbiAgcHVzaFRhcmdldCh0aGlzKTtcclxuICB2YXIgdmFsdWU7XHJcbiAgdmFyIHZtID0gdGhpcy52bTtcclxuICB0cnkge1xyXG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgaWYgKHRoaXMudXNlcikge1xyXG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IGVcclxuICAgIH1cclxuICB9IGZpbmFsbHkge1xyXG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXHJcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcclxuICAgIGlmICh0aGlzLmRlZXApIHtcclxuICAgICAgdHJhdmVyc2UodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcG9wVGFyZ2V0KCk7XHJcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXHJcbiAqL1xyXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xyXG4gIHZhciBpZCA9IGRlcC5pZDtcclxuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcclxuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XHJcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xyXG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XHJcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXHJcbiAqL1xyXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xyXG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XHJcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcclxuICAgIH1cclxuICB9XHJcbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xyXG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XHJcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XHJcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcclxuICB0bXAgPSB0aGlzLmRlcHM7XHJcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xyXG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcclxuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cclxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cclxuICovXHJcbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICBpZiAodGhpcy5sYXp5KSB7XHJcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xyXG4gICAgdGhpcy5ydW4oKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cclxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cclxuICovXHJcbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XHJcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xyXG4gICAgaWYgKFxyXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxyXG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cclxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxyXG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXHJcbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxyXG4gICAgICB0aGlzLmRlZXBcclxuICAgICkge1xyXG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXHJcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgaWYgKHRoaXMudXNlcikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cclxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxyXG4gKi9cclxuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XHJcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XHJcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxyXG4gKi9cclxuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxyXG4gKi9cclxuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XHJcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XHJcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxyXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XHJcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XHJcbiAgICB9XHJcbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgZ2V0OiBub29wLFxyXG4gIHNldDogbm9vcFxyXG59O1xyXG5cclxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcclxuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xyXG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXHJcbiAgfTtcclxuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xyXG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XHJcbiAgfTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcclxuICB2bS5fd2F0Y2hlcnMgPSBbXTtcclxuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xyXG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cclxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XHJcbiAgaWYgKG9wdHMuZGF0YSkge1xyXG4gICAgaW5pdERhdGEodm0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XHJcbiAgfVxyXG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cclxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xyXG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xyXG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XHJcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XHJcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcclxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cclxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xyXG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcclxuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcclxuICBpZiAoIWlzUm9vdCkge1xyXG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcclxuICB9XHJcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcclxuICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICB7XHJcbiAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XHJcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XHJcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxyXG4gICAgICAgICAgdm1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xyXG4gICAgICAgICAgd2FybihcclxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xyXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcclxuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xyXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxyXG4gICAgICAgICAgICB2bVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxyXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcclxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cclxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcclxuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XHJcbiAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcclxuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XHJcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcclxuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcclxuICAgIDogZGF0YSB8fCB7fTtcclxuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcclxuICAgIGRhdGEgPSB7fTtcclxuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcclxuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXHJcbiAgICAgIHZtXHJcbiAgICApO1xyXG4gIH1cclxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXHJcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcclxuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcclxuICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XHJcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgIHtcclxuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcclxuICAgICAgICAgIHZtXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xyXG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXHJcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXHJcbiAgICAgICAgdm1cclxuICAgICAgKTtcclxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xyXG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBvYnNlcnZlIGRhdGFcclxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XHJcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xyXG4gIHB1c2hUYXJnZXQoKTtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xyXG4gICAgcmV0dXJuIHt9XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIHBvcFRhcmdldCgpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcclxuXHJcbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XHJcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXHJcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcclxuXHJcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XHJcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XHJcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XHJcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcclxuICAgICAgICB2bVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNTU1IpIHtcclxuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cclxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxyXG4gICAgICAgIHZtLFxyXG4gICAgICAgIGdldHRlciB8fCBub29wLFxyXG4gICAgICAgIG5vb3AsXHJcbiAgICAgICAgY29tcHV0ZWRXYXRjaGVyT3B0aW9uc1xyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcclxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXHJcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXHJcbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XHJcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xyXG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcclxuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcclxuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxyXG4gIHRhcmdldCxcclxuICBrZXksXHJcbiAgdXNlckRlZlxyXG4pIHtcclxuICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcclxuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxyXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcclxuICAgICAgOiB1c2VyRGVmO1xyXG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxyXG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXHJcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXHJcbiAgICAgICAgOiB1c2VyRGVmLmdldFxyXG4gICAgICA6IG5vb3A7XHJcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcclxuICAgICAgPyB1c2VyRGVmLnNldFxyXG4gICAgICA6IG5vb3A7XHJcbiAgfVxyXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XHJcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxyXG4gICAgICAgIHRoaXNcclxuICAgICAgKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xyXG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XHJcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xyXG4gICAgaWYgKHdhdGNoZXIpIHtcclxuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcclxuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcclxuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcclxuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcclxuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xyXG4gICAge1xyXG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXHJcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXHJcbiAgICAgICAgICB2bVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxyXG4gICAgICAgICAgdm1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiICtcclxuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcclxuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcclxuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcclxuICB2bSxcclxuICBleHBPckZuLFxyXG4gIGhhbmRsZXIsXHJcbiAgb3B0aW9uc1xyXG4pIHtcclxuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xyXG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XHJcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XHJcbiAgfVxyXG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcclxufVxyXG5cclxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XHJcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XHJcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXHJcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxyXG4gIHZhciBkYXRhRGVmID0ge307XHJcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XHJcbiAgdmFyIHByb3BzRGVmID0ge307XHJcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcclxuICB7XHJcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcclxuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxyXG4gICAgICAgIHRoaXNcclxuICAgICAgKTtcclxuICAgIH07XHJcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xyXG5cclxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XHJcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xyXG5cclxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcclxuICAgIGV4cE9yRm4sXHJcbiAgICBjYixcclxuICAgIG9wdGlvbnNcclxuICApIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcclxuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxyXG4gICAgfVxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xyXG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xyXG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XHJcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XHJcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xyXG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcclxuICBpZiAocHJvdmlkZSkge1xyXG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcclxuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXHJcbiAgICAgIDogcHJvdmlkZTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xyXG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xyXG4gIGlmIChyZXN1bHQpIHtcclxuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XHJcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgICB7XHJcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXHJcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXHJcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxyXG4gICAgICAgICAgICB2bVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XHJcbiAgaWYgKGluamVjdCkge1xyXG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcclxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcclxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5qZWN0LCBrZXkpLmVudW1lcmFibGVcclxuICAgICAgfSlcclxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xyXG4gICAgICB2YXIgc291cmNlID0gdm07XHJcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcclxuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBoYXNPd24oc291cmNlLl9wcm92aWRlZCwgcHJvdmlkZUtleSkpIHtcclxuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghc291cmNlKSB7XHJcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xyXG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcclxuICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZW9mIHByb3ZpZGVEZWZhdWx0ID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcclxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cclxuICovXHJcbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxyXG4gIHZhbCxcclxuICByZW5kZXJcclxuKSB7XHJcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcclxuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcclxuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XHJcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XHJcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcclxuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XHJcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoaXNEZWYocmV0KSkge1xyXG4gICAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4gcmV0XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJTbG90IChcclxuICBuYW1lLFxyXG4gIGZhbGxiYWNrLFxyXG4gIHByb3BzLFxyXG4gIGJpbmRPYmplY3RcclxuKSB7XHJcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xyXG4gIHZhciBub2RlcztcclxuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XHJcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xyXG4gICAgaWYgKGJpbmRPYmplY3QpIHtcclxuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc09iamVjdChiaW5kT2JqZWN0KSkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXHJcbiAgICAgICAgICB0aGlzXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XHJcbiAgICB9XHJcbiAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcclxuICAgIC8vIHdhcm4gZHVwbGljYXRlIHNsb3QgdXNhZ2VcclxuICAgIGlmIChzbG90Tm9kZXMpIHtcclxuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3ROb2Rlcy5fcmVuZGVyZWQpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgXCJEdXBsaWNhdGUgcHJlc2VuY2Ugb2Ygc2xvdCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGZvdW5kIGluIHRoZSBzYW1lIHJlbmRlciB0cmVlIFwiICtcclxuICAgICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXHJcbiAgICAgICAgICB0aGlzXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIG5vZGVzID0gc2xvdE5vZGVzIHx8IGZhbGxiYWNrO1xyXG4gIH1cclxuXHJcbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XHJcbiAgaWYgKHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywgeyBzbG90OiB0YXJnZXQgfSwgbm9kZXMpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBub2Rlc1xyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xyXG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdCkpIHtcclxuICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZXhwZWN0ICE9PSBhY3R1YWxcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXHJcbiAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xyXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcclxuICovXHJcbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxyXG4gIGV2ZW50S2V5Q29kZSxcclxuICBrZXksXHJcbiAgYnVpbHRJbktleUNvZGUsXHJcbiAgZXZlbnRLZXlOYW1lLFxyXG4gIGJ1aWx0SW5LZXlOYW1lXHJcbikge1xyXG4gIHZhciBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XHJcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcclxuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKGJ1aWx0SW5LZXlOYW1lLCBldmVudEtleU5hbWUpXHJcbiAgfSBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XHJcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXHJcbiAgfSBlbHNlIGlmIChldmVudEtleU5hbWUpIHtcclxuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxyXG4gKi9cclxuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcclxuICBkYXRhLFxyXG4gIHRhZyxcclxuICB2YWx1ZSxcclxuICBhc1Byb3AsXHJcbiAgaXNTeW5jXHJcbikge1xyXG4gIGlmICh2YWx1ZSkge1xyXG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxyXG4gICAgICAgIHRoaXNcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBoYXNoO1xyXG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxyXG4gICAgICAgICAga2V5ID09PSAnc3R5bGUnIHx8XHJcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGhhc2ggPSBkYXRhO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xyXG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXHJcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxyXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xyXG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcclxuXHJcbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XHJcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XHJcbiAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xyXG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGRhdGFcclxufVxyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxyXG4gIGluZGV4LFxyXG4gIGlzSW5Gb3JcclxuKSB7XHJcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcclxuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XHJcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXHJcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXHJcbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcclxuICAgIHJldHVybiB0cmVlXHJcbiAgfVxyXG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cclxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxyXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXHJcbiAgICBudWxsLFxyXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xyXG4gICk7XHJcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcclxuICByZXR1cm4gdHJlZVxyXG59XHJcblxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cclxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXJrT25jZSAoXHJcbiAgdHJlZSxcclxuICBpbmRleCxcclxuICBrZXlcclxuKSB7XHJcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XHJcbiAgcmV0dXJuIHRyZWVcclxufVxyXG5cclxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXHJcbiAgdHJlZSxcclxuICBrZXksXHJcbiAgaXNPbmNlXHJcbikge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XHJcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XHJcbiAgbm9kZS5rZXkgPSBrZXk7XHJcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcclxuICBpZiAodmFsdWUpIHtcclxuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcclxuICAgICAgICB0aGlzXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcclxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcclxuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XHJcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGRhdGFcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XHJcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XHJcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XHJcbiAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XHJcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcclxuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xyXG4gIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XHJcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xyXG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcclxuICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xyXG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XHJcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xyXG4gIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcclxuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xyXG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcclxuICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcclxuICBkYXRhLFxyXG4gIHByb3BzLFxyXG4gIGNoaWxkcmVuLFxyXG4gIHBhcmVudCxcclxuICBDdG9yXHJcbikge1xyXG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xyXG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcclxuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXHJcbiAgdmFyIGNvbnRleHRWbTtcclxuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xyXG4gICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xyXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cclxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxyXG4gICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxyXG4gICAgY29udGV4dFZtID0gcGFyZW50O1xyXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xyXG4gIH1cclxuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XHJcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XHJcblxyXG4gIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xyXG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XHJcbiAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcclxuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpOyB9O1xyXG5cclxuICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXHJcbiAgaWYgKGlzQ29tcGlsZWQpIHtcclxuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxyXG4gICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXHJcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcclxuICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gZGF0YS5zY29wZWRTbG90cyB8fCBlbXB0eU9iamVjdDtcclxuICB9XHJcblxyXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XHJcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcclxuICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xyXG4gICAgICAgIHZub2RlLmZuU2NvcGVJZCA9IG9wdGlvbnMuX3Njb3BlSWQ7XHJcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2bm9kZVxyXG4gICAgfTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pOyB9O1xyXG4gIH1cclxufVxyXG5cclxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxyXG4gIEN0b3IsXHJcbiAgcHJvcHNEYXRhLFxyXG4gIGRhdGEsXHJcbiAgY29udGV4dFZtLFxyXG4gIGNoaWxkcmVuXHJcbikge1xyXG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xyXG4gIHZhciBwcm9wcyA9IHt9O1xyXG4gIHZhciBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XHJcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XHJcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XHJcbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cclxuICB9XHJcblxyXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxyXG4gICAgZGF0YSxcclxuICAgIHByb3BzLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICBjb250ZXh0Vm0sXHJcbiAgICBDdG9yXHJcbiAgKTtcclxuXHJcbiAgdmFyIHZub2RlID0gb3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCByZW5kZXJDb250ZXh0Ll9jLCByZW5kZXJDb250ZXh0KTtcclxuXHJcbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgIHJldHVybiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucylcclxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XHJcbiAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xyXG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zKSB7XHJcbiAgLy8gIzc4MTcgY2xvbmUgbm9kZSBiZWZvcmUgc2V0dGluZyBmbkNvbnRleHQsIG90aGVyd2lzZSBpZiB0aGUgbm9kZSBpcyByZXVzZWRcclxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcclxuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cclxuICB2YXIgY2xvbmUgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XHJcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcclxuICBpZiAoZGF0YS5zbG90KSB7XHJcbiAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcclxuICB9XHJcbiAgcmV0dXJuIGNsb25lXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcclxuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5cclxuXHJcblxyXG4vLyBSZWdpc3RlciB0aGUgY29tcG9uZW50IGhvb2sgdG8gd2VleCBuYXRpdmUgcmVuZGVyIGVuZ2luZS5cclxuLy8gVGhlIGhvb2sgd2lsbCBiZSB0cmlnZ2VyZWQgYnkgbmF0aXZlLCBub3QgamF2YXNjcmlwdC5cclxuXHJcblxyXG4vLyBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50IHRvIHdlZXggbmF0aXZlIHJlbmRlciBlbmdpbmUuXHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYW5rczEwMTAwL3dlZXgtbmF0aXZlLWRpcmVjdGl2ZS90cmVlL21hc3Rlci9jb21wb25lbnRcclxuXHJcbi8vIGxpc3RlbmluZyBvbiBuYXRpdmUgY2FsbGJhY2tcclxuXHJcbi8qICAqL1xyXG5cclxuLyogICovXHJcblxyXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxyXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcclxuICBpbml0OiBmdW5jdGlvbiBpbml0IChcclxuICAgIHZub2RlLFxyXG4gICAgaHlkcmF0aW5nLFxyXG4gICAgcGFyZW50RWxtLFxyXG4gICAgcmVmRWxtXHJcbiAgKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXHJcbiAgICAgICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQgJiZcclxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcclxuICAgICkge1xyXG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcclxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcclxuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxyXG4gICAgICAgIHZub2RlLFxyXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxyXG4gICAgICAgIHBhcmVudEVsbSxcclxuICAgICAgICByZWZFbG1cclxuICAgICAgKTtcclxuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xyXG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcclxuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxyXG4gICAgICBjaGlsZCxcclxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcclxuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXHJcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXHJcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXHJcbiAgICApO1xyXG4gIH0sXHJcblxyXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xyXG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xyXG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XHJcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcclxuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XHJcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcclxuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcclxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XHJcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXHJcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxyXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cclxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcclxuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcclxuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xyXG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxyXG4gIEN0b3IsXHJcbiAgZGF0YSxcclxuICBjb250ZXh0LFxyXG4gIGNoaWxkcmVuLFxyXG4gIHRhZ1xyXG4pIHtcclxuICBpZiAoaXNVbmRlZihDdG9yKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xyXG5cclxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcclxuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XHJcbiAgfVxyXG5cclxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXHJcbiAgLy8gcmVqZWN0LlxyXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAge1xyXG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgLy8gYXN5bmMgY29tcG9uZW50XHJcbiAgdmFyIGFzeW5jRmFjdG9yeTtcclxuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcclxuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XHJcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IsIGNvbnRleHQpO1xyXG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXHJcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxyXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXHJcbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxyXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcclxuICAgICAgICBkYXRhLFxyXG4gICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgdGFnXHJcbiAgICAgIClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xyXG5cclxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXHJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXHJcbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcclxuXHJcbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xyXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xyXG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcclxuICB9XHJcblxyXG4gIC8vIGV4dHJhY3QgcHJvcHNcclxuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xyXG5cclxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxyXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxyXG4gIH1cclxuXHJcbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcclxuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xyXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xyXG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXHJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXHJcbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XHJcblxyXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xyXG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xyXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcclxuXHJcbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XHJcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcclxuICAgIGRhdGEgPSB7fTtcclxuICAgIGlmIChzbG90KSB7XHJcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcclxuICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XHJcblxyXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXHJcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XHJcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxyXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcclxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXHJcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9LFxyXG4gICAgYXN5bmNGYWN0b3J5XHJcbiAgKTtcclxuXHJcbiAgLy8gV2VleCBzcGVjaWZpYzogaW52b2tlIHJlY3ljbGUtbGlzdCBvcHRpbWl6ZWQgQHJlbmRlciBmdW5jdGlvbiBmb3JcclxuICAvLyBleHRyYWN0aW5nIGNlbGwtc2xvdCB0ZW1wbGF0ZS5cclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vSGFua3MxMDEwMC93ZWV4LW5hdGl2ZS1kaXJlY3RpdmUvdHJlZS9tYXN0ZXIvY29tcG9uZW50XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgcmV0dXJuIHZub2RlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxyXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcclxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxyXG4gIHBhcmVudEVsbSxcclxuICByZWZFbG1cclxuKSB7XHJcbiAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXHJcbiAgICBwYXJlbnQ6IHBhcmVudCxcclxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXHJcbiAgICBfcGFyZW50RWxtOiBwYXJlbnRFbG0gfHwgbnVsbCxcclxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXHJcbiAgfTtcclxuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xyXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XHJcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xyXG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XHJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcclxuICB9XHJcbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcclxufVxyXG5cclxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XHJcbiAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XHJcbiAgICBob29rc1trZXldID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xyXG4gIH1cclxufVxyXG5cclxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xyXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cclxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcclxuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcclxuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XHJcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcclxuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xyXG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XHJcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcclxuXHJcbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXHJcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xyXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcclxuICBjb250ZXh0LFxyXG4gIHRhZyxcclxuICBkYXRhLFxyXG4gIGNoaWxkcmVuLFxyXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxyXG4gIGFsd2F5c05vcm1hbGl6ZVxyXG4pIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xyXG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcclxuICAgIGNoaWxkcmVuID0gZGF0YTtcclxuICAgIGRhdGEgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xyXG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xyXG4gIH1cclxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcclxuICBjb250ZXh0LFxyXG4gIHRhZyxcclxuICBkYXRhLFxyXG4gIGNoaWxkcmVuLFxyXG4gIG5vcm1hbGl6YXRpb25UeXBlXHJcbikge1xyXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xyXG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcclxuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXHJcbiAgICAgIGNvbnRleHRcclxuICAgICk7XHJcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXHJcbiAgfVxyXG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXHJcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XHJcbiAgICB0YWcgPSBkYXRhLmlzO1xyXG4gIH1cclxuICBpZiAoIXRhZykge1xyXG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxyXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxyXG4gIH1cclxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcclxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXHJcbiAgKSB7XHJcbiAgICB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcclxuICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxyXG4gICAgICAgIGNvbnRleHRcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxyXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxyXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXHJcbiAgKSB7XHJcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcclxuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XHJcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gIH1cclxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcclxuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xyXG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcclxuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xyXG4gIH1cclxuICB2YXIgdm5vZGUsIG5zO1xyXG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xyXG4gICAgdmFyIEN0b3I7XHJcbiAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xyXG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcclxuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcclxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXHJcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxyXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xyXG4gICAgICAvLyBjb21wb25lbnRcclxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcclxuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcclxuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cclxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXHJcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcclxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxyXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XHJcbiAgfVxyXG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xyXG4gICAgcmV0dXJuIHZub2RlXHJcbiAgfSBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcclxuICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XHJcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHsgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7IH1cclxuICAgIHJldHVybiB2bm9kZVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMsIGZvcmNlKSB7XHJcbiAgdm5vZGUubnMgPSBucztcclxuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcclxuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxyXG4gICAgbnMgPSB1bmRlZmluZWQ7XHJcbiAgICBmb3JjZSA9IHRydWU7XHJcbiAgfVxyXG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXHJcbiAgICAgICAgaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XHJcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gcmVmICM1MzE4XHJcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXHJcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XHJcbiAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XHJcbiAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcclxuICB9XHJcbiAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XHJcbiAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcclxuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxyXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcclxuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xyXG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxyXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcclxuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xyXG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xyXG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxyXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXHJcbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxyXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXHJcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xyXG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxyXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxyXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xyXG5cclxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxyXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcclxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XHJcblxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAge1xyXG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XHJcbiAgICB9LCB0cnVlKTtcclxuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XHJcbiAgICB9LCB0cnVlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcclxuICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xyXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xyXG5cclxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxyXG4gIH07XHJcblxyXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XHJcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcclxuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xyXG5cclxuICAgIC8vIHJlc2V0IF9yZW5kZXJlZCBmbGFnIG9uIHNsb3RzIGZvciBkdXBsaWNhdGUgc2xvdCBjaGVja1xyXG4gICAge1xyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XHJcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICAgICAgdm0uJHNsb3RzW2tleV0uX3JlbmRlcmVkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoX3BhcmVudFZub2RlKSB7XHJcbiAgICAgIHZtLiRzY29wZWRTbG90cyA9IF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IGVtcHR5T2JqZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcclxuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxyXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xyXG4gICAgLy8gcmVuZGVyIHNlbGZcclxuICAgIHZhciB2bm9kZTtcclxuICAgIHRyeSB7XHJcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlclwiKTtcclxuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXHJcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgIHtcclxuICAgICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyRXJyb3JcIik7XHJcbiAgICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcclxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XHJcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xyXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXHJcbiAgICAgICAgICB2bVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XHJcbiAgICB9XHJcbiAgICAvLyBzZXQgcGFyZW50XHJcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XHJcbiAgICByZXR1cm4gdm5vZGVcclxuICB9O1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciB1aWQkMyA9IDA7XHJcblxyXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xyXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIHZtID0gdGhpcztcclxuICAgIC8vIGEgdWlkXHJcbiAgICB2bS5fdWlkID0gdWlkJDMrKztcclxuXHJcbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XHJcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcclxuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XHJcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXHJcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xyXG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xyXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcclxuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cclxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxyXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cclxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxyXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxyXG4gICAgICAgIG9wdGlvbnMgfHwge30sXHJcbiAgICAgICAgdm1cclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICB7XHJcbiAgICAgIGluaXRQcm94eSh2bSk7XHJcbiAgICB9XHJcbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXHJcbiAgICB2bS5fc2VsZiA9IHZtO1xyXG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XHJcbiAgICBpbml0RXZlbnRzKHZtKTtcclxuICAgIGluaXRSZW5kZXIodm0pO1xyXG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcclxuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXHJcbiAgICBpbml0U3RhdGUodm0pO1xyXG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xyXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcclxuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XHJcbiAgICAgIG1hcmsoZW5kVGFnKTtcclxuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XHJcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xyXG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xyXG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXHJcbiAgdmFyIHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XHJcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcclxuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xyXG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcclxuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XHJcblxyXG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xyXG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcclxuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xyXG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xyXG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XHJcblxyXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xyXG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcclxuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XHJcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XHJcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcclxuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xyXG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xyXG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XHJcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxyXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXHJcbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xyXG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXHJcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xyXG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xyXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XHJcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcclxuICAgICAgfVxyXG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcclxuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xyXG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gb3B0aW9uc1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XHJcbiAgdmFyIG1vZGlmaWVkO1xyXG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XHJcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xyXG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XHJcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xyXG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xyXG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cclxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbW9kaWZpZWRcclxufVxyXG5cclxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcclxuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxyXG4gIC8vIGJldHdlZW4gbWVyZ2VzXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XHJcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcclxuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XHJcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbGF0ZXN0XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBWdWUgKG9wdGlvbnMpIHtcclxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcclxuICApIHtcclxuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcclxuICB9XHJcbiAgdGhpcy5faW5pdChvcHRpb25zKTtcclxufVxyXG5cclxuaW5pdE1peGluKFZ1ZSk7XHJcbnN0YXRlTWl4aW4oVnVlKTtcclxuZXZlbnRzTWl4aW4oVnVlKTtcclxubGlmZWN5Y2xlTWl4aW4oVnVlKTtcclxucmVuZGVyTWl4aW4oVnVlKTtcclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XHJcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcclxuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xyXG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcclxuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xyXG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xyXG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9O1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcclxuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcclxuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcclxuICAvKipcclxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcclxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXHJcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXHJcbiAgICovXHJcbiAgVnVlLmNpZCA9IDA7XHJcbiAgdmFyIGNpZCA9IDE7XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXHJcbiAgICovXHJcbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XHJcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcclxuICAgIHZhciBTdXBlciA9IHRoaXM7XHJcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcclxuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XHJcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcclxuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xyXG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcclxuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcclxuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xyXG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcclxuICAgIFN1Yi5jaWQgPSBjaWQrKztcclxuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxyXG4gICAgICBTdXBlci5vcHRpb25zLFxyXG4gICAgICBleHRlbmRPcHRpb25zXHJcbiAgICApO1xyXG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XHJcblxyXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cclxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXHJcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXHJcbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcclxuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcclxuICAgIH1cclxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xyXG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxyXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcclxuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xyXG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcclxuXHJcbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXHJcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXHJcbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xyXG4gICAgfSk7XHJcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXHJcbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxyXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxyXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XHJcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XHJcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xyXG5cclxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXHJcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcclxuICAgIHJldHVybiBTdWJcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xyXG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcclxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcclxuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcclxuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XHJcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XHJcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXHJcbiAgICovXHJcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxyXG4gICAgICBpZCxcclxuICAgICAgZGVmaW5pdGlvblxyXG4gICAgKSB7XHJcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGUgPT09ICdjb21wb25lbnQnKSB7XHJcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xyXG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xyXG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xyXG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xyXG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcclxuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxyXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcclxuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcclxuICB9XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICByZXR1cm4gZmFsc2VcclxufVxyXG5cclxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xyXG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xyXG4gIHZhciBrZXlzID0ga2VlcEFsaXZlSW5zdGFuY2Uua2V5cztcclxuICB2YXIgX3Zub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuX3Zub2RlO1xyXG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xyXG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xyXG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcclxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XHJcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcclxuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcclxuICBjYWNoZSxcclxuICBrZXksXHJcbiAga2V5cyxcclxuICBjdXJyZW50XHJcbikge1xyXG4gIHZhciBjYWNoZWQkJDEgPSBjYWNoZVtrZXldO1xyXG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xyXG4gICAgY2FjaGVkJCQxLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XHJcbiAgfVxyXG4gIGNhY2hlW2tleV0gPSBudWxsO1xyXG4gIHJlbW92ZShrZXlzLCBrZXkpO1xyXG59XHJcblxyXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XHJcblxyXG52YXIgS2VlcEFsaXZlID0ge1xyXG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcclxuICBhYnN0cmFjdDogdHJ1ZSxcclxuXHJcbiAgcHJvcHM6IHtcclxuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcclxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcclxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xyXG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB0aGlzLmtleXMgPSBbXTtcclxuICB9LFxyXG5cclxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XHJcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGUsIGtleSwgdGhpcyQxLmtleXMpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XHJcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XHJcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xyXG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xyXG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcclxuICAgICAgLy8gY2hlY2sgcGF0dGVyblxyXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XHJcbiAgICAgIHZhciByZWYgPSB0aGlzO1xyXG4gICAgICB2YXIgaW5jbHVkZSA9IHJlZi5pbmNsdWRlO1xyXG4gICAgICB2YXIgZXhjbHVkZSA9IHJlZi5leGNsdWRlO1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXHJcbiAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcclxuICAgICAgICAvLyBleGNsdWRlZFxyXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XHJcbiAgICAgIHZhciBjYWNoZSA9IHJlZiQxLmNhY2hlO1xyXG4gICAgICB2YXIga2V5cyA9IHJlZiQxLmtleXM7XHJcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxyXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXHJcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxyXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxyXG4gICAgICAgIDogdm5vZGUua2V5O1xyXG4gICAgICBpZiAoY2FjaGVba2V5XSkge1xyXG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcclxuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XHJcbiAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XHJcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2FjaGVba2V5XSA9IHZub2RlO1xyXG4gICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxyXG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xyXG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcclxuICB9XHJcbn1cclxuXHJcbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcclxuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xyXG4gIC8vIGNvbmZpZ1xyXG4gIHZhciBjb25maWdEZWYgPSB7fTtcclxuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xyXG4gIHtcclxuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xyXG4gICAgICApO1xyXG4gICAgfTtcclxuICB9XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XHJcblxyXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxyXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxyXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXHJcbiAgVnVlLnV0aWwgPSB7XHJcbiAgICB3YXJuOiB3YXJuLFxyXG4gICAgZXh0ZW5kOiBleHRlbmQsXHJcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcclxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZVxyXG4gIH07XHJcblxyXG4gIFZ1ZS5zZXQgPSBzZXQ7XHJcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcclxuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcclxuXHJcbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICB9KTtcclxuXHJcbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxyXG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxyXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xyXG5cclxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xyXG5cclxuICBpbml0VXNlKFZ1ZSk7XHJcbiAgaW5pdE1peGluJDEoVnVlKTtcclxuICBpbml0RXh0ZW5kKFZ1ZSk7XHJcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XHJcbn1cclxuXHJcbmluaXRHbG9iYWxBUEkoVnVlKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xyXG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xyXG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxyXG4gIH1cclxufSk7XHJcblxyXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xyXG4gIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxyXG59KTtcclxuXHJcblZ1ZS52ZXJzaW9uID0gJzIuNS4xNic7XHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxyXG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cclxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcclxuXHJcbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcclxudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xyXG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XHJcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxyXG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XHJcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXHJcbiAgKVxyXG59O1xyXG5cclxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcclxuXHJcbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcclxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcclxuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xyXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xyXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xyXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xyXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xyXG4pO1xyXG5cclxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XHJcblxyXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xyXG59O1xyXG5cclxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXHJcbn07XHJcblxyXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxyXG59O1xyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xyXG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xyXG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcclxuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xyXG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcclxuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcclxuICAgIH1cclxuICB9XHJcbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcclxuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xyXG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXHJcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXHJcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXHJcbiAgICAgIDogcGFyZW50LmNsYXNzXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXHJcbiAgc3RhdGljQ2xhc3MsXHJcbiAgZHluYW1pY0NsYXNzXHJcbikge1xyXG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xyXG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcclxuICB9XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICByZXR1cm4gJydcclxufVxyXG5cclxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XHJcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXHJcbiAgfVxyXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gdmFsdWVcclxuICB9XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICByZXR1cm4gJydcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XHJcbiAgdmFyIHJlcyA9ICcnO1xyXG4gIHZhciBzdHJpbmdpZmllZDtcclxuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcclxuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XHJcbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XHJcbiAgdmFyIHJlcyA9ICcnO1xyXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlW2tleV0pIHtcclxuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XHJcbiAgICAgIHJlcyArPSBrZXk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgbmFtZXNwYWNlTWFwID0ge1xyXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcclxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcclxufTtcclxuXHJcbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxyXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcclxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xyXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcclxuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xyXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcclxuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXHJcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xyXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xyXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xyXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXHJcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXHJcbik7XHJcblxyXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcclxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cclxudmFyIGlzU1ZHID0gbWFrZU1hcChcclxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xyXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcclxuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXHJcbiAgdHJ1ZVxyXG4pO1xyXG5cclxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcclxuXHJcbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xyXG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xyXG4gIGlmIChpc1NWRyh0YWcpKSB7XHJcbiAgICByZXR1cm4gJ3N2ZydcclxuICB9XHJcbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXHJcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xyXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xyXG4gICAgcmV0dXJuICdtYXRoJ1xyXG4gIH1cclxufVxyXG5cclxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoIWluQnJvd3Nlcikge1xyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxyXG4gIH1cclxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XHJcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xyXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxyXG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXHJcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XHJcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcclxuICAgICkpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcclxuICB9XHJcbn1cclxuXHJcbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcclxuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xyXG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XHJcbiAgICBpZiAoIXNlbGVjdGVkKSB7XHJcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgIH1cclxuICAgIHJldHVybiBzZWxlY3RlZFxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZWxcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xyXG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xyXG4gICAgcmV0dXJuIGVsbVxyXG4gIH1cclxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxyXG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xyXG4gIH1cclxuICByZXR1cm4gZWxtXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XHJcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcclxuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xyXG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xyXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcclxuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XHJcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcclxuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XHJcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcclxufVxyXG5cclxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xyXG4gIHJldHVybiBub2RlLnRhZ05hbWVcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcclxuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xyXG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcclxufVxyXG5cclxuXHJcbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XHJcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxyXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxyXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcclxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxyXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxyXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcclxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXHJcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcclxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXHJcblx0dGFnTmFtZTogdGFnTmFtZSxcclxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXHJcblx0c2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxyXG59KTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIHJlZiA9IHtcclxuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcclxuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcclxuICB9LFxyXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcclxuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xyXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xyXG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcclxuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XHJcbiAgaWYgKCFpc0RlZihrZXkpKSB7IHJldHVybiB9XHJcblxyXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XHJcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcclxuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xyXG4gIGlmIChpc1JlbW92YWwpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcclxuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcclxuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcclxuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xyXG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XHJcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVmc1trZXldID0gcmVmO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxyXG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcclxuICpcclxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXHJcbiAqXHJcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcclxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXHJcbiAqL1xyXG5cclxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcclxuXHJcbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xyXG5cclxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXHJcbiAgICAgIChcclxuICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcclxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcclxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXHJcbiAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxyXG4gICAgICApIHx8IChcclxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXHJcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXHJcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcclxuICAgICAgKVxyXG4gICAgKVxyXG4gIClcclxufVxyXG5cclxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xyXG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XHJcbiAgdmFyIGk7XHJcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcclxuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xyXG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xyXG4gIHZhciBpLCBrZXk7XHJcbiAgdmFyIG1hcCA9IHt9O1xyXG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XHJcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XHJcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cclxuICB9XHJcbiAgcmV0dXJuIG1hcFxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XHJcbiAgdmFyIGksIGo7XHJcbiAgdmFyIGNicyA9IHt9O1xyXG5cclxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcclxuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcclxuXHJcbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XHJcbiAgICBjYnNbaG9va3NbaV1dID0gW107XHJcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xyXG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XHJcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xyXG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xyXG4gICAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcclxuICAgICAgaWYgKC0tcmVtb3ZlLmxpc3RlbmVycyA9PT0gMCkge1xyXG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmUubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xyXG4gICAgcmV0dXJuIHJlbW92ZVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcclxuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xyXG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XHJcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xyXG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgIWluVlByZSAmJlxyXG4gICAgICAhdm5vZGUubnMgJiZcclxuICAgICAgIShcclxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxyXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShmdW5jdGlvbiAoaWdub3JlKSB7XHJcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxyXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcclxuICAgICAgICAgICAgOiBpZ25vcmUgPT09IHZub2RlLnRhZ1xyXG4gICAgICAgIH0pXHJcbiAgICAgICkgJiZcclxuICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKVxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlRWxtIChcclxuICAgIHZub2RlLFxyXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxyXG4gICAgcGFyZW50RWxtLFxyXG4gICAgcmVmRWxtLFxyXG4gICAgbmVzdGVkLFxyXG4gICAgb3duZXJBcnJheSxcclxuICAgIGluZGV4XHJcbiAgKSB7XHJcbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xyXG4gICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxyXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcclxuICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxyXG4gICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xyXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cclxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXHJcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XHJcbiAgICBpZiAoaXNEZWYodGFnKSkge1xyXG4gICAgICB7XHJcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcclxuICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcclxuICAgICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcclxuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xyXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxyXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcclxuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXHJcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XHJcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcclxuXHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICB7XHJcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xyXG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcclxuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XHJcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcclxuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcclxuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xyXG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xyXG4gICAgaWYgKGlzRGVmKGkpKSB7XHJcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xyXG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcclxuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxyXG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcclxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXHJcbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXHJcbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcclxuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XHJcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xyXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XHJcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XHJcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XHJcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICBzZXRTY29wZSh2bm9kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cclxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxyXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XHJcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXHJcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cclxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcclxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxyXG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cclxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcclxuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxyXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcclxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xyXG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcclxuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcclxuICAgICAgICBpZiAocmVmJCQxLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xyXG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgICB7XHJcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XHJcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XHJcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcclxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xyXG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XHJcbiAgICB9XHJcbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxyXG4gICAgaWYgKGlzRGVmKGkpKSB7XHJcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cclxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXHJcbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcclxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXHJcbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZm5TY29wZUlkKSkge1xyXG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xyXG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcclxuICAgICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xyXG4gICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXHJcbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxyXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXHJcbiAgICAgIGkgIT09IHZub2RlLmZuQ29udGV4dCAmJlxyXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcclxuICAgICkge1xyXG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XHJcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XHJcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBmYWxzZSwgdm5vZGVzLCBzdGFydElkeCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcclxuICAgIHZhciBpLCBqO1xyXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XHJcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xyXG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcclxuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcclxuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcclxuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcclxuICAgICAgaWYgKGlzRGVmKGNoKSkge1xyXG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XHJcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcclxuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcclxuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcclxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xyXG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcclxuICAgICAgaWYgKGlzRGVmKHJtKSkge1xyXG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xyXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcclxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXHJcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcclxuICAgICAgfVxyXG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxyXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcclxuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xyXG4gICAgICAgIGkodm5vZGUsIHJtKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBybSgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xyXG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcclxuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XHJcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcclxuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XHJcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xyXG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XHJcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xyXG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcclxuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XHJcblxyXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XHJcbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXHJcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xyXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcclxuXHJcbiAgICB7XHJcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcclxuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcclxuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcclxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xyXG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xyXG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xyXG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XHJcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xyXG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XHJcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XHJcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XHJcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxyXG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xyXG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcclxuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcclxuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcclxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcclxuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcclxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XHJcbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSlcclxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXHJcbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XHJcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XHJcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdm5vZGVUb01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XHJcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xyXG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcclxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XHJcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcclxuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcclxuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xyXG4gICAgdmFyIHNlZW5LZXlzID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xyXG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xyXG4gICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XHJcbiAgICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxyXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcclxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgIHZhciBjID0gb2xkQ2hbaV07XHJcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcclxuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcclxuXHJcbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcclxuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcclxuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXHJcbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cclxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxyXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cclxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXHJcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcclxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcclxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXHJcbiAgICApIHtcclxuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XHJcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XHJcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcclxuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cclxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xyXG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xyXG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cclxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcclxuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxyXG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xyXG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcclxuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xyXG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xyXG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcclxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcclxuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxyXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcclxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xyXG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcclxuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxyXG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXHJcbiAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXHJcbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcclxuXHJcbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cclxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xyXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICBpblZQcmUgPSBpblZQcmUgfHwgKGRhdGEgJiYgZGF0YS5wcmUpO1xyXG4gICAgdm5vZGUuZWxtID0gZWxtO1xyXG5cclxuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XHJcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcbiAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxyXG4gICAge1xyXG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc0RlZihkYXRhKSkge1xyXG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XHJcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XHJcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXHJcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNEZWYodGFnKSkge1xyXG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XHJcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxyXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xyXG4gICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xyXG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXHJcbiAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcclxuICAgICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cclxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXHJcbiAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XHJcbiAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xyXG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcclxuICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xyXG4gICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcclxuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xyXG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XHJcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xyXG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXHJcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcclxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcclxuICAgICAgKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XHJcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcclxuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XHJcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XHJcblxyXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XHJcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcclxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xyXG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XHJcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xyXG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxyXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XHJcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxyXG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cclxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXHJcbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xyXG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xyXG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XHJcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xyXG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgd2FybihcclxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXHJcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXHJcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xyXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcclxuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXHJcbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxyXG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxyXG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XHJcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XHJcblxyXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxyXG4gICAgICAgIGNyZWF0ZUVsbShcclxuICAgICAgICAgIHZub2RlLFxyXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxyXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcclxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xyXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcclxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcclxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxyXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICB2YXIgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xyXG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXShhbmNlc3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xyXG4gICAgICAgICAgICBpZiAocGF0Y2hhYmxlKSB7XHJcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XHJcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIC8vICM2NTEzXHJcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cclxuICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXHJcbiAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XHJcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGF0IGluZGV4IDEgdG8gYXZvaWQgcmUtaW52b2tpbmcgY29tcG9uZW50IG1vdW50ZWQgaG9va1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgaW5zZXJ0LmZucy5sZW5ndGg7IGkkMisrKSB7XHJcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXHJcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xyXG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcclxuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcclxuICAgIHJldHVybiB2bm9kZS5lbG1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGRpcmVjdGl2ZXMgPSB7XHJcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxyXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcclxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xyXG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XHJcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xyXG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xyXG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XHJcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcclxuXHJcbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XHJcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XHJcblxyXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xyXG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcclxuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcclxuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcclxuICAgIGlmICghb2xkRGlyKSB7XHJcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcclxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcclxuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xyXG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcclxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xyXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XHJcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xyXG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xyXG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKGlzQ3JlYXRlKSB7XHJcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjYWxsSW5zZXJ0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XHJcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpZiAoIWlzQ3JlYXRlKSB7XHJcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XHJcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XHJcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxyXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcclxuICBkaXJzLFxyXG4gIHZtXHJcbikge1xyXG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIGlmICghZGlycykge1xyXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfVxyXG4gIHZhciBpLCBkaXI7XHJcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcclxuICAgIGRpciA9IGRpcnNbaV07XHJcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcclxuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcclxuICAgIH1cclxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xyXG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XHJcbiAgfVxyXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XHJcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xyXG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcclxuICBpZiAoZm4pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBiYXNlTW9kdWxlcyA9IFtcclxuICByZWYsXHJcbiAgZGlyZWN0aXZlc1xyXG5dXHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgdmFyIGtleSwgY3VyLCBvbGQ7XHJcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcclxuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xyXG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XHJcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XHJcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcclxuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xyXG4gIH1cclxuXHJcbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcclxuICAgIGN1ciA9IGF0dHJzW2tleV07XHJcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xyXG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XHJcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXHJcbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xyXG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcclxuICB9XHJcbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcclxuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XHJcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcclxuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xyXG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcclxuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XHJcbiAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcclxuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcclxuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xyXG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcclxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XHJcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcclxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXHJcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXHJcbiAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXHJcbiAgICAgICAgPyAndHJ1ZSdcclxuICAgICAgICA6IGtleTtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XHJcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xyXG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XHJcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcclxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xyXG4gIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xyXG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXHJcbiAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXHJcbiAgICAvLyBpbW1lZGlhdGVseS5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKFxyXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxyXG4gICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXHJcbiAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiAhZWwuX19pZXBoXHJcbiAgICApIHtcclxuICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcclxuICAgICAgfTtcclxuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcclxuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cclxuICAgIH1cclxuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBhdHRycyA9IHtcclxuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxyXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XHJcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xyXG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XHJcbiAgaWYgKFxyXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxyXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXHJcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxyXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcclxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXHJcbiAgICAgIClcclxuICAgIClcclxuICApIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xyXG5cclxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXHJcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcclxuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xyXG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XHJcbiAgfVxyXG5cclxuICAvLyBzZXQgdGhlIGNsYXNzXHJcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xyXG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XHJcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGtsYXNzID0ge1xyXG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXHJcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xyXG5cclxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcclxuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcclxuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcclxuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xyXG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XHJcbiAgdmFyIGN1cmx5ID0gMDtcclxuICB2YXIgc3F1YXJlID0gMDtcclxuICB2YXIgcGFyZW4gPSAwO1xyXG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xyXG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBwcmV2ID0gYztcclxuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcclxuICAgIGlmIChpblNpbmdsZSkge1xyXG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cclxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcclxuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XHJcbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcclxuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cclxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xyXG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXHJcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxyXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcclxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXHJcbiAgICApIHtcclxuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cclxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcclxuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwdXNoRmlsdGVyKCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN3aXRjaCAoYykge1xyXG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXHJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xyXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcclxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXHJcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxyXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcclxuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXHJcbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXHJcbiAgICAgICAgdmFyIGogPSBpIC0gMTtcclxuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xyXG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXHJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcclxuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xyXG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcclxuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xyXG4gICAgcHVzaEZpbHRlcigpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XHJcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xyXG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XHJcbiAgfVxyXG5cclxuICBpZiAoZmlsdGVycykge1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZXhwcmVzc2lvblxyXG59XHJcblxyXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xyXG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcclxuICBpZiAoaSA8IDApIHtcclxuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXHJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcclxuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcclxuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcclxuICBtb2R1bGVzLFxyXG4gIGtleVxyXG4pIHtcclxuICByZXR1cm4gbW9kdWxlc1xyXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXHJcbiAgICA6IFtdXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xyXG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XHJcbiAgZWwucGxhaW4gPSBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XHJcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcclxuICBlbC5wbGFpbiA9IGZhbHNlO1xyXG59XHJcblxyXG4vLyBhZGQgYSByYXcgYXR0ciAodXNlIHRoaXMgaW4gcHJlVHJhbnNmb3JtcylcclxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XHJcbiAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcclxuICBlbC5hdHRyc0xpc3QucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcclxuICBlbCxcclxuICBuYW1lLFxyXG4gIHJhd05hbWUsXHJcbiAgdmFsdWUsXHJcbiAgYXJnLFxyXG4gIG1vZGlmaWVyc1xyXG4pIHtcclxuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xyXG4gIGVsLnBsYWluID0gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxyXG4gIGVsLFxyXG4gIG5hbWUsXHJcbiAgdmFsdWUsXHJcbiAgbW9kaWZpZXJzLFxyXG4gIGltcG9ydGFudCxcclxuICB3YXJuXHJcbikge1xyXG4gIG1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBlbXB0eU9iamVjdDtcclxuICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoXHJcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuICYmXHJcbiAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxyXG4gICkge1xyXG4gICAgd2FybihcclxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcclxuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxyXG4gIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xyXG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xyXG4gICAgbmFtZSA9ICchJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXHJcbiAgfVxyXG4gIGlmIChtb2RpZmllcnMub25jZSkge1xyXG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xyXG4gICAgbmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2VcclxuICB9XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XHJcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XHJcbiAgICBuYW1lID0gJyYnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgcGFzc2l2ZVxyXG4gIH1cclxuXHJcbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXHJcbiAgLy8gdGhpcyBpcyB0ZWNobmljYWxseSBicm93c2VyLXNwZWNpZmljLCBidXQgYXQgbGVhc3QgZm9yIG5vdyBicm93c2VycyBhcmVcclxuICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cclxuICBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xyXG4gICAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xyXG4gICAgICBuYW1lID0gJ2NvbnRleHRtZW51JztcclxuICAgICAgZGVsZXRlIG1vZGlmaWVycy5yaWdodDtcclxuICAgIH0gZWxzZSBpZiAobW9kaWZpZXJzLm1pZGRsZSkge1xyXG4gICAgICBuYW1lID0gJ21vdXNldXAnO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGV2ZW50cztcclxuICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xyXG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XHJcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XHJcbiAgfVxyXG5cclxuICB2YXIgbmV3SGFuZGxlciA9IHtcclxuICAgIHZhbHVlOiB2YWx1ZS50cmltKClcclxuICB9O1xyXG4gIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XHJcbiAgICBuZXdIYW5kbGVyLm1vZGlmaWVycyA9IG1vZGlmaWVycztcclxuICB9XHJcblxyXG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcclxuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xyXG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcclxuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xyXG4gIH1cclxuXHJcbiAgZWwucGxhaW4gPSBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxyXG4gIGVsLFxyXG4gIG5hbWUsXHJcbiAgZ2V0U3RhdGljXHJcbikge1xyXG4gIHZhciBkeW5hbWljVmFsdWUgPVxyXG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcclxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xyXG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXHJcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XHJcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcclxuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcclxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cclxuLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXHJcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cclxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXHJcbiAgZWwsXHJcbiAgbmFtZSxcclxuICByZW1vdmVGcm9tTWFwXHJcbikge1xyXG4gIHZhciB2YWw7XHJcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xyXG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcclxuICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XHJcbiAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XHJcbiAgfVxyXG4gIHJldHVybiB2YWxcclxufVxyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxyXG4gIGVsLFxyXG4gIHZhbHVlLFxyXG4gIG1vZGlmaWVyc1xyXG4pIHtcclxuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xyXG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xyXG4gIHZhciB0cmltID0gcmVmLnRyaW07XHJcblxyXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XHJcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XHJcbiAgaWYgKHRyaW0pIHtcclxuICAgIHZhbHVlRXhwcmVzc2lvbiA9XHJcbiAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXHJcbiAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXHJcbiAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcclxuICB9XHJcbiAgaWYgKG51bWJlcikge1xyXG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xyXG4gIH1cclxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xyXG5cclxuICBlbC5tb2RlbCA9IHtcclxuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcclxuICAgIGV4cHJlc3Npb246IChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLFxyXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cclxuICovXHJcbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcclxuICB2YWx1ZSxcclxuICBhc3NpZ25tZW50XHJcbikge1xyXG4gIHZhciByZXMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcclxuICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIChcIiRzZXQoXCIgKyAocmVzLmV4cCkgKyBcIiwgXCIgKyAocmVzLmtleSkgKyBcIiwgXCIgKyBhc3NpZ25tZW50ICsgXCIpXCIpXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgYSB2LW1vZGVsIGV4cHJlc3Npb24gaW50byBhIGJhc2UgcGF0aCBhbmQgYSBmaW5hbCBrZXkgc2VnbWVudC5cclxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXHJcbiAqXHJcbiAqIFBvc3NpYmxlIGNhc2VzOlxyXG4gKlxyXG4gKiAtIHRlc3RcclxuICogLSB0ZXN0W2tleV1cclxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXHJcbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxyXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFba2V5XV1cclxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXHJcbiAqXHJcbiAqL1xyXG5cclxudmFyIGxlbjtcclxudmFyIHN0cjtcclxudmFyIGNocjtcclxudmFyIGluZGV4JDE7XHJcbnZhciBleHByZXNzaW9uUG9zO1xyXG52YXIgZXhwcmVzc2lvbkVuZFBvcztcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XHJcbiAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXHJcbiAgLy8gYWxsb3cgdi1tb2RlbD1cIm9iai52YWwgXCIgKHRyYWlsaW5nIHdoaXRlc3BhY2UpXHJcbiAgdmFsID0gdmFsLnRyaW0oKTtcclxuICBsZW4gPSB2YWwubGVuZ3RoO1xyXG5cclxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XHJcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XHJcbiAgICBpZiAoaW5kZXgkMSA+IC0xKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXHJcbiAgICAgICAga2V5OiAnXCInICsgdmFsLnNsaWNlKGluZGV4JDEgKyAxKSArICdcIidcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBleHA6IHZhbCxcclxuICAgICAgICBrZXk6IG51bGxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RyID0gdmFsO1xyXG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XHJcblxyXG4gIHdoaWxlICghZW9mKCkpIHtcclxuICAgIGNociA9IG5leHQoKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xyXG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xyXG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcclxuICAgICAgcGFyc2VCcmFja2V0KGNocik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZXhwOiB2YWwuc2xpY2UoMCwgZXhwcmVzc2lvblBvcyksXHJcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHQgKCkge1xyXG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVvZiAoKSB7XHJcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xyXG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XHJcbiAgdmFyIGluQnJhY2tldCA9IDE7XHJcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XHJcbiAgd2hpbGUgKCFlb2YoKSkge1xyXG4gICAgY2hyID0gbmV4dCgpO1xyXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xyXG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xyXG4gICAgICBjb250aW51ZVxyXG4gICAgfVxyXG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxyXG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxyXG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xyXG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcclxuICAgICAgYnJlYWtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcclxuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XHJcbiAgd2hpbGUgKCFlb2YoKSkge1xyXG4gICAgY2hyID0gbmV4dCgpO1xyXG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcclxuICAgICAgYnJlYWtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIHdhcm4kMTtcclxuXHJcbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcclxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cclxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XHJcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xyXG5cclxuZnVuY3Rpb24gbW9kZWwgKFxyXG4gIGVsLFxyXG4gIGRpcixcclxuICBfd2FyblxyXG4pIHtcclxuICB3YXJuJDEgPSBfd2FybjtcclxuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XHJcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XHJcbiAgdmFyIHRhZyA9IGVsLnRhZztcclxuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XHJcblxyXG4gIHtcclxuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xyXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cclxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XHJcbiAgICAgIHdhcm4kMShcclxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xyXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xyXG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xyXG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xyXG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XHJcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XHJcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcclxuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XHJcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xyXG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xyXG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH0gZWxzZSB7XHJcbiAgICB3YXJuJDEoXHJcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xyXG4gICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xyXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXHJcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LidcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcclxuICByZXR1cm4gdHJ1ZVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcclxuICBlbCxcclxuICB2YWx1ZSxcclxuICBtb2RpZmllcnNcclxuKSB7XHJcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xyXG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xyXG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xyXG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xyXG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcclxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xyXG4gICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXHJcbiAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xyXG4gICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXHJcbiAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxyXG4gICAgKVxyXG4gICk7XHJcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXHJcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcclxuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xyXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcclxuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xyXG4gICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xyXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcclxuICAgICAgXCJpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuY29uY2F0KFskJHZdKScpKSArIFwiKX1cIiArXHJcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpJykpICsgXCIpfVwiICtcclxuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcclxuICAgIG51bGwsIHRydWVcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcclxuICBlbCxcclxuICB2YWx1ZSxcclxuICBtb2RpZmllcnNcclxuKSB7XHJcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xyXG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xyXG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xyXG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcclxuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxyXG4gIGVsLFxyXG4gIHZhbHVlLFxyXG4gIG1vZGlmaWVyc1xyXG4pIHtcclxuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XHJcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xyXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcclxuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXHJcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XHJcblxyXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XHJcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xyXG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcclxuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXHJcbiAgZWwsXHJcbiAgdmFsdWUsXHJcbiAgbW9kaWZpZXJzXHJcbikge1xyXG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcclxuXHJcbiAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxyXG4gIC8vIGV4Y2VwdCBmb3IgaW5wdXRzIHdpdGggdi1iaW5kOnR5cGVcclxuICB7XHJcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XHJcbiAgICB2YXIgdHlwZUJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcclxuICAgIGlmICh2YWx1ZSQxICYmICF0eXBlQmluZGluZykge1xyXG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XHJcbiAgICAgIHdhcm4kMShcclxuICAgICAgICBiaW5kaW5nICsgXCI9XFxcIlwiICsgdmFsdWUkMSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCB2LW1vZGVsIG9uIHRoZSBzYW1lIGVsZW1lbnQgXCIgK1xyXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5J1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcclxuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xyXG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xyXG4gIHZhciB0cmltID0gcmVmLnRyaW07XHJcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcclxuICB2YXIgZXZlbnQgPSBsYXp5XHJcbiAgICA/ICdjaGFuZ2UnXHJcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcclxuICAgICAgPyBSQU5HRV9UT0tFTlxyXG4gICAgICA6ICdpbnB1dCc7XHJcblxyXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XHJcbiAgaWYgKHRyaW0pIHtcclxuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcclxuICB9XHJcbiAgaWYgKG51bWJlcikge1xyXG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xyXG4gIH1cclxuXHJcbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcclxuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcclxuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XHJcbiAgfVxyXG5cclxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XHJcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xyXG4gIGlmICh0cmltIHx8IG51bWJlcikge1xyXG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxyXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXHJcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcclxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cclxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XHJcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XHJcbiAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xyXG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcclxuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XHJcbiAgfVxyXG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XHJcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XHJcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xyXG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcclxuICB9XHJcbn1cclxuXHJcbnZhciB0YXJnZXQkMTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChoYW5kbGVyLCBldmVudCwgY2FwdHVyZSkge1xyXG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcclxuICAgIHZhciByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XHJcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGQkMSAoXHJcbiAgZXZlbnQsXHJcbiAgaGFuZGxlcixcclxuICBvbmNlJCQxLFxyXG4gIGNhcHR1cmUsXHJcbiAgcGFzc2l2ZVxyXG4pIHtcclxuICBoYW5kbGVyID0gd2l0aE1hY3JvVGFzayhoYW5kbGVyKTtcclxuICBpZiAob25jZSQkMSkgeyBoYW5kbGVyID0gY3JlYXRlT25jZUhhbmRsZXIoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpOyB9XHJcbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgIGV2ZW50LFxyXG4gICAgaGFuZGxlcixcclxuICAgIHN1cHBvcnRzUGFzc2l2ZVxyXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XHJcbiAgICAgIDogY2FwdHVyZVxyXG4gICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZSQyIChcclxuICBldmVudCxcclxuICBoYW5kbGVyLFxyXG4gIGNhcHR1cmUsXHJcbiAgX3RhcmdldFxyXG4pIHtcclxuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuICAgIGV2ZW50LFxyXG4gICAgaGFuZGxlci5fd2l0aFRhc2sgfHwgaGFuZGxlcixcclxuICAgIGNhcHR1cmVcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xyXG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XHJcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XHJcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcclxuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xyXG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG52YXIgZXZlbnRzID0ge1xyXG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxyXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIga2V5LCBjdXI7XHJcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcclxuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xyXG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XHJcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XHJcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcclxuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xyXG4gIH1cclxuXHJcbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcclxuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XHJcbiAgICAgIGVsbVtrZXldID0gJyc7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZvciAoa2V5IGluIHByb3BzKSB7XHJcbiAgICBjdXIgPSBwcm9wc1trZXldO1xyXG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXHJcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xyXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcclxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xyXG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxyXG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cclxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxyXG4gICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxyXG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcclxuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcclxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxyXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xyXG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcclxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XHJcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcclxuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsbVtrZXldID0gY3VyO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXHJcblxyXG5cclxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcclxuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcclxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxyXG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcclxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXHJcbiAgKSlcclxufVxyXG5cclxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcclxuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXHJcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXHJcbiAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xyXG4gIC8vICM2MTU3XHJcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXHJcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cclxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xyXG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcclxuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcclxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xyXG4gICAgaWYgKG1vZGlmaWVycy5sYXp5KSB7XHJcbiAgICAgIC8vIGlucHV0cyB3aXRoIGxhenkgc2hvdWxkIG9ubHkgYmUgdXBkYXRlZCB3aGVuIG5vdCBpbiBmb2N1c1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XHJcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcclxuICAgIH1cclxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXHJcbn1cclxuXHJcbnZhciBkb21Qcm9wcyA9IHtcclxuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxyXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcclxuICB2YXIgcmVzID0ge307XHJcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xyXG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XHJcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICBpZiAoaXRlbSkge1xyXG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XHJcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gcmVzXHJcbn0pO1xyXG5cclxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcclxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XHJcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xyXG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxyXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XHJcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcclxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxyXG4gICAgOiBzdHlsZVxyXG59XHJcblxyXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xyXG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxyXG4gIH1cclxuICByZXR1cm4gYmluZGluZ1N0eWxlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXHJcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcclxuICB2YXIgcmVzID0ge307XHJcbiAgdmFyIHN0eWxlRGF0YTtcclxuXHJcbiAgaWYgKGNoZWNrQ2hpbGQpIHtcclxuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcclxuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxyXG4gICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxyXG4gICAgICApIHtcclxuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcclxuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XHJcbiAgfVxyXG5cclxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xyXG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xyXG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XHJcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcclxudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XHJcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xyXG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcclxuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xyXG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XHJcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXHJcbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cclxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XHJcblxyXG52YXIgZW1wdHlTdHlsZTtcclxudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xyXG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xyXG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcclxuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcclxuICAgIHJldHVybiBwcm9wXHJcbiAgfVxyXG4gIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XHJcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XHJcbiAgICAgIHJldHVybiBuYW1lXHJcbiAgICB9XHJcbiAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XHJcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xyXG5cclxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXHJcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcclxuICApIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgdmFyIGN1ciwgbmFtZTtcclxuICB2YXIgZWwgPSB2bm9kZS5lbG07XHJcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcclxuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcclxuXHJcbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcclxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XHJcblxyXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcclxuXHJcbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxyXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcclxuICAvLyB0byBtdXRhdGUgaXQuXHJcbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXHJcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXHJcbiAgICA6IHN0eWxlO1xyXG5cclxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XHJcblxyXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xyXG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XHJcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcclxuICAgIH1cclxuICB9XHJcbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XHJcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcclxuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XHJcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXHJcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIHN0eWxlID0ge1xyXG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXHJcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qKlxyXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cclxuICogU1ZHIGVsZW1lbnRzIGluIElFXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICBpZiAoZWwuY2xhc3NMaXN0KSB7XHJcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XHJcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xyXG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XHJcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxyXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcclxuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcclxuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcclxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xyXG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcclxuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcclxuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xyXG4gICAgfVxyXG4gICAgY3VyID0gY3VyLnRyaW0oKTtcclxuICAgIGlmIChjdXIpIHtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYpIHtcclxuICBpZiAoIWRlZikge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdvYmplY3QnKSB7XHJcbiAgICB2YXIgcmVzID0ge307XHJcbiAgICBpZiAoZGVmLmNzcyAhPT0gZmFsc2UpIHtcclxuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmLm5hbWUgfHwgJ3YnKSk7XHJcbiAgICB9XHJcbiAgICBleHRlbmQocmVzLCBkZWYpO1xyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYpXHJcbiAgfVxyXG59XHJcblxyXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcclxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcclxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxyXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcclxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcclxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcclxudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XHJcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcclxuXHJcbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcclxudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xyXG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xyXG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xyXG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcclxuaWYgKGhhc1RyYW5zaXRpb24pIHtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcclxuICApIHtcclxuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xyXG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xyXG4gIH1cclxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcclxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXHJcbiAgKSB7XHJcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XHJcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xyXG4gIH1cclxufVxyXG5cclxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXHJcbnZhciByYWYgPSBpbkJyb3dzZXJcclxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcclxuICAgIDogc2V0VGltZW91dFxyXG4gIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9O1xyXG5cclxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xyXG4gIHJhZihmdW5jdGlvbiAoKSB7XHJcbiAgICByYWYoZm4pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcclxuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcclxuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xyXG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xyXG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcclxuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XHJcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xyXG4gIH1cclxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcclxuICBlbCxcclxuICBleHBlY3RlZFR5cGUsXHJcbiAgY2JcclxuKSB7XHJcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xyXG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XHJcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcclxuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcclxuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxyXG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcclxuICB2YXIgZW5kZWQgPSAwO1xyXG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XHJcbiAgICBjYigpO1xyXG4gIH07XHJcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcclxuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcclxuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XHJcbiAgICAgICAgZW5kKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XHJcbiAgICAgIGVuZCgpO1xyXG4gICAgfVxyXG4gIH0sIHRpbWVvdXQgKyAxKTtcclxuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XHJcbn1cclxuXHJcbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XHJcblxyXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xyXG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XHJcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcclxuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xyXG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XHJcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XHJcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XHJcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcclxuXHJcbiAgdmFyIHR5cGU7XHJcbiAgdmFyIHRpbWVvdXQgPSAwO1xyXG4gIHZhciBwcm9wQ291bnQgPSAwO1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcclxuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcclxuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XHJcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcclxuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xyXG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XHJcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XHJcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xyXG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xyXG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXHJcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XHJcbiAgICAgICAgPyBUUkFOU0lUSU9OXHJcbiAgICAgICAgOiBBTklNQVRJT05cclxuICAgICAgOiBudWxsO1xyXG4gICAgcHJvcENvdW50ID0gdHlwZVxyXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cclxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgIDogMDtcclxuICB9XHJcbiAgdmFyIGhhc1RyYW5zZm9ybSA9XHJcbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXHJcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogdHlwZSxcclxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXHJcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcclxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcclxuICB9KSlcclxufVxyXG5cclxuZnVuY3Rpb24gdG9NcyAocykge1xyXG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xyXG4gIHZhciBlbCA9IHZub2RlLmVsbTtcclxuXHJcbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcclxuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XHJcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgZWwuX2xlYXZlQ2IoKTtcclxuICB9XHJcblxyXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcclxuICBpZiAoaXNVbmRlZihkYXRhKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcclxuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcclxuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcclxuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XHJcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XHJcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcclxuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcclxuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xyXG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XHJcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcclxuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcclxuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xyXG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcclxuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XHJcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcclxuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XHJcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcclxuXHJcbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xyXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxyXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXHJcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXHJcbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcclxuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XHJcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xyXG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XHJcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcclxuICB9XHJcblxyXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcclxuXHJcbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXHJcbiAgICA/IGFwcGVhckNsYXNzXHJcbiAgICA6IGVudGVyQ2xhc3M7XHJcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcclxuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcclxuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcclxuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcclxuICAgID8gYXBwZWFyVG9DbGFzc1xyXG4gICAgOiBlbnRlclRvQ2xhc3M7XHJcblxyXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxyXG4gICAgOiBiZWZvcmVFbnRlcjtcclxuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcclxuICAgIDogZW50ZXI7XHJcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXHJcbiAgICA6IGFmdGVyRW50ZXI7XHJcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXHJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXHJcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xyXG5cclxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXHJcbiAgICBpc09iamVjdChkdXJhdGlvbilcclxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxyXG4gICAgICA6IGR1cmF0aW9uXHJcbiAgKTtcclxuXHJcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XHJcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcclxuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcclxuXHJcbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChleHBlY3RzQ1NTKSB7XHJcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XHJcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xyXG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XHJcbiAgICAgIH1cclxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XHJcbiAgICB9XHJcbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XHJcbiAgfSk7XHJcblxyXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XHJcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xyXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xyXG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcclxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxyXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxyXG4gICAgICApIHtcclxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcclxuICAgICAgfVxyXG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cclxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcclxuICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcclxuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xyXG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcclxuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcclxuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xyXG4gICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xyXG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xyXG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XHJcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XHJcbiAgfVxyXG5cclxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcclxuICAgIGNiKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XHJcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xyXG5cclxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xyXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcclxuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICBlbC5fZW50ZXJDYigpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xyXG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XHJcbiAgICByZXR1cm4gcm0oKVxyXG4gIH1cclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICB2YXIgY3NzID0gZGF0YS5jc3M7XHJcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XHJcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XHJcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xyXG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xyXG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XHJcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcclxuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcclxuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xyXG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xyXG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XHJcblxyXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XHJcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcclxuXHJcbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxyXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXHJcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcclxuICAgICAgOiBkdXJhdGlvblxyXG4gICk7XHJcblxyXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XHJcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcclxuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChleHBlY3RzQ1NTKSB7XHJcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcclxuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcclxuICAgIH1cclxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcclxuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xyXG4gICAgICB9XHJcbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJtKCk7XHJcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XHJcbiAgICB9XHJcbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChkZWxheUxlYXZlKSB7XHJcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHBlcmZvcm1MZWF2ZSgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcclxuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcclxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XHJcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xyXG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XHJcbiAgICB9XHJcbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XHJcbiAgICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xyXG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XHJcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcclxuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcclxuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcclxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XHJcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcclxuICAgICAgY2IoKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxyXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXHJcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXHJcbiAgICAgIHZub2RlLmNvbnRleHRcclxuICAgICk7XHJcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXHJcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcclxuICAgICAgdm5vZGUuY29udGV4dFxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcclxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXHJcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxyXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xyXG4gIGlmIChpc1VuZGVmKGZuKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xyXG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xyXG4gICAgLy8gaW52b2tlclxyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXHJcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcclxuICAgICAgICA/IGludm9rZXJGbnNbMF1cclxuICAgICAgICA6IGludm9rZXJGbnNcclxuICAgIClcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XHJcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xyXG4gICAgZW50ZXIodm5vZGUpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XHJcbiAgY3JlYXRlOiBfZW50ZXIsXHJcbiAgYWN0aXZhdGU6IF9lbnRlcixcclxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xyXG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcm0oKTtcclxuICAgIH1cclxuICB9XHJcbn0gOiB7fVxyXG5cclxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcclxuICBhdHRycyxcclxuICBrbGFzcyxcclxuICBldmVudHMsXHJcbiAgZG9tUHJvcHMsXHJcbiAgc3R5bGUsXHJcbiAgdHJhbnNpdGlvblxyXG5dXHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxyXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxyXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xyXG5cclxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XHJcblxyXG4vKipcclxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXHJcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXHJcbiAqL1xyXG5cclxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbmlmIChpc0lFOSkge1xyXG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xyXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XHJcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XHJcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG52YXIgZGlyZWN0aXZlID0ge1xyXG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xyXG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcclxuICAgICAgLy8gIzY5MDNcclxuICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xyXG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XHJcbiAgICAgIH1cclxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xyXG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XHJcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XHJcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xyXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xyXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XHJcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxyXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcclxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXHJcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXHJcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKGlzSUU5KSB7XHJcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcclxuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xyXG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcclxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxyXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcclxuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXHJcbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcclxuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XHJcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcclxuICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxyXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXHJcbiAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXHJcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKTsgfSlcclxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xyXG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcclxuICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XHJcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcclxuICAgIH0sIDApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XHJcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcclxuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xyXG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcclxuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXHJcbiAgICAgIHZtXHJcbiAgICApO1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XHJcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xyXG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcclxuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcclxuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XHJcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcclxuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoIWlzTXVsdGlwbGUpIHtcclxuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xyXG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cclxuICAgID8gb3B0aW9uLl92YWx1ZVxyXG4gICAgOiBvcHRpb24udmFsdWVcclxufVxyXG5cclxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XHJcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xyXG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXHJcbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cclxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcclxuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcclxuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XHJcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XHJcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XHJcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxyXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcclxuICAgIDogdm5vZGVcclxufVxyXG5cclxudmFyIHNob3cgPSB7XHJcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcclxuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcclxuXHJcbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xyXG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcclxuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxyXG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XHJcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xyXG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xyXG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xyXG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xyXG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSB7IHJldHVybiB9XHJcbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xyXG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcclxuICAgIGlmICh0cmFuc2l0aW9uJCQxKSB7XHJcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XHJcbiAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxyXG4gICAgZWwsXHJcbiAgICBiaW5kaW5nLFxyXG4gICAgdm5vZGUsXHJcbiAgICBvbGRWbm9kZSxcclxuICAgIGlzRGVzdHJveVxyXG4gICkge1xyXG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcclxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XHJcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcclxuICBzaG93OiBzaG93XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cclxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXHJcblxyXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xyXG4gIG5hbWU6IFN0cmluZyxcclxuICBhcHBlYXI6IEJvb2xlYW4sXHJcbiAgY3NzOiBCb29sZWFuLFxyXG4gIG1vZGU6IFN0cmluZyxcclxuICB0eXBlOiBTdHJpbmcsXHJcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxyXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcclxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcclxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcclxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXHJcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxyXG59O1xyXG5cclxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XHJcbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXHJcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcclxuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xyXG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcclxuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB2bm9kZVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XHJcbiAgdmFyIGRhdGEgPSB7fTtcclxuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XHJcbiAgLy8gcHJvcHNcclxuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcclxuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcclxuICB9XHJcbiAgLy8gZXZlbnRzLlxyXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xyXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XHJcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XHJcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xyXG4gIH1cclxuICByZXR1cm4gZGF0YVxyXG59XHJcblxyXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcclxuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XHJcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcclxuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXHJcbiAgICB9KVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcclxuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xyXG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xyXG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xyXG59XHJcblxyXG52YXIgVHJhbnNpdGlvbiA9IHtcclxuICBuYW1lOiAndHJhbnNpdGlvbicsXHJcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcclxuICBhYnN0cmFjdDogdHJ1ZSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XHJcbiAgICBpZiAoIWNoaWxkcmVuKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXHJcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xyXG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xyXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXHJcbiAgICAgICAgdGhpcy4kcGFyZW50XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XHJcblxyXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcclxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXHJcbiAgICApIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXHJcbiAgICAgICAgdGhpcy4kcGFyZW50XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XHJcblxyXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xyXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXHJcbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcclxuICAgICAgcmV0dXJuIHJhd0NoaWxkXHJcbiAgICB9XHJcblxyXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXHJcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXHJcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWNoaWxkKSB7XHJcbiAgICAgIHJldHVybiByYXdDaGlsZFxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XHJcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcclxuICAgIH1cclxuXHJcbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxyXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xyXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxyXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xyXG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcclxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcclxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXHJcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xyXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcclxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxyXG4gICAgICAgIDogY2hpbGQua2V5O1xyXG5cclxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XHJcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcclxuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XHJcblxyXG4gICAgLy8gbWFyayB2LXNob3dcclxuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxyXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XHJcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBvbGRDaGlsZCAmJlxyXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXHJcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXHJcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXHJcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXHJcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcclxuICAgICkge1xyXG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcclxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxyXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XHJcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcclxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XHJcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXHJcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XHJcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXHJcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcclxuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xyXG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XHJcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XHJcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xyXG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XHJcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJhd0NoaWxkXHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cclxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXHJcblxyXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXHJcbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxyXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxyXG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcclxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcclxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcclxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXHJcblxyXG52YXIgcHJvcHMgPSBleHRlbmQoe1xyXG4gIHRhZzogU3RyaW5nLFxyXG4gIG1vdmVDbGFzczogU3RyaW5nXHJcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XHJcblxyXG5kZWxldGUgcHJvcHMubW9kZTtcclxuXHJcbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XHJcbiAgcHJvcHM6IHByb3BzLFxyXG5cclxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xyXG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcclxuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XHJcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xyXG4gICAgICBpZiAoYy50YWcpIHtcclxuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xyXG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcclxuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXHJcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xyXG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XHJcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XHJcbiAgICAgIHZhciBrZXB0ID0gW107XHJcbiAgICAgIHZhciByZW1vdmVkID0gW107XHJcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XHJcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xyXG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcclxuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcclxuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xyXG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXHJcbiAgfSxcclxuXHJcbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xyXG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xyXG4gICAgdGhpcy5fX3BhdGNoX18oXHJcbiAgICAgIHRoaXMuX3Zub2RlLFxyXG4gICAgICB0aGlzLmtlcHQsXHJcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcclxuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXHJcbiAgICApO1xyXG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcclxuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XHJcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcclxuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxyXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XHJcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcclxuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XHJcblxyXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXHJcbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xyXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcclxuXHJcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcclxuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcclxuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xyXG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcclxuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcclxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XHJcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XHJcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xyXG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIG1ldGhvZHM6IHtcclxuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICB9XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXHJcbiAgICAgIH1cclxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXHJcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xyXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXHJcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xyXG4gICAgICAvLyBpcyBhcHBsaWVkLlxyXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcclxuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xyXG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XHJcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xyXG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XHJcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoYy5lbG0uX21vdmVDYikge1xyXG4gICAgYy5lbG0uX21vdmVDYigpO1xyXG4gIH1cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcclxuICAgIGMuZWxtLl9lbnRlckNiKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xyXG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xyXG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xyXG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xyXG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XHJcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XHJcbiAgaWYgKGR4IHx8IGR5KSB7XHJcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xyXG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcclxuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcclxuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcclxuICB9XHJcbn1cclxuXHJcbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XHJcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcclxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcclxuVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xyXG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xyXG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XHJcblZ1ZS5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xyXG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xyXG5cclxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXHJcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xyXG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcclxuXHJcbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cclxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XHJcblxyXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXHJcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxyXG4gIGVsLFxyXG4gIGh5ZHJhdGluZ1xyXG4pIHtcclxuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcclxuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcclxufTtcclxuXHJcbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmlmIChpbkJyb3dzZXIpIHtcclxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcclxuICAgICAgaWYgKGRldnRvb2xzKSB7XHJcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICBcImRldmVsb3BtZW50XCIgIT09ICd0ZXN0JyAmJlxyXG4gICAgICAgIGlzQ2hyb21lXHJcbiAgICAgICkge1xyXG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxyXG4gICAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xyXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Rlc3QnICYmXHJcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxyXG4gICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICkge1xyXG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcclxuICAgICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXHJcbiAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xyXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH0sIDApO1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxuKSs/KVxcfVxcfS9nO1xyXG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XHJcblxyXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xyXG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcclxuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xyXG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXHJcbn0pO1xyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBwYXJzZVRleHQgKFxyXG4gIHRleHQsXHJcbiAgZGVsaW1pdGVyc1xyXG4pIHtcclxuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcclxuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgdG9rZW5zID0gW107XHJcbiAgdmFyIHJhd1Rva2VucyA9IFtdO1xyXG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xyXG4gIHZhciBtYXRjaCwgaW5kZXgsIHRva2VuVmFsdWU7XHJcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XHJcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xyXG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXHJcbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcclxuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xyXG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICAvLyB0YWcgdG9rZW5cclxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcclxuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcclxuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xyXG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XHJcbiAgfVxyXG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xyXG4gICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSk7XHJcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICBleHByZXNzaW9uOiB0b2tlbnMuam9pbignKycpLFxyXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcclxuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcclxuICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcclxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcclxuICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xyXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xyXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xyXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChzdGF0aWNDbGFzcykge1xyXG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XHJcbiAgfVxyXG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcclxuICBpZiAoY2xhc3NCaW5kaW5nKSB7XHJcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xyXG4gIHZhciBkYXRhID0gJyc7XHJcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XHJcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XHJcbiAgfVxyXG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcclxuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XHJcbiAgfVxyXG4gIHJldHVybiBkYXRhXHJcbn1cclxuXHJcbnZhciBrbGFzcyQxID0ge1xyXG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcclxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxyXG4gIGdlbkRhdGE6IGdlbkRhdGFcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XHJcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XHJcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XHJcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIHtcclxuICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcclxuICAgICAgaWYgKHJlcykge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXHJcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcclxuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xyXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LidcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XHJcbiAgfVxyXG5cclxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XHJcbiAgaWYgKHN0eWxlQmluZGluZykge1xyXG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xyXG4gIHZhciBkYXRhID0gJyc7XHJcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XHJcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XHJcbiAgfVxyXG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcclxuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcclxuICB9XHJcbiAgcmV0dXJuIGRhdGFcclxufVxyXG5cclxudmFyIHN0eWxlJDEgPSB7XHJcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxyXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcclxuICBnZW5EYXRhOiBnZW5EYXRhJDFcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgZGVjb2RlcjtcclxuXHJcbnZhciBoZSA9IHtcclxuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xyXG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XHJcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXHJcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xyXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcclxuKTtcclxuXHJcbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxyXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXHJcbnZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcclxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcclxuKTtcclxuXHJcbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcclxuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XHJcbnZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcclxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xyXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXHJcbiAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xyXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXHJcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xyXG4pO1xyXG5cclxuLyoqXHJcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxyXG4gKi9cclxuXHJcbi8qIVxyXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXHJcbiAqIE1vZGlmaWVkIGJ5IEp1cml5IFwia2FuZ2F4XCIgWmF5dHNldlxyXG4gKiBPcmlnaW5hbCBjb2RlIGJ5IEVyaWsgQXJ2aWRzc29uLCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXHJcbiAqL1xyXG5cclxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXHJcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcclxuLy8gY291bGQgdXNlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8xOTk5L1JFQy14bWwtbmFtZXMtMTk5OTAxMTQvI05ULVFOYW1lXHJcbi8vIGJ1dCBmb3IgVnVlIHRlbXBsYXRlcyB3ZSBjYW4gZW5mb3JjZSBhIHNpbXBsZSBjaGFyc2V0XHJcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcclxudmFyIHFuYW1lQ2FwdHVyZSA9IFwiKCg/OlwiICsgbmNuYW1lICsgXCJcXFxcOik/XCIgKyBuY25hbWUgKyBcIilcIjtcclxudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoKFwiXjxcIiArIHFuYW1lQ2FwdHVyZSkpO1xyXG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xyXG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgoXCJePFxcXFwvXCIgKyBxbmFtZUNhcHR1cmUgKyBcIltePl0qPlwiKSk7XHJcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XHJcbi8vICM3Mjk4OiBlc2NhcGUgLSB0byBhdm9pZCBiZWluZyBwYXNlZCBhcyBIVE1MIGNvbW1lbnQgd2hlbiBpbmxpbmVkIGluIHBhZ2VcclxudmFyIGNvbW1lbnQgPSAvXjwhXFwtLS87XHJcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcclxuXHJcbnZhciBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZmFsc2U7XHJcbid4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobSwgZykge1xyXG4gIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBnID09PSAnJztcclxufSk7XHJcblxyXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcclxudmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xyXG52YXIgcmVDYWNoZSA9IHt9O1xyXG5cclxudmFyIGRlY29kaW5nTWFwID0ge1xyXG4gICcmbHQ7JzogJzwnLFxyXG4gICcmZ3Q7JzogJz4nLFxyXG4gICcmcXVvdDsnOiAnXCInLFxyXG4gICcmYW1wOyc6ICcmJyxcclxuICAnJiMxMDsnOiAnXFxuJyxcclxuICAnJiM5Oyc6ICdcXHQnXHJcbn07XHJcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXApOy9nO1xyXG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMxMHwjOSk7L2c7XHJcblxyXG4vLyAjNTk5MlxyXG52YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XHJcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XHJcblxyXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcclxuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XHJcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdOyB9KVxyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcclxuICB2YXIgc3RhY2sgPSBbXTtcclxuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcclxuICB2YXIgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcclxuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcclxuICB2YXIgaW5kZXggPSAwO1xyXG4gIHZhciBsYXN0LCBsYXN0VGFnO1xyXG4gIHdoaWxlIChodG1sKSB7XHJcbiAgICBsYXN0ID0gaHRtbDtcclxuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXHJcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xyXG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xyXG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xyXG4gICAgICAgIC8vIENvbW1lbnQ6XHJcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xyXG4gICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xyXG5cclxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcclxuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XHJcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XHJcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XHJcblxyXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcclxuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG9jdHlwZTpcclxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcclxuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XHJcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVuZCB0YWc6XHJcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xyXG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xyXG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdGFydCB0YWc6XHJcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XHJcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcclxuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xyXG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShsYXN0VGFnLCBodG1sKSkge1xyXG4gICAgICAgICAgICBhZHZhbmNlKDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xyXG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XHJcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XHJcbiAgICAgICAgd2hpbGUgKFxyXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXHJcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcclxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcclxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcclxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcclxuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XHJcbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XHJcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xyXG4gICAgICAgIGFkdmFuY2UodGV4dEVuZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xyXG4gICAgICAgIHRleHQgPSBodG1sO1xyXG4gICAgICAgIGh0bWwgPSAnJztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xyXG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xyXG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcclxuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xyXG4gICAgICB2YXIgcmVzdCQxID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XHJcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcclxuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XHJcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxyXG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XHJcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcclxuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJ1xyXG4gICAgICB9KTtcclxuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xyXG4gICAgICBodG1sID0gcmVzdCQxO1xyXG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XHJcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcclxuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XHJcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSk7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xyXG4gIHBhcnNlRW5kVGFnKCk7XHJcblxyXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcclxuICAgIGluZGV4ICs9IG47XHJcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcclxuICAgIHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcclxuICAgIGlmIChzdGFydCkge1xyXG4gICAgICB2YXIgbWF0Y2ggPSB7XHJcbiAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXHJcbiAgICAgICAgYXR0cnM6IFtdLFxyXG4gICAgICAgIHN0YXJ0OiBpbmRleFxyXG4gICAgICB9O1xyXG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XHJcbiAgICAgIHZhciBlbmQsIGF0dHI7XHJcbiAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xyXG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xyXG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XHJcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcclxuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcclxuICAgICAgICByZXR1cm4gbWF0Y2hcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XHJcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XHJcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XHJcblxyXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcclxuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XHJcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xyXG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XHJcblxyXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XHJcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xyXG4gICAgICAvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3NzhcclxuICAgICAgaWYgKElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gJiYgYXJnc1swXS5pbmRleE9mKCdcIlwiJykgPT09IC0xKSB7XHJcbiAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XHJcbiAgICAgICAgaWYgKGFyZ3NbNF0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzRdOyB9XHJcbiAgICAgICAgaWYgKGFyZ3NbNV0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzVdOyB9XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XHJcbiAgICAgIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcclxuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXHJcbiAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xyXG4gICAgICBhdHRyc1tpXSA9IHtcclxuICAgICAgICBuYW1lOiBhcmdzWzFdLFxyXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXVuYXJ5KSB7XHJcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzIH0pO1xyXG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xyXG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XHJcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XHJcbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cclxuXHJcbiAgICBpZiAodGFnTmFtZSkge1xyXG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxyXG4gICAgaWYgKHRhZ05hbWUpIHtcclxuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcclxuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXHJcbiAgICAgIHBvcyA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBvcyA+PSAwKSB7XHJcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXHJcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XHJcbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcclxuICAgICAgICAgIG9wdGlvbnMud2FyblxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxyXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcclxuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcclxuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xyXG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcclxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcclxuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcclxuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XHJcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XHJcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xyXG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBvblJFID0gL15AfF52LW9uOi87XHJcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xyXG52YXIgZm9yQWxpYXNSRSA9IC8oW15dKj8pXFxzKyg/OmlufG9mKVxccysoW15dKikvO1xyXG52YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcclxudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XHJcblxyXG52YXIgYXJnUkUgPSAvOiguKikkLztcclxudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XHJcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XHJcblxyXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xyXG5cclxuLy8gY29uZmlndXJhYmxlIHN0YXRlXHJcbnZhciB3YXJuJDI7XHJcbnZhciBkZWxpbWl0ZXJzO1xyXG52YXIgdHJhbnNmb3JtcztcclxudmFyIHByZVRyYW5zZm9ybXM7XHJcbnZhciBwb3N0VHJhbnNmb3JtcztcclxudmFyIHBsYXRmb3JtSXNQcmVUYWc7XHJcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xyXG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQgKFxyXG4gIHRhZyxcclxuICBhdHRycyxcclxuICBwYXJlbnRcclxuKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IDEsXHJcbiAgICB0YWc6IHRhZyxcclxuICAgIGF0dHJzTGlzdDogYXR0cnMsXHJcbiAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcclxuICAgIHBhcmVudDogcGFyZW50LFxyXG4gICAgY2hpbGRyZW46IFtdXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZSAoXHJcbiAgdGVtcGxhdGUsXHJcbiAgb3B0aW9uc1xyXG4pIHtcclxuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XHJcblxyXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xyXG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xyXG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XHJcblxyXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcclxuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XHJcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XHJcblxyXG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XHJcblxyXG4gIHZhciBzdGFjayA9IFtdO1xyXG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XHJcbiAgdmFyIHJvb3Q7XHJcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XHJcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xyXG4gIHZhciBpblByZSA9IGZhbHNlO1xyXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcclxuXHJcbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZykge1xyXG4gICAgaWYgKCF3YXJuZWQpIHtcclxuICAgICAgd2FybmVkID0gdHJ1ZTtcclxuICAgICAgd2FybiQyKG1zZyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcclxuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxyXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XHJcbiAgICAgIGluVlByZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XHJcbiAgICAgIGluUHJlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcclxuICAgIHdhcm46IHdhcm4kMixcclxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcclxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcclxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcclxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxyXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcclxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xyXG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXHJcbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxyXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xyXG5cclxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xyXG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcclxuICAgICAgaWYgKG5zKSB7XHJcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcclxuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxyXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xyXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXHJcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghaW5WUHJlKSB7XHJcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcclxuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcclxuICAgICAgICAgIGluVlByZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xyXG4gICAgICAgIGluUHJlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5WUHJlKSB7XHJcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xyXG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xyXG4gICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xyXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XHJcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xyXG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xyXG4gICAgICAgIC8vIGVsZW1lbnQtc2NvcGUgc3R1ZmZcclxuICAgICAgICBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xyXG4gICAgICAgICAgICB3YXJuT25jZShcclxuICAgICAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXHJcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XHJcbiAgICAgICAgICAgIHdhcm5PbmNlKFxyXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcclxuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcclxuICAgICAgaWYgKCFyb290KSB7XHJcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxyXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XHJcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcclxuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcclxuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcclxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB3YXJuT25jZShcclxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXHJcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXHJcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xyXG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcclxuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxyXG4gICAgICAgICAgY3VycmVudFBhcmVudC5wbGFpbiA9IGZhbHNlO1xyXG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XHJcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghdW5hcnkpIHtcclxuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcclxuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XHJcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXHJcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgIHZhciBsYXN0Tm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcclxuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnICYmICFpblByZSkge1xyXG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ucG9wKCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gcG9wIHN0YWNrXHJcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xyXG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcclxuICAgIH0sXHJcblxyXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0KSB7XHJcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB3YXJuT25jZShcclxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJ1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xyXG4gICAgICAgICAgICB3YXJuT25jZShcclxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmIChpc0lFICYmXHJcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcclxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgIHRleHQgPSBpblByZSB8fCB0ZXh0LnRyaW0oKVxyXG4gICAgICAgID8gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dClcclxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xyXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xyXG4gICAgICBpZiAodGV4dCkge1xyXG4gICAgICAgIHZhciByZXM7XHJcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XHJcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogMixcclxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgIHRva2VuczogcmVzLnRva2VucyxcclxuICAgICAgICAgICAgdGV4dDogdGV4dFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcclxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xyXG4gICAgICAgICAgICB0eXBlOiAzLFxyXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0KSB7XHJcbiAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaCh7XHJcbiAgICAgICAgdHlwZTogMyxcclxuICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgIGlzQ29tbWVudDogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gcm9vdFxyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xyXG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XHJcbiAgICBlbC5wcmUgPSB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xyXG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcclxuICBpZiAobCkge1xyXG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBhdHRyc1tpXSA9IHtcclxuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcclxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xyXG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xyXG4gICAgZWwucGxhaW4gPSB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xyXG5cclxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxyXG4gIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xyXG4gIGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWVsZW1lbnQuYXR0cnNMaXN0Lmxlbmd0aDtcclxuXHJcbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcclxuICBwcm9jZXNzU2xvdChlbGVtZW50KTtcclxuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcclxuICB9XHJcbiAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xyXG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xyXG4gIGlmIChleHApIHtcclxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgd2FybiQyKFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiKTtcclxuICAgIH1cclxuICAgIGVsLmtleSA9IGV4cDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XHJcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XHJcbiAgaWYgKHJlZikge1xyXG4gICAgZWwucmVmID0gcmVmO1xyXG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XHJcbiAgdmFyIGV4cDtcclxuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xyXG4gICAgdmFyIHJlcyA9IHBhcnNlRm9yKGV4cCk7XHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIGV4dGVuZChlbCwgcmVzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdhcm4kMihcclxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBwYXJzZUZvciAoZXhwKSB7XHJcbiAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XHJcbiAgaWYgKCFpbk1hdGNoKSB7IHJldHVybiB9XHJcbiAgdmFyIHJlcyA9IHt9O1xyXG4gIHJlcy5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcclxuICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKTtcclxuICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xyXG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XHJcbiAgICByZXMuYWxpYXMgPSBhbGlhcy5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKTtcclxuICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcclxuICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XHJcbiAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgcmVzLmFsaWFzID0gYWxpYXM7XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xyXG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xyXG4gIGlmIChleHApIHtcclxuICAgIGVsLmlmID0gZXhwO1xyXG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcclxuICAgICAgZXhwOiBleHAsXHJcbiAgICAgIGJsb2NrOiBlbFxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xyXG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XHJcbiAgICBpZiAoZWxzZWlmKSB7XHJcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcclxuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xyXG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcclxuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcclxuICAgICAgZXhwOiBlbC5lbHNlaWYsXHJcbiAgICAgIGJsb2NrOiBlbFxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHdhcm4kMihcclxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXHJcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xyXG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gIHdoaWxlIChpLS0pIHtcclxuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xyXG4gICAgICAgIHdhcm4kMihcclxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xyXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCJcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcclxuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xyXG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XHJcbiAgfVxyXG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xyXG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xyXG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcclxuICAgIGVsLm9uY2UgPSB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3QgKGVsKSB7XHJcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XHJcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xyXG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xyXG4gICAgICB3YXJuJDIoXHJcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcclxuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcclxuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBzbG90U2NvcGU7XHJcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XHJcbiAgICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3RTY29wZSkge1xyXG4gICAgICAgIHdhcm4kMihcclxuICAgICAgICAgIFwidGhlIFxcXCJzY29wZVxcXCIgYXR0cmlidXRlIGZvciBzY29wZWQgc2xvdHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIFwiICtcclxuICAgICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcclxuICAgICAgICAgIFwiY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIFwiICtcclxuICAgICAgICAgIFwiZGVub3RlIHNjb3BlZCBzbG90cy5cIixcclxuICAgICAgICAgIHRydWVcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xyXG4gICAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5hdHRyc01hcFsndi1mb3InXSkge1xyXG4gICAgICAgIHdhcm4kMihcclxuICAgICAgICAgIFwiQW1iaWd1b3VzIGNvbWJpbmVkIHVzYWdlIG9mIHNsb3Qtc2NvcGUgYW5kIHYtZm9yIG9uIDxcIiArIChlbC50YWcpICsgXCI+IFwiICtcclxuICAgICAgICAgIFwiKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIFwiICtcclxuICAgICAgICAgIFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlwiLFxyXG4gICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xyXG4gICAgfVxyXG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcclxuICAgIGlmIChzbG90VGFyZ2V0KSB7XHJcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcclxuICAgICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxyXG4gICAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxyXG4gICAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcclxuICAgICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xyXG4gIHZhciBiaW5kaW5nO1xyXG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcclxuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XHJcbiAgfVxyXG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xyXG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xyXG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xyXG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpc1Byb3A7XHJcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcclxuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcclxuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXHJcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcclxuICAgICAgLy8gbW9kaWZpZXJzXHJcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xyXG4gICAgICBpZiAobW9kaWZpZXJzKSB7XHJcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxyXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XHJcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xyXG4gICAgICAgIGlzUHJvcCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcclxuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCkge1xyXG4gICAgICAgICAgICBpc1Byb3AgPSB0cnVlO1xyXG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwpIHtcclxuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XHJcbiAgICAgICAgICAgIGFkZEhhbmRsZXIoXHJcbiAgICAgICAgICAgICAgZWwsXHJcbiAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXHJcbiAgICAgICAgICAgICAgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1Byb3AgfHwgKFxyXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcclxuICAgICAgICApKSB7XHJcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cclxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcclxuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyKTtcclxuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcclxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XHJcbiAgICAgICAgLy8gcGFyc2UgYXJnXHJcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XHJcbiAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xyXG4gICAgICAgIGlmIChhcmcpIHtcclxuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMpO1xyXG4gICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XHJcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXHJcbiAgICAgIHtcclxuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcclxuICAgICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgICB3YXJuJDIoXHJcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xyXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcclxuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXHJcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xyXG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXHJcbiAgICAgIC8vIGV2ZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgZWxlbWVudCBjcmVhdGlvblxyXG4gICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxyXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxyXG4gICAgICAgICAgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XHJcbiAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcclxuICB2YXIgcGFyZW50ID0gZWw7XHJcbiAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XHJcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcclxuICBpZiAobWF0Y2gpIHtcclxuICAgIHZhciByZXQgPSB7fTtcclxuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XHJcbiAgICByZXR1cm4gcmV0XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XHJcbiAgdmFyIG1hcCA9IHt9O1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXHJcbiAgICApIHtcclxuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XHJcbiAgICB9XHJcbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcclxuICB9XHJcbiAgcmV0dXJuIG1hcFxyXG59XHJcblxyXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcclxuZnVuY3Rpb24gaXNUZXh0VGFnIChlbCkge1xyXG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcclxuICByZXR1cm4gKFxyXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XHJcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXHJcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XHJcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXHJcbiAgICApKVxyXG4gIClcclxufVxyXG5cclxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XHJcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcclxuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XHJcbiAgdmFyIHJlcyA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XHJcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XHJcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcclxuICAgICAgcmVzLnB1c2goYXR0cik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcclxuICB2YXIgX2VsID0gZWw7XHJcbiAgd2hpbGUgKF9lbCkge1xyXG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xyXG4gICAgICB3YXJuJDIoXHJcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXHJcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xyXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xyXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xyXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qKlxyXG4gKiBFeHBhbmQgaW5wdXRbdi1tb2RlbF0gd2l0aCBkeWFubWljIHR5cGUgYmluZGluZ3MgaW50byB2LWlmLWVsc2UgY2hhaW5zXHJcbiAqIFR1cm4gdGhpczpcclxuICogICA8aW5wdXQgdi1tb2RlbD1cImRhdGFbdHlwZV1cIiA6dHlwZT1cInR5cGVcIj5cclxuICogaW50byB0aGlzOlxyXG4gKiAgIDxpbnB1dCB2LWlmPVwidHlwZSA9PT0gJ2NoZWNrYm94J1wiIHR5cGU9XCJjaGVja2JveFwiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XHJcbiAqICAgPGlucHV0IHYtZWxzZS1pZj1cInR5cGUgPT09ICdyYWRpbydcIiB0eXBlPVwicmFkaW9cIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxyXG4gKiAgIDxpbnB1dCB2LWVsc2UgOnR5cGU9XCJ0eXBlXCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cclxuICovXHJcblxyXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xyXG4gIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcclxuICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcclxuICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHR5cGVCaW5kaW5nO1xyXG4gICAgaWYgKG1hcFsnOnR5cGUnXSB8fCBtYXBbJ3YtYmluZDp0eXBlJ10pIHtcclxuICAgICAgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcclxuICAgIH1cclxuICAgIGlmICghbWFwLnR5cGUgJiYgIXR5cGVCaW5kaW5nICYmIG1hcFsndi1iaW5kJ10pIHtcclxuICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIiArIChtYXBbJ3YtYmluZCddKSArIFwiKS50eXBlXCI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XHJcbiAgICAgIHZhciBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XHJcbiAgICAgIHZhciBpZkNvbmRpdGlvbkV4dHJhID0gaWZDb25kaXRpb24gPyAoXCImJihcIiArIGlmQ29uZGl0aW9uICsgXCIpXCIpIDogXCJcIjtcclxuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcclxuICAgICAgdmFyIGVsc2VJZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnLCB0cnVlKTtcclxuICAgICAgLy8gMS4gY2hlY2tib3hcclxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xyXG4gICAgICAvLyBwcm9jZXNzIGZvciBvbiB0aGUgbWFpbiBub2RlXHJcbiAgICAgIHByb2Nlc3NGb3IoYnJhbmNoMCk7XHJcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcclxuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMCwgb3B0aW9ucyk7XHJcbiAgICAgIGJyYW5jaDAucHJvY2Vzc2VkID0gdHJ1ZTsgLy8gcHJldmVudCBpdCBmcm9tIGRvdWJsZS1wcm9jZXNzZWRcclxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xyXG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XHJcbiAgICAgICAgZXhwOiBicmFuY2gwLmlmLFxyXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXHJcbiAgICAgIH0pO1xyXG4gICAgICAvLyAyLiBhZGQgcmFkaW8gZWxzZS1pZiBjb25kaXRpb25cclxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xyXG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDEsICd2LWZvcicsIHRydWUpO1xyXG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XHJcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xyXG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XHJcbiAgICAgICAgZXhwOiBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J3JhZGlvJ1wiICsgaWZDb25kaXRpb25FeHRyYSxcclxuICAgICAgICBibG9jazogYnJhbmNoMVxyXG4gICAgICB9KTtcclxuICAgICAgLy8gMy4gb3RoZXJcclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xyXG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDIsICd2LWZvcicsIHRydWUpO1xyXG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcclxuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XHJcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcclxuICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxyXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKGhhc0Vsc2UpIHtcclxuICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xyXG4gICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xyXG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYnJhbmNoMFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xyXG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcclxufVxyXG5cclxudmFyIG1vZGVsJDIgPSB7XHJcbiAgcHJlVHJhbnNmb3JtTm9kZTogcHJlVHJhbnNmb3JtTm9kZVxyXG59XHJcblxyXG52YXIgbW9kdWxlcyQxID0gW1xyXG4gIGtsYXNzJDEsXHJcbiAgc3R5bGUkMSxcclxuICBtb2RlbCQyXHJcbl1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xyXG4gIGlmIChkaXIudmFsdWUpIHtcclxuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XHJcbiAgaWYgKGRpci52YWx1ZSkge1xyXG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcclxuICBtb2RlbDogbW9kZWwsXHJcbiAgdGV4dDogdGV4dCxcclxuICBodG1sOiBodG1sXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGJhc2VPcHRpb25zID0ge1xyXG4gIGV4cGVjdEhUTUw6IHRydWUsXHJcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxyXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcclxuICBpc1ByZVRhZzogaXNQcmVUYWcsXHJcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcclxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXHJcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcclxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxyXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxyXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxyXG59O1xyXG5cclxuLyogICovXHJcblxyXG52YXIgaXNTdGF0aWNLZXk7XHJcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XHJcblxyXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xyXG5cclxuLyoqXHJcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXHJcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcclxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cclxuICpcclxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XHJcbiAqXHJcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cclxuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xyXG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cclxuICovXHJcbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XHJcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XHJcbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XHJcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xyXG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXHJcbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xyXG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cclxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcclxuICByZXR1cm4gbWFrZU1hcChcclxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArXHJcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcclxuICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xyXG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xyXG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXHJcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXHJcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXHJcbiAgICBpZiAoXHJcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXHJcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcclxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xyXG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xyXG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xyXG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcclxuICAgICAgICB2YXIgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrO1xyXG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XHJcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcclxuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcclxuICBpZiAobm9kZS50eXBlID09PSAxKSB7XHJcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XHJcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xyXG4gICAgfVxyXG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcclxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXHJcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXHJcbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcclxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcclxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXHJcbiAgICApKSB7XHJcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xyXG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcclxuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XHJcbiAgICByZXR1cm4gdHJ1ZVxyXG4gIH1cclxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxyXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xyXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxyXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cclxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XHJcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcclxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxyXG4gICkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XHJcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XHJcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XHJcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5mb3IpIHtcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xyXG52YXIgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcclxuXHJcbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXHJcbnZhciBrZXlDb2RlcyA9IHtcclxuICBlc2M6IDI3LFxyXG4gIHRhYjogOSxcclxuICBlbnRlcjogMTMsXHJcbiAgc3BhY2U6IDMyLFxyXG4gIHVwOiAzOCxcclxuICBsZWZ0OiAzNyxcclxuICByaWdodDogMzksXHJcbiAgZG93bjogNDAsXHJcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cclxufTtcclxuXHJcbi8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcclxudmFyIGtleU5hbWVzID0ge1xyXG4gIGVzYzogJ0VzY2FwZScsXHJcbiAgdGFiOiAnVGFiJyxcclxuICBlbnRlcjogJ0VudGVyJyxcclxuICBzcGFjZTogJyAnLFxyXG4gIC8vICM3ODA2OiBJRTExIHVzZXMga2V5IG5hbWVzIHdpdGhvdXQgYEFycm93YCBwcmVmaXggZm9yIGFycm93IGtleXMuXHJcbiAgdXA6IFsnVXAnLCAnQXJyb3dVcCddLFxyXG4gIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcclxuICByaWdodDogWydSaWdodCcsICdBcnJvd1JpZ2h0J10sXHJcbiAgZG93bjogWydEb3duJywgJ0Fycm93RG93biddLFxyXG4gICdkZWxldGUnOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnXVxyXG59O1xyXG5cclxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxyXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXHJcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xyXG5cclxudmFyIG1vZGlmaWVyQ29kZSA9IHtcclxuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXHJcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXHJcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcclxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcclxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxyXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcclxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcclxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxyXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcclxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxyXG4gIGV2ZW50cyxcclxuICBpc05hdGl2ZSxcclxuICB3YXJuXHJcbikge1xyXG4gIHZhciByZXMgPSBpc05hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcclxuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xyXG4gICAgcmVzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIChnZW5IYW5kbGVyKG5hbWUsIGV2ZW50c1tuYW1lXSkpICsgXCIsXCI7XHJcbiAgfVxyXG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKFxyXG4gIG5hbWUsXHJcbiAgaGFuZGxlclxyXG4pIHtcclxuICBpZiAoIWhhbmRsZXIpIHtcclxuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xyXG4gIH1cclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcclxuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcclxuICB9XHJcblxyXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcclxuICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XHJcblxyXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcclxuICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcclxuICAgICAgcmV0dXJuIGhhbmRsZXIudmFsdWVcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY29kZSA9ICcnO1xyXG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xyXG4gICAgdmFyIGtleXMgPSBbXTtcclxuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xyXG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcclxuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XHJcbiAgICAgICAgLy8gbGVmdC9yaWdodFxyXG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XHJcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XHJcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XHJcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxyXG4gICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuICFtb2RpZmllcnNba2V5TW9kaWZpZXJdOyB9KVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcclxuICAgICAgICAgICAgLmpvaW4oJ3x8JylcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XHJcbiAgICB9XHJcbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xyXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xyXG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcclxuICAgIH1cclxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxyXG4gICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKCRldmVudClcIilcclxuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxyXG4gICAgICAgID8gKFwicmV0dXJuIChcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXHJcbiAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XHJcbiAgcmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XHJcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xyXG4gIGlmIChrZXlWYWwpIHtcclxuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxyXG4gIH1cclxuICB2YXIga2V5Q29kZSA9IGtleUNvZGVzW2tleV07XHJcbiAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xyXG4gIHJldHVybiAoXHJcbiAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcclxuICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcclxuICAgIChKU09OLnN0cmluZ2lmeShrZXlDb2RlKSkgKyBcIixcIiArXHJcbiAgICBcIiRldmVudC5rZXksXCIgK1xyXG4gICAgXCJcIiArIChKU09OLnN0cmluZ2lmeShrZXlOYW1lKSkgK1xyXG4gICAgXCIpXCJcclxuICApXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcclxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xyXG4gICAgd2FybihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XHJcbiAgfVxyXG4gIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcclxuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XHJcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIFwiLFwiICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJ3RydWUnIDogJ2ZhbHNlJykgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnN5bmMgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXHJcbiAgfTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XHJcbiAgb246IG9uLFxyXG4gIGJpbmQ6IGJpbmQkMSxcclxuICBjbG9hazogbm9vcFxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBDb2RlZ2VuU3RhdGUgPSBmdW5jdGlvbiBDb2RlZ2VuU3RhdGUgKG9wdGlvbnMpIHtcclxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcclxuICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcclxuICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcclxuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XHJcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XHJcbiAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcclxuICB0aGlzLm9uY2VJZCA9IDA7XHJcbiAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcclxufTtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxyXG4gIGFzdCxcclxuICBvcHRpb25zXHJcbikge1xyXG4gIHZhciBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XHJcbiAgdmFyIGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCwgc3RhdGUpIDogJ19jKFwiZGl2XCIpJztcclxuICByZXR1cm4ge1xyXG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXHJcbiAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRlLnN0YXRpY1JlbmRlckZuc1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwsIHN0YXRlKSB7XHJcbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xyXG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXHJcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XHJcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXHJcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xyXG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXHJcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcclxuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXHJcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQpIHtcclxuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXHJcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xyXG4gICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKVxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxyXG4gICAgdmFyIGNvZGU7XHJcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XHJcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGRhdGEgPSBlbC5wbGFpbiA/IHVuZGVmaW5lZCA6IGdlbkRhdGEkMihlbCwgc3RhdGUpO1xyXG5cclxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcclxuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcclxuICAgIH1cclxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvZGVcclxuICB9XHJcbn1cclxuXHJcbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XHJcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XHJcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcclxuICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCIpKTtcclxuICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxyXG59XHJcblxyXG4vLyB2LW9uY2VcclxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XHJcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XHJcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xyXG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcclxuICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XHJcbiAgICB2YXIga2V5ID0gJyc7XHJcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xyXG4gICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICBpZiAocGFyZW50LmZvcikge1xyXG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgfVxyXG4gICAgaWYgKCFrZXkpIHtcclxuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGUud2FybihcclxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIlxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuSWYgKFxyXG4gIGVsLFxyXG4gIHN0YXRlLFxyXG4gIGFsdEdlbixcclxuICBhbHRFbXB0eVxyXG4pIHtcclxuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxyXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxyXG4gIGNvbmRpdGlvbnMsXHJcbiAgc3RhdGUsXHJcbiAgYWx0R2VuLFxyXG4gIGFsdEVtcHR5XHJcbikge1xyXG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcclxuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcclxuICB9XHJcblxyXG4gIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XHJcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcclxuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkpKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcclxuICB9XHJcblxyXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcclxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xyXG4gICAgcmV0dXJuIGFsdEdlblxyXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXHJcbiAgICAgIDogZWwub25jZVxyXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXHJcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbkZvciAoXHJcbiAgZWwsXHJcbiAgc3RhdGUsXHJcbiAgYWx0R2VuLFxyXG4gIGFsdEhlbHBlclxyXG4pIHtcclxuICB2YXIgZXhwID0gZWwuZm9yO1xyXG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xyXG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcclxuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XHJcblxyXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXHJcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxyXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXHJcbiAgICAhZWwua2V5XHJcbiAgKSB7XHJcbiAgICBzdGF0ZS53YXJuKFxyXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcclxuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXHJcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcclxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cclxuICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXHJcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xyXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcclxuICAgICd9KSdcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcclxuICB2YXIgZGF0YSA9ICd7JztcclxuXHJcbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cclxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxyXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xyXG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxyXG5cclxuICAvLyBrZXlcclxuICBpZiAoZWwua2V5KSB7XHJcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcclxuICB9XHJcbiAgLy8gcmVmXHJcbiAgaWYgKGVsLnJlZikge1xyXG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XHJcbiAgfVxyXG4gIGlmIChlbC5yZWZJbkZvcikge1xyXG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XHJcbiAgfVxyXG4gIC8vIHByZVxyXG4gIGlmIChlbC5wcmUpIHtcclxuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcclxuICB9XHJcbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcclxuICBpZiAoZWwuY29tcG9uZW50KSB7XHJcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xyXG4gIH1cclxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xyXG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcclxuICB9XHJcbiAgLy8gYXR0cmlidXRlc1xyXG4gIGlmIChlbC5hdHRycykge1xyXG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xyXG4gIH1cclxuICAvLyBET00gcHJvcHNcclxuICBpZiAoZWwucHJvcHMpIHtcclxuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcclxuICB9XHJcbiAgLy8gZXZlbnQgaGFuZGxlcnNcclxuICBpZiAoZWwuZXZlbnRzKSB7XHJcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcclxuICB9XHJcbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xyXG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcclxuICB9XHJcbiAgLy8gc2xvdCB0YXJnZXRcclxuICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXHJcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xyXG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcclxuICB9XHJcbiAgLy8gc2NvcGVkIHNsb3RzXHJcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XHJcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xyXG4gIH1cclxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxyXG4gIGlmIChlbC5tb2RlbCkge1xyXG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xyXG4gIH1cclxuICAvLyBpbmxpbmUtdGVtcGxhdGVcclxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcclxuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XHJcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcclxuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xyXG4gICAgfVxyXG4gIH1cclxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcclxuICAvLyB2LWJpbmQgZGF0YSB3cmFwXHJcbiAgaWYgKGVsLndyYXBEYXRhKSB7XHJcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XHJcbiAgfVxyXG4gIC8vIHYtb24gZGF0YSB3cmFwXHJcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcclxuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xyXG4gIH1cclxuICByZXR1cm4gZGF0YVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcclxuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XHJcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XHJcbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xyXG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XHJcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XHJcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBkaXIgPSBkaXJzW2ldO1xyXG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xyXG4gICAgdmFyIGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xyXG4gICAgaWYgKGdlbikge1xyXG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxyXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXHJcbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XHJcbiAgICB9XHJcbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcclxuICAgICAgaGFzUnVudGltZSA9IHRydWU7XHJcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoaGFzUnVudGltZSkge1xyXG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcclxuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XHJcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcclxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMVxyXG4gICkpIHtcclxuICAgIHN0YXRlLndhcm4oJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xyXG4gIH1cclxuICBpZiAoYXN0LnR5cGUgPT09IDEpIHtcclxuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcclxuICBzbG90cyxcclxuICBzdGF0ZVxyXG4pIHtcclxuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgKE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0sIHN0YXRlKVxyXG4gICAgfSkuam9pbignLCcpKSArIFwiXSlcIilcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXHJcbiAga2V5LFxyXG4gIGVsLFxyXG4gIHN0YXRlXHJcbikge1xyXG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xyXG4gICAgcmV0dXJuIGdlbkZvclNjb3BlZFNsb3Qoa2V5LCBlbCwgc3RhdGUpXHJcbiAgfVxyXG4gIHZhciBmbiA9IFwiZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLnNsb3RTY29wZSkpICsgXCIpe1wiICtcclxuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xyXG4gICAgICA/IGVsLmlmXHJcbiAgICAgICAgPyAoKGVsLmlmKSArIFwiP1wiICsgKGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCcpICsgXCI6dW5kZWZpbmVkXCIpXHJcbiAgICAgICAgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnXHJcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xyXG4gIHJldHVybiAoXCJ7a2V5OlwiICsga2V5ICsgXCIsZm46XCIgKyBmbiArIFwifVwiKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5Gb3JTY29wZWRTbG90IChcclxuICBrZXksXHJcbiAgZWwsXHJcbiAgc3RhdGVcclxuKSB7XHJcbiAgdmFyIGV4cCA9IGVsLmZvcjtcclxuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcclxuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XHJcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xyXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxyXG4gIHJldHVybiBcIl9sKChcIiArIGV4cCArIFwiKSxcIiArXHJcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xyXG4gICAgICBcInJldHVybiBcIiArIChnZW5TY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKSkgK1xyXG4gICAgJ30pJ1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXHJcbiAgZWwsXHJcbiAgc3RhdGUsXHJcbiAgY2hlY2tTa2lwLFxyXG4gIGFsdEdlbkVsZW1lbnQsXHJcbiAgYWx0R2VuTm9kZVxyXG4pIHtcclxuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcclxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xyXG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXHJcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgIGVsJDEuZm9yICYmXHJcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXHJcbiAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpXHJcbiAgICB9XHJcbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcclxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXHJcbiAgICAgIDogMDtcclxuICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XHJcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUpIDogJycpKVxyXG4gIH1cclxufVxyXG5cclxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxyXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxyXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXHJcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcclxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxyXG4gIGNoaWxkcmVuLFxyXG4gIG1heWJlQ29tcG9uZW50XHJcbikge1xyXG4gIHZhciByZXMgPSAwO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcclxuICAgICAgY29udGludWVcclxuICAgIH1cclxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XHJcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcclxuICAgICAgcmVzID0gMjtcclxuICAgICAgYnJlYWtcclxuICAgIH1cclxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcclxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XHJcbiAgICAgIHJlcyA9IDE7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xyXG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSwgc3RhdGUpIHtcclxuICBpZiAobm9kZS50eXBlID09PSAxKSB7XHJcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcclxuICB9IGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcclxuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XHJcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxyXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcclxuICByZXR1cm4gKFwiX2UoXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcIilcIilcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XHJcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcclxuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xyXG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XHJcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgKFwie1wiICsgKGVsLmF0dHJzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChjYW1lbGl6ZShhLm5hbWUpKSArIFwiOlwiICsgKGEudmFsdWUpKTsgfSkuam9pbignLCcpKSArIFwifVwiKTtcclxuICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcclxuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xyXG4gICAgcmVzICs9IFwiLG51bGxcIjtcclxuICB9XHJcbiAgaWYgKGF0dHJzKSB7XHJcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcclxuICB9XHJcbiAgaWYgKGJpbmQkJDEpIHtcclxuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xyXG4gIH1cclxuICByZXR1cm4gcmVzICsgJyknXHJcbn1cclxuXHJcbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcclxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcclxuICBjb21wb25lbnROYW1lLFxyXG4gIGVsLFxyXG4gIHN0YXRlXHJcbikge1xyXG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XHJcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcclxuICB2YXIgcmVzID0gJyc7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAge1xyXG4gICAgICByZXMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArICh0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSkpICsgXCIsXCI7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXHJcbn1cclxuXHJcbi8vICMzODk1LCAjNDI2OFxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcclxuICByZXR1cm4gdGV4dFxyXG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXHJcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5JylcclxufVxyXG5cclxuLyogICovXHJcblxyXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxyXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXHJcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxyXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xyXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXHJcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXHJcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XHJcblxyXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xyXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcclxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xyXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcclxuXHJcbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcclxudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcclxuXHJcbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXHJcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XHJcbiAgdmFyIGVycm9ycyA9IFtdO1xyXG4gIGlmIChhc3QpIHtcclxuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XHJcbiAgfVxyXG4gIHJldHVybiBlcnJvcnNcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCBlcnJvcnMpIHtcclxuICBpZiAobm9kZS50eXBlID09PSAxKSB7XHJcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcclxuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcclxuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xyXG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIGVycm9ycyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xyXG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcclxuICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcclxuICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcclxuICBpZiAoa2V5d29yZE1hdGNoICYmIHN0aXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcclxuICAgIGVycm9ycy5wdXNoKFxyXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xyXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXHJcbiAgICApO1xyXG4gIH1cclxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCBlcnJvcnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XHJcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCBlcnJvcnMpO1xyXG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCBlcnJvcnMpO1xyXG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcclxuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoXHJcbiAgaWRlbnQsXHJcbiAgdHlwZSxcclxuICB0ZXh0LFxyXG4gIGVycm9yc1xyXG4pIHtcclxuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbmV3IEZ1bmN0aW9uKChcInZhciBcIiArIGlkZW50ICsgXCI9X1wiKSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XHJcbiAgdHJ5IHtcclxuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xyXG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xyXG4gICAgICBlcnJvcnMucHVzaChcclxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXHJcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIlxcbiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKVxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXJyb3JzLnB1c2goXHJcbiAgICAgICAgXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcclxuICAgICAgICBcIiAgICBcIiArIGV4cCArIFwiXFxuXFxuXCIgK1xyXG4gICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XHJcbiAgICByZXR1cm4gbm9vcFxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xyXG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxyXG4gICAgdGVtcGxhdGUsXHJcbiAgICBvcHRpb25zLFxyXG4gICAgdm1cclxuICApIHtcclxuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xyXG4gICAgdmFyIHdhcm4kJDEgPSBvcHRpb25zLndhcm4gfHwgd2FybjtcclxuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICB7XHJcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xyXG4gICAgICAgICAgd2FybiQkMShcclxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xyXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXHJcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXHJcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcclxuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBjaGVjayBjYWNoZVxyXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xyXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcclxuICAgICAgOiB0ZW1wbGF0ZTtcclxuICAgIGlmIChjYWNoZVtrZXldKSB7XHJcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29tcGlsZVxyXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcclxuICAgIHtcclxuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgd2FybiQkMShcclxuICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcclxuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcclxuICAgICAgICAgIHZtXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXHJcbiAgICB2YXIgcmVzID0ge307XHJcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcclxuICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcclxuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XHJcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxyXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cclxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAge1xyXG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgIHdhcm4kJDEoXHJcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xyXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcclxuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xyXG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgICAgdm1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xyXG4gICAgZnVuY3Rpb24gY29tcGlsZSAoXHJcbiAgICAgIHRlbXBsYXRlLFxyXG4gICAgICBvcHRpb25zXHJcbiAgICApIHtcclxuICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xyXG4gICAgICB2YXIgZXJyb3JzID0gW107XHJcbiAgICAgIHZhciB0aXBzID0gW107XHJcbiAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwKSB7XHJcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcclxuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XHJcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XHJcbiAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcclxuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcclxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxyXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcclxuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcclxuICAgICAge1xyXG4gICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCkpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcclxuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XHJcbiAgICAgIHJldHVybiBjb21waWxlZFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXHJcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG4vLyBgY3JlYXRlQ29tcGlsZXJDcmVhdG9yYCBhbGxvd3MgY3JlYXRpbmcgY29tcGlsZXJzIHRoYXQgdXNlIGFsdGVybmF0aXZlXHJcbi8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cclxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXHJcbnZhciBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXHJcbiAgdGVtcGxhdGUsXHJcbiAgb3B0aW9uc1xyXG4pIHtcclxuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcclxuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcclxuICAgIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XHJcbiAgfVxyXG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcclxuICByZXR1cm4ge1xyXG4gICAgYXN0OiBhc3QsXHJcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxyXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xyXG4gIH1cclxufSk7XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcclxudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcclxuXHJcbi8qICAqL1xyXG5cclxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcclxudmFyIGRpdjtcclxuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XHJcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIGRpdi5pbm5lckhUTUwgPSBocmVmID8gXCI8YSBocmVmPVxcXCJcXG5cXFwiLz5cIiA6IFwiPGRpdiBhPVxcXCJcXG5cXFwiLz5cIjtcclxuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxyXG59XHJcblxyXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxyXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XHJcbi8vICM2ODI4OiBjaHJvbWUgZW5jb2RlcyBjb250ZW50IGluIGFbaHJlZl1cclxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xyXG5cclxuLyogICovXHJcblxyXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xyXG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcclxuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXHJcbn0pO1xyXG5cclxudmFyIG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XHJcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxyXG4gIGVsLFxyXG4gIGh5ZHJhdGluZ1xyXG4pIHtcclxuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcclxuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcclxuICAgICk7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xyXG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXHJcbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xyXG4gICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcclxuICAgIGlmICh0ZW1wbGF0ZSkge1xyXG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xyXG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xyXG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcclxuICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XHJcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChlbCkge1xyXG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGVtcGxhdGUpIHtcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xyXG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xyXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcclxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcclxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXHJcbiAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcclxuICAgICAgfSwgdGhpcyk7XHJcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xyXG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XHJcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xyXG5cclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xyXG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XHJcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcclxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XHJcbiAgaWYgKGVsLm91dGVySFRNTCkge1xyXG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcclxuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXHJcbiAgfVxyXG59XHJcblxyXG5WdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcclxuXHJcbnJldHVybiBWdWU7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvanMvdnVlanMvdnVlLmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sInNvdXJjZVJvb3QiOiIifQ==
